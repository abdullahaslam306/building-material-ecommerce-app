/*!
 * FullCalendar v2.9.0
 * Docs & License: http://fullcalendar.io/
 * (c) 2016 Adam Shaw
 */
!(function (a) { typeof define === 'function' && define.amd ? define(['jquery', 'moment'], a) : typeof exports === 'object' ? module.exports = a(require('jquery'), require('moment')) : a(jQuery, moment); }((a, b) => {
  function c(a) { return W(a, Ya); } function d(b) { let c; const d = { views: b.views || {} }; return a.each(b, (b, e) => { b != 'views' && (a.isPlainObject(e) && !/(time|duration|interval)$/i.test(b) && a.inArray(b, Ya) == -1 ? (c = null, a.each(e, (a, e) => { /^(month|week|day|default|basic(Week|Day)?|agenda(Week|Day)?)$/.test(a) ? (d.views[a] || (d.views[a] = {}), d.views[a][b] = e) : (c || (c = {}), c[a] = e); }), c && (d[b] = c)) : d[b] = e); }), d; } function e(a, b) { b.left && a.css({ 'border-left-width': 1, 'margin-left': b.left - 1 }), b.right && a.css({ 'border-right-width': 1, 'margin-right': b.right - 1 }); } function f(a) {
    a.css({
      'margin-left': '', 'margin-right': '', 'border-left-width': '', 'border-right-width': '',
    });
  } function g() { a('body').addClass('fc-not-allowed'); } function h() { a('body').removeClass('fc-not-allowed'); } function i(b, c, d) { let e = Math.floor(c / b.length); let f = Math.floor(c - e * (b.length - 1)); const g = []; const h = []; const i = []; let k = 0; j(b), b.each((c, d) => { const j = c === b.length - 1 ? f : e; const l = a(d).outerHeight(!0); j > l ? (g.push(d), h.push(l), i.push(a(d).height())) : k += l; }), d && (c -= k, e = Math.floor(c / g.length), f = Math.floor(c - e * (g.length - 1))), a(g).each((b, c) => { const d = b === g.length - 1 ? f : e; const j = h[b]; const k = i[b]; const l = d - (j - k); d > j && a(c).height(l); }); } function j(a) { a.height(''); } function k(b) { let c = 0; return b.find('> span').each((b, d) => { const e = a(d).outerWidth(); e > c && (c = e); }), c++, b.width(c), c; } function l(a, b) { let c; const d = a.add(b); return d.css({ position: 'relative', left: -1 }), c = a.outerHeight() - b.outerHeight(), d.css({ position: '', left: '' }), c; } function m(b) { const c = b.css('position'); const d = b.parents().filter(function () { const b = a(this); return /(auto|scroll)/.test(b.css('overflow') + b.css('overflow-y') + b.css('overflow-x')); }).eq(0); return c !== 'fixed' && d.length ? d : a(b[0].ownerDocument || document); } function n(a, b) {
    const c = a.offset(); const d = c.left - (b ? b.left : 0); const e = c.top - (b ? b.top : 0); return {
      left: d, right: d + a.outerWidth(), top: e, bottom: e + a.outerHeight(),
    };
  } function o(a, b) {
    const c = a.offset(); const d = q(a); const e = c.left + t(a, 'border-left-width') + d.left - (b ? b.left : 0); const f = c.top + t(a, 'border-top-width') + d.top - (b ? b.top : 0); return {
      left: e, right: e + a[0].clientWidth, top: f, bottom: f + a[0].clientHeight,
    };
  } function p(a, b) {
    const c = a.offset(); const d = c.left + t(a, 'border-left-width') + t(a, 'padding-left') - (b ? b.left : 0); const e = c.top + t(a, 'border-top-width') + t(a, 'padding-top') - (b ? b.top : 0); return {
      left: d, right: d + a.width(), top: e, bottom: e + a.height(),
    };
  } function q(a) {
    const b = a.innerWidth() - a[0].clientWidth; const c = {
      left: 0, right: 0, top: 0, bottom: a.innerHeight() - a[0].clientHeight,
    }; return r() && a.css('direction') == 'rtl' ? c.left = b : c.right = b, c;
  } function r() { return Za === null && (Za = s()), Za; } function s() {
    const b = a('<div><div/></div>').css({
      position: 'absolute', top: -1e3, left: 0, border: 0, padding: 0, overflow: 'scroll', direction: 'rtl',
    }).appendTo('body'); const c = b.children(); const d = c.offset().left > b.offset().left; return b.remove(), d;
  } function t(a, b) { return parseFloat(a.css(b)) || 0; } function u(a) { return a.which == 1 && !a.ctrlKey; } function v(a) { if (void 0 !== a.pageX) return a.pageX; const b = a.originalEvent.touches; return b ? b[0].pageX : void 0; } function w(a) { if (void 0 !== a.pageY) return a.pageY; const b = a.originalEvent.touches; return b ? b[0].pageY : void 0; } function x(a) { return /^touch/.test(a.type); } function y(a) { a.addClass('fc-unselectable').on('selectstart', z); } function z(a) { a.preventDefault(); } function A(a) { return window.addEventListener ? (window.addEventListener('scroll', a, !0), !0) : !1; } function B(a) { return window.removeEventListener ? (window.removeEventListener('scroll', a, !0), !0) : !1; } function C(a, b) {
    const c = {
      left: Math.max(a.left, b.left), right: Math.min(a.right, b.right), top: Math.max(a.top, b.top), bottom: Math.min(a.bottom, b.bottom),
    }; return c.left < c.right && c.top < c.bottom ? c : !1;
  } function D(a, b) { return { left: Math.min(Math.max(a.left, b.left), b.right), top: Math.min(Math.max(a.top, b.top), b.bottom) }; } function E(a) { return { left: (a.left + a.right) / 2, top: (a.top + a.bottom) / 2 }; } function F(a, b) { return { left: a.left - b.left, top: a.top - b.top }; } function G(b) { let c; let d; const e = []; let f = []; for (typeof b === 'string' ? f = b.split(/\s*,\s*/) : typeof b === 'function' ? f = [b] : a.isArray(b) && (f = b), c = 0; c < f.length; c++)d = f[c], typeof d === 'string' ? e.push(d.charAt(0) == '-' ? { field: d.substring(1), order: -1 } : { field: d, order: 1 }) : typeof d === 'function' && e.push({ func: d }); return e; } function H(a, b, c) { let d; let e; for (d = 0; d < c.length; d++) if (e = I(a, b, c[d])) return e; return 0; } function I(a, b, c) { return c.func ? c.func(a, b) : J(a[c.field], b[c.field]) * (c.order || 1); } function J(b, c) { return b || c ? c == null ? -1 : b == null ? 1 : a.type(b) === 'string' || a.type(c) === 'string' ? String(b).localeCompare(String(c)) : b - c : 0; } function K(a, b) {
    let c; let d; let e; let f; const g = a.start; const h = a.end; const i = b.start; const j = b.end; return h > i && j > g ? (g >= i ? (c = g.clone(), e = !0) : (c = i.clone(), e = !1), j >= h ? (d = h.clone(), f = !0) : (d = j.clone(), f = !1), {
      start: c, end: d, isStart: e, isEnd: f,
    }) : void 0;
  } function L(a, c) { return b.duration({ days: a.clone().stripTime().diff(c.clone().stripTime(), 'days'), ms: a.time() - c.time() }); } function M(a, c) { return b.duration({ days: a.clone().stripTime().diff(c.clone().stripTime(), 'days') }); } function N(a, c, d) { return b.duration(Math.round(a.diff(c, d, !0)), d); } function O(a, b) { let c; let d; let e; for (c = 0; c < _a.length && (d = _a[c], e = P(d, a, b), !(e >= 1 && ha(e))); c++);return d; } function P(a, c, d) { return d != null ? d.diff(c, a, !0) : b.isDuration(c) ? c.as(a) : c.end.diff(c.start, a, !0); } function Q(a, b, c) { let d; return T(c) ? (b - a) / c : (d = c.asMonths(), Math.abs(d) >= 1 && ha(d) ? b.diff(a, 'months', !0) / d : b.diff(a, 'days', !0) / c.asDays()); } function R(a, b) { let c; let d; return T(a) || T(b) ? a / b : (c = a.asMonths(), d = b.asMonths(), Math.abs(c) >= 1 && ha(c) && Math.abs(d) >= 1 && ha(d) ? c / d : a.asDays() / b.asDays()); } function S(a, c) { let d; return T(a) ? b.duration(a * c) : (d = a.asMonths(), Math.abs(d) >= 1 && ha(d) ? b.duration({ months: d * c }) : b.duration({ days: a.asDays() * c })); } function T(a) { return Boolean(a.hours() || a.minutes() || a.seconds() || a.milliseconds()); } function U(a) { return Object.prototype.toString.call(a) === '[object Date]' || a instanceof Date; } function V(a) { return /^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(a); } function W(a, b) { let c; let d; let e; let f; let g; let h; const i = {}; if (b) for (c = 0; c < b.length; c++) { for (d = b[c], e = [], f = a.length - 1; f >= 0; f--) if (g = a[f][d], typeof g === 'object')e.unshift(g); else if (void 0 !== g) { i[d] = g; break; }e.length && (i[d] = W(e)); } for (c = a.length - 1; c >= 0; c--) { h = a[c]; for (d in h)d in i || (i[d] = h[d]); } return i; } function X(a) { const b = function () {}; return b.prototype = a, new b(); } function Y(a, b) { for (const c in a)$(a, c) && (b[c] = a[c]); } function Z(a, b) { let c; let d; const e = ['constructor', 'toString', 'valueOf']; for (c = 0; c < e.length; c++)d = e[c], a[d] !== Object.prototype[d] && (b[d] = a[d]); } function $(a, b) { return db.call(a, b); } function _(b) { return /undefined|null|boolean|number|string/.test(a.type(b)); } function aa(b, c, d) { if (a.isFunction(b) && (b = [b]), b) { let e; let f; for (e = 0; e < b.length; e++)f = b[e].apply(c, d) || f; return f; } } function ba() { for (let a = 0; a < arguments.length; a++) if (void 0 !== arguments[a]) return arguments[a]; } function ca(a) {
    return (`${a}`).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/'/g, '&#039;')
      .replace(/"/g, '&quot;')
      .replace(/\n/g, '<br />');
  } function da(a) { return a.replace(/&.*?;/g, ''); } function ea(b) { const c = []; return a.each(b, (a, b) => { b != null && c.push(`${a}:${b}`); }), c.join(';'); } function fa(a) { return a.charAt(0).toUpperCase() + a.slice(1); } function ga(a, b) { return a - b; } function ha(a) { return a % 1 === 0; } function ia(a, b) { const c = a[b]; return function () { return c.apply(a, arguments); }; } function ja(a, b, c) { let d; let e; let f; let g; let h; var i = function () { const j = +new Date() - g; b > j ? d = setTimeout(i, b - j) : (d = null, c || (h = a.apply(f, e), f = e = null)); }; return function () { f = this, e = arguments, g = +new Date(); const j = c && !d; return d || (d = setTimeout(i, b)), j && (h = a.apply(f, e), f = e = null), h; }; } function ka(b, c) { return b && b.then && b.state() !== 'resolved' ? c ? b.then(c) : void 0 : a.when(c()); } function la(c, d, e) { let f; let g; let h; let i; let j = c[0]; const k = c.length == 1 && typeof j === 'string'; return b.isMoment(j) ? (i = b.apply(null, c), na(j, i)) : U(j) || void 0 === j ? i = b.apply(null, c) : (f = !1, g = !1, k ? eb.test(j) ? (j += '-01', c = [j], f = !0, g = !0) : (h = fb.exec(j)) && (f = !h[5], g = !0) : a.isArray(j) && (g = !0), i = d || f ? b.utc.apply(b, c) : b.apply(null, c), f ? (i._ambigTime = !0, i._ambigZone = !0) : e && (g ? i._ambigZone = !0 : k && (i.utcOffset ? i.utcOffset(j) : i.zone(j)))), i._fullCalendar = !0, i; } function ma(a, c) { let d; let e; let f = !1; let g = !1; const h = a.length; const i = []; for (d = 0; h > d; d++)e = a[d], b.isMoment(e) || (e = Wa.moment.parseZone(e)), f = f || e._ambigTime, g = g || e._ambigZone, i.push(e); for (d = 0; h > d; d++)e = i[d], c || !f || e._ambigTime ? g && !e._ambigZone && (i[d] = e.clone().stripZone()) : i[d] = e.clone().stripTime(); return i; } function na(a, b) { a._ambigTime ? b._ambigTime = !0 : b._ambigTime && (b._ambigTime = !1), a._ambigZone ? b._ambigZone = !0 : b._ambigZone && (b._ambigZone = !1); } function oa(a, b) {
    a.year(b[0] || 0).month(b[1] || 0).date(b[2] || 0).hours(b[3] || 0)
      .minutes(b[4] || 0)
      .seconds(b[5] || 0)
      .milliseconds(b[6] || 0);
  } function pa(a, b) { return hb.format.call(a, b); } function qa(a, b) { return ra(a, wa(b)); } function ra(a, b) { let c; let d = ''; for (c = 0; c < b.length; c++)d += sa(a, b[c]); return d; } function sa(a, b) { let c; let d; return typeof b === 'string' ? b : (c = b.token) ? ib[c] ? ib[c](a) : pa(a, c) : b.maybe && (d = ra(a, b.maybe), d.match(/[1-9]/)) ? d : ''; } function ta(a, b, c, d, e) { let f; return a = Wa.moment.parseZone(a), b = Wa.moment.parseZone(b), f = (a.localeData || a.lang).call(a), c = f.longDateFormat(c) || c, d = d || ' - ', ua(a, b, wa(c), d, e); } function ua(a, b, c, d, e) { let f; let g; let h; let i; const j = a.clone().stripZone(); const k = b.clone().stripZone(); let l = ''; let m = ''; let n = ''; let o = ''; let p = ''; for (g = 0; g < c.length && (f = va(a, b, j, k, c[g]), f !== !1); g++)l += f; for (h = c.length - 1; h > g && (f = va(a, b, j, k, c[h]), f !== !1); h--)m = f + m; for (i = g; h >= i; i++)n += sa(a, c[i]), o += sa(b, c[i]); return (n || o) && (p = e ? o + d + n : n + d + o), l + p + m; } function va(a, b, c, d, e) { let f; let g; return typeof e === 'string' ? e : (f = e.token) && (g = jb[f.charAt(0)], g && c.isSame(d, g)) ? pa(a, f) : !1; } function wa(a) { return a in kb ? kb[a] : kb[a] = xa(a); } function xa(a) { for (var b, c = [], d = /\[([^\]]*)\]|\(([^\)]*)\)|(LTS|LT|(\w)\4*o?)|([^\w\[\(]+)/g; b = d.exec(a);)b[1] ? c.push(b[1]) : b[2] ? c.push({ maybe: xa(b[2]) }) : b[3] ? c.push({ token: b[3] }) : b[5] && c.push(b[5]); return c; } function ya() {} function za(a, b) { let c; return $(b, 'constructor') && (c = b.constructor), typeof c !== 'function' && (c = b.constructor = function () { a.apply(this, arguments); }), c.prototype = X(a.prototype), Y(b, c.prototype), Z(b, c.prototype), Y(a, c), c; } function Aa(a, b) { Y(b, a.prototype); } function Ba(a, b) { return a || b ? a && b ? a.component === b.component && Ca(a, b) && Ca(b, a) : !1 : !0; } function Ca(a, b) { for (const c in a) if (!/^(component|left|right|top|bottom)$/.test(c) && a[c] !== b[c]) return !1; return !0; } function Da(a) { const b = Fa(a); return b === 'background' || b === 'inverse-background'; } function Ea(a) { return Fa(a) === 'inverse-background'; } function Fa(a) { return ba((a.source || {}).rendering, a.rendering); } function Ga(a) { let b; let c; const d = {}; for (b = 0; b < a.length; b++)c = a[b], (d[c._id] || (d[c._id] = [])).push(c); return d; } function Ha(a, b) { return a.start - b.start; } function Ia(c) {
    let d; let e; let f; let g; let h = Wa.dataAttrPrefix; return h && (h += '-'), d = c.data(`${h}event`) || null, d && (d = typeof d === 'object' ? a.extend({}, d) : {}, e = d.start, e == null && (e = d.time), f = d.duration, g = d.stick, delete d.start, delete d.time, delete d.duration, delete d.stick), e == null && (e = c.data(`${h}start`)), e == null && (e = c.data(`${h}time`)), f == null && (f = c.data(`${h}duration`)), g == null && (g = c.data(`${h}stick`)), e = e != null ? b.duration(e) : null, f = f != null ? b.duration(f) : null, g = Boolean(g), {
      eventProps: d, startTime: e, duration: f, stick: g,
    };
  } function Ja(a, b) { let c; let d; for (c = 0; c < b.length; c++) if (d = b[c], d.leftCol <= a.rightCol && d.rightCol >= a.leftCol) return !0; return !1; } function Ka(a, b) { return a.leftCol - b.leftCol; } function La(a) { let b; let c; let d; const e = []; for (b = 0; b < a.length; b++) { for (c = a[b], d = 0; d < e.length && Oa(c, e[d]).length; d++);c.level = d, (e[d] || (e[d] = [])).push(c); } return e; } function Ma(a) { let b; let c; let d; let e; let f; for (b = 0; b < a.length; b++) for (c = a[b], d = 0; d < c.length; d++) for (e = c[d], e.forwardSegs = [], f = b + 1; f < a.length; f++)Oa(e, a[f], e.forwardSegs); } function Na(a) { let b; let c; const d = a.forwardSegs; let e = 0; if (void 0 === a.forwardPressure) { for (b = 0; b < d.length; b++)c = d[b], Na(c), e = Math.max(e, 1 + c.forwardPressure); a.forwardPressure = e; } } function Oa(a, b, c) { c = c || []; for (let d = 0; d < b.length; d++)Pa(a, b[d]) && c.push(b[d]); return c; } function Pa(a, b) { return a.bottom > b.top && a.top < b.bottom; } function Qa(c, e) { function f(a) { '_locale' in a ? a._locale = U : a._lang = U; } function g() { W ? k() && (p(), l()) : h(); } function h() { c.addClass('fc'), T.bindOption('theme', (a) => { Y = a ? 'ui' : 'fc', c.toggleClass('ui-widget', a), c.toggleClass('fc-unthemed', !a); }), T.bindOptions(['isRTL', 'lang'], (a) => { c.toggleClass('fc-ltr', !a), c.toggleClass('fc-rtl', a); }), W = a('<div class=\'fc-view-container\'/>').prependTo(c), V = T.header = new Ta(T), i(), l(T.options.defaultView), T.options.handleWindowResize && (_ = ja(r, T.options.windowResizeDelay), a(window).resize(_)); } function i() { V.render(), V.el && c.prepend(V.el); } function j() { Z && Z.removeElement(), V.removeElement(), W.remove(), c.removeClass('fc fc-ltr fc-rtl fc-unthemed ui-widget'), _ && a(window).unbind('resize', _); } function k() { return c.is(':visible'); } function l(b, c) { ga++, Z && b && Z.type !== b && (M(), m()), !Z && b && (Z = T.view = fa[b] || (fa[b] = T.instantiateView(b)), Z.setElement(a(`<div class='fc-view fc-${b}-view' />`).appendTo(W)), V.activateButton(b)), Z && (aa = Z.massageCurrentDate(aa), Z.displaying && aa.isWithin(Z.intervalStart, Z.intervalEnd) || k() && (Z.display(aa, c), N(), z(), A(), v())), N(), ga--; } function m() { V.deactivateButton(Z.type), Z.removeElement(), Z = T.view = null; } function n() { ga++, M(); const a = Z.type; const b = Z.queryScroll(); m(), l(a, b), N(), ga--; } function o(a) { return k() ? (a && q(), ga++, Z.updateSize(!0), ga--, !0) : void 0; } function p() { k() && q(); } function q() { $ = typeof T.options.contentHeight === 'number' ? T.options.contentHeight : typeof T.options.height === 'number' ? T.options.height - (V.el ? V.el.outerHeight(!0) : 0) : Math.round(W.width() / Math.max(T.options.aspectRatio, 0.5)); } function r(a) { !ga && a.target === window && Z.start && o(!0) && Z.trigger('windowResize', ea); } function s() { w(); } function t(a) { da(T.getEventSourcesByMatchArray(a)); } function u() { k() && (M(), Z.displayEvents(ha), N()); } function v() { !T.options.lazyFetching || ba(Z.start, Z.end) ? w() : u(); } function w() { ca(Z.start, Z.end); } function x(a) { ha = a, u(); } function y() { u(); } function z() { V.updateTitle(Z.title); } function A() { const a = T.getNow(); a.isWithin(Z.intervalStart, Z.intervalEnd) ? V.disableButton('today') : V.enableButton('today'); } function B(a, b) { Z.select(T.buildSelectSpan.apply(T, arguments)); } function C() { Z && Z.unselect(); } function D() { aa = Z.computePrevDate(aa), l(); } function E() { aa = Z.computeNextDate(aa), l(); } function F() { aa.add(-1, 'years'), l(); } function G() { aa.add(1, 'years'), l(); } function H() { aa = T.getNow(), l(); } function I(a) { aa = T.moment(a).stripZone(), l(); } function J(a) { aa.add(b.duration(a)), l(); } function K(a, b) { let c; b = b || 'day', c = T.getViewSpec(b) || T.getUnitViewSpec(b), aa = a.clone(), l(c ? c.type : null); } function L() { return T.applyTimezone(aa); } function M() { W.css({ width: '100%', height: W.height(), overflow: 'hidden' }); } function N() { W.css({ width: '', height: '', overflow: '' }); } function O() { return T; } function P() { return Z; } function Q(a, b) { let c; if (typeof a === 'string') { if (void 0 === b) return T.options[a]; c = {}, c[a] = b, R(c); } else typeof a === 'object' && R(a); } function R(a) { let b; let c = 0; for (b in a)T.dynamicOverrides[b] = a[b]; T.viewSpecCache = {}, T.populateOptionsHash(); for (b in a)T.triggerOptionHandlers(b), c++; if (c === 1) { if (b === 'height' || b === 'contentHeight' || b === 'aspectRatio') return void o(!0); if (b === 'defaultDate') return; if (b === 'businessHours') return void (Z && (Z.unrenderBusinessHours(), Z.renderBusinessHours())); if (b === 'timezone') return T.rezoneArrayEventSources(), void s(); }i(), fa = {}, n(); } function S(a, b) { const c = Array.prototype.slice.call(arguments, 2); return b = b || ea, this.triggerWith(a, b, c), T.options[a] ? T.options[a].apply(b, c) : void 0; } var T = this; T.render = g, T.destroy = j, T.refetchEvents = s, T.refetchEventSources = t, T.reportEvents = x, T.reportEventChange = y, T.rerenderEvents = u, T.changeView = l, T.select = B, T.unselect = C, T.prev = D, T.next = E, T.prevYear = F, T.nextYear = G, T.today = H, T.gotoDate = I, T.incrementDate = J, T.zoomTo = K, T.getDate = L, T.getCalendar = O, T.getView = P, T.option = Q, T.trigger = S, T.dynamicOverrides = {}, T.viewSpecCache = {}, T.optionHandlers = {}, T.overrides = d(e || {}), T.populateOptionsHash(); let U; T.bindOptions(['lang', 'monthNames', 'monthNamesShort', 'dayNames', 'dayNamesShort', 'firstDay', 'weekNumberCalculation'], (a, b, c, d, e, g, h) => { if (U = X(Sa(a)), b && (U._months = b), c && (U._monthsShort = c), d && (U._weekdays = d), e && (U._weekdaysShort = e), g != null) { const i = X(U._week); i.dow = g, U._week = i; }h === 'iso' && (h = 'ISO'), h !== 'ISO' && h !== 'local' && typeof h !== 'function' || (U._fullCalendar_weekCalc = h), aa && f(aa); }), T.defaultAllDayEventDuration = b.duration(T.options.defaultAllDayEventDuration), T.defaultTimedEventDuration = b.duration(T.options.defaultTimedEventDuration), T.moment = function () { let a; return T.options.timezone === 'local' ? (a = Wa.moment.apply(null, arguments), a.hasTime() && a.local()) : a = T.options.timezone === 'UTC' ? Wa.moment.utc.apply(null, arguments) : Wa.moment.parseZone.apply(null, arguments), f(a), a; }, T.getIsAmbigTimezone = function () { return T.options.timezone !== 'local' && T.options.timezone !== 'UTC'; }, T.applyTimezone = function (a) { if (!a.hasTime()) return a.clone(); let b; let c = T.moment(a.toArray()); const d = a.time() - c.time(); return d && (b = c.clone().add(d), a.time() - b.time() === 0 && (c = b)), c; }, T.getNow = function () { let a = T.options.now; return typeof a === 'function' && (a = a()), T.moment(a).stripZone(); }, T.getEventEnd = function (a) { return a.end ? a.end.clone() : T.getDefaultEventEnd(a.allDay, a.start); }, T.getDefaultEventEnd = function (a, b) { const c = b.clone(); return a ? c.stripTime().add(T.defaultAllDayEventDuration) : c.add(T.defaultTimedEventDuration), T.getIsAmbigTimezone() && c.stripZone(), c; }, T.humanizeDuration = function (a) { return (a.locale || a.lang).call(a, T.options.lang).humanize(); }, Ua.call(T); let V; let W; let Y; let Z; let $; let _; let aa; var ba = T.isFetchNeeded; var ca = T.fetchEvents; var da = T.fetchEventSources; var ea = c[0]; var fa = {}; var ga = 0; var ha = []; aa = T.options.defaultDate != null ? T.moment(T.options.defaultDate).stripZone() : T.getNow(), T.getSuggestedViewHeight = function () { return void 0 === $ && p(), $; }, T.isHeightAuto = function () { return T.options.contentHeight === 'auto' || T.options.height === 'auto'; }, T.freezeContentHeight = M, T.unfreezeContentHeight = N, T.initialize(); } function Ra(b) { a.each(Db, (a, c) => { b[a] == null && (b[a] = c(b)); }); } function Sa(a) { const c = b.localeData || b.langData; return c.call(b, a) || c.call(b, 'en'); } function Ta(b) {
    function c() { const c = b.options; const f = c.header; n = c.theme ? 'ui' : 'fc', f ? (m ? m.empty() : m = this.el = a('<div class=\'fc-toolbar\'/>'), m.append(e('left')).append(e('right')).append(e('center')).append('<div class="fc-clear"/>')) : d(); } function d() { m && (m.remove(), m = l.el = null); } function e(c) {
      const d = a(`<div class="fc-${c}"/>`); const e = b.options; const f = e.header[c]; return f && a.each(f.split(' '), function (c) {
        let f; let g = a(); let h = !0; a.each(this.split(','), (c, d) => {
          let f; let i; let j; let k; let l; let m; let p; let q; let r; let s; d == 'title' ? (g = g.add(a('<h2>&nbsp;</h2>')), h = !1) : ((f = (e.customButtons || {})[d]) ? (j = function (a) { f.click && f.click.call(s[0], a); }, k = '', l = f.text) : (i = b.getViewSpec(d)) ? (j = function () { b.changeView(d); }, o.push(d), k = i.buttonTextOverride, l = i.buttonTextDefault) : b[d] && (j = function () { b[d](); }, k = (b.overrides.buttonText || {})[d], l = e.buttonText[d]), j && (m = f ? f.themeIcon : e.themeButtonIcons[d], p = f ? f.icon : e.buttonIcons[d], q = k ? ca(k) : m && e.theme ? `<span class='ui-icon ui-icon-${m}'></span>` : p && !e.theme ? `<span class='fc-icon fc-icon-${p}'></span>` : ca(l), r = [`fc-${d}-button`, `${n}-button`, `${n}-state-default`], s = a(`<button type="button" class="${r.join(' ')}">${q}</button>`).click((a) => { s.hasClass(`${n}-state-disabled`) || (j(a), (s.hasClass(`${n}-state-active`) || s.hasClass(`${n}-state-disabled`)) && s.removeClass(`${n}-state-hover`)); }).mousedown(() => { s.not(`.${n}-state-active`).not(`.${n}-state-disabled`).addClass(`${n}-state-down`); }).mouseup(() => { s.removeClass(`${n}-state-down`); })
            .hover(() => { s.not(`.${n}-state-active`).not(`.${n}-state-disabled`).addClass(`${n}-state-hover`); }, () => { s.removeClass(`${n}-state-hover`).removeClass(`${n}-state-down`); }), g = g.add(s)));
        }), h && g.first().addClass(`${n}-corner-left`).end().last()
          .addClass(`${n}-corner-right`)
          .end(), g.length > 1 ? (f = a('<div/>'), h && f.addClass('fc-button-group'), f.append(g), d.append(f)) : d.append(g);
      }), d;
    } function f(a) { m && m.find('h2').text(a); } function g(a) { m && m.find(`.fc-${a}-button`).addClass(`${n}-state-active`); } function h(a) { m && m.find(`.fc-${a}-button`).removeClass(`${n}-state-active`); } function i(a) { m && m.find(`.fc-${a}-button`).prop('disabled', !0).addClass(`${n}-state-disabled`); } function j(a) { m && m.find(`.fc-${a}-button`).prop('disabled', !1).removeClass(`${n}-state-disabled`); } function k() { return o; } var l = this; l.render = c, l.removeElement = d, l.updateTitle = f, l.activateButton = g, l.deactivateButton = h, l.disableButton = i, l.enableButton = j, l.getViewsWithButtons = k, l.el = null; let m; let n; var o = [];
  } function Ua() {
    function c(a, b) { return !W || W > a || b > X; } function d(a, b) { W = a, X = b, e($, 'reset'); } function e(a, b) { let c; let d; for (b === 'reset' ? da = [] : b !== 'add' && (da = u(da, a)), c = 0; c < a.length; c++)d = a[c], d._status !== 'pending' && ca++, d._fetchId = (d._fetchId || 0) + 1, d._status = 'pending'; for (c = 0; c < a.length; c++)d = a[c], f(d, d._fetchId); } function f(b, c) { i(b, (d) => { let e; let f; let g; const i = a.isArray(b.events); if (c === b._fetchId && b._status !== 'rejected') { if (b._status = 'resolved', d) for (e = 0; e < d.length; e++)f = d[e], g = i ? f : C(f, b), g && da.push.apply(da, G(g)); h(); } }); } function g(a) { const b = a._status === 'pending'; a._status = 'rejected', b && h(); } function h() { ca--, ca || Y(da); } function i(b, c) {
      let d; let e; const f = Wa.sourceFetchers; for (d = 0; d < f.length; d++) { if (e = f[d].call(U, b, W.clone(), X.clone(), U.options.timezone, c), e === !0) return; if (typeof e === 'object') return void i(e, c); } const g = b.events; if (g)a.isFunction(g) ? (U.pushLoading(), g.call(U, W.clone(), X.clone(), U.options.timezone, (a) => { c(a), U.popLoading(); })) : a.isArray(g) ? c(g) : c(); else {
        const h = b.url; if (h) {
          let j; const k = b.success; const l = b.error; const m = b.complete; j = a.isFunction(b.data) ? b.data() : b.data; const n = a.extend({}, j || {}); const o = ba(b.startParam, U.options.startParam); const p = ba(b.endParam, U.options.endParam); const q = ba(b.timezoneParam, U.options.timezoneParam); o && (n[o] = W.format()), p && (n[p] = X.format()), U.options.timezone && U.options.timezone != 'local' && (n[q] = U.options.timezone), U.pushLoading(), a.ajax(a.extend({}, Eb, b, {
            data: n, success(b) { b = b || []; const d = aa(k, this, arguments); a.isArray(d) && (b = d), c(b); }, error() { aa(l, this, arguments), c(); }, complete() { aa(m, this, arguments), U.popLoading(); },
          }));
        } else c();
      }
    } function j(a) { const b = k(a); b && ($.push(b), e([b], 'add')); } function k(b) { let c; let d; const e = Wa.sourceNormalizers; if (a.isFunction(b) || a.isArray(b) ? c = { events: b } : typeof b === 'string' ? c = { url: b } : typeof b === 'object' && (c = a.extend({}, b)), c) { for (c.className ? typeof c.className === 'string' && (c.className = c.className.split(/\s+/)) : c.className = [], a.isArray(c.events) && (c.origArray = c.events, c.events = a.map(c.events, (a) => C(a, c))), d = 0; d < e.length; d++)e[d].call(U, c); return c; } } function l(a) { n(r(a)); } function m(a) { a == null ? n($, !0) : n(q(a)); } function n(b, c) { let d; for (d = 0; d < b.length; d++)g(b[d]); c ? ($ = [], da = []) : ($ = a.grep($, (a) => { for (d = 0; d < b.length; d++) if (a === b[d]) return !1; return !0; }), da = u(da, b)), Y(da); } function o() { return $.slice(1); } function p(b) { return a.grep($, (a) => a.id && a.id === b)[0]; } function q(b) { b ? a.isArray(b) || (b = [b]) : b = []; let c; const d = []; for (c = 0; c < b.length; c++)d.push.apply(d, r(b[c])); return d; } function r(b) { let c; let d; for (c = 0; c < $.length; c++) if (d = $[c], d === b) return [d]; return d = p(b), d ? [d] : a.grep($, (a) => s(b, a)); } function s(a, b) { return a && b && t(a) == t(b); } function t(a) { return (typeof a === 'object' ? a.origArray || a.googleCalendarId || a.url || a.events : null) || a; } function u(b, c) { return a.grep(b, (a) => { for (let b = 0; b < c.length; b++) if (a.source === c[b]) return !1; return !0; }); } function v(a) { a.start = U.moment(a.start), a.end ? a.end = U.moment(a.end) : a.end = null, H(a, w(a)), Y(da); } function w(b) { const c = {}; return a.each(b, (a, b) => { x(a) && void 0 !== b && _(b) && (c[a] = b); }), c; } function x(a) { return !/^_|^(id|allDay|start|end)$/.test(a); } function y(a, b) { let c; let d; let e; const f = C(a); if (f) { for (c = G(f), d = 0; d < c.length; d++)e = c[d], e.source || (b && (Z.events.push(e), e.source = Z), da.push(e)); return Y(da), c; } return []; } function z(b) { let c; let d; for (b == null ? b = function () { return !0; } : a.isFunction(b) || (c = `${b}`, b = function (a) { return a._id == c; }), da = a.grep(da, b, !0), d = 0; d < $.length; d++)a.isArray($[d].events) && ($[d].events = a.grep($[d].events, b, !0)); Y(da); } function A(b) { return a.isFunction(b) ? a.grep(da, b) : b != null ? (b += '', a.grep(da, (a) => a._id == b)) : da; } function B(a) { a.start = U.moment(a.start), a.end && (a.end = U.moment(a.end)), Va(a); } function C(c, d) { let e; let f; let g; const h = {}; if (U.options.eventDataTransform && (c = U.options.eventDataTransform(c)), d && d.eventDataTransform && (c = d.eventDataTransform(c)), a.extend(h, c), d && (h.source = d), h._id = c._id || (void 0 === c.id ? `_fc${Fb++}` : `${c.id}`), c.className ? typeof c.className === 'string' ? h.className = c.className.split(/\s+/) : h.className = c.className : h.className = [], e = c.start || c.date, f = c.end, V(e) && (e = b.duration(e)), V(f) && (f = b.duration(f)), c.dow || b.isDuration(e) || b.isDuration(f))h.start = e ? b.duration(e) : null, h.end = f ? b.duration(f) : null, h._recurring = !0; else { if (e && (e = U.moment(e), !e.isValid())) return !1; f && (f = U.moment(f), f.isValid() || (f = null)), g = c.allDay, void 0 === g && (g = ba(d ? d.allDayDefault : void 0, U.options.allDayDefault)), D(e, f, g, h); } return U.normalizeEvent(h), h; } function D(a, b, c, d) { d.start = a, d.end = b, d.allDay = c, E(d), Va(d); } function E(a) { F(a), a.end && !a.end.isAfter(a.start) && (a.end = null), a.end || (U.options.forceEventDuration ? a.end = U.getDefaultEventEnd(a.allDay, a.start) : a.end = null); } function F(a) { a.allDay == null && (a.allDay = !(a.start.hasTime() || a.end && a.end.hasTime())), a.allDay ? (a.start.stripTime(), a.end && a.end.stripTime()) : (a.start.hasTime() || (a.start = U.applyTimezone(a.start.time(0))), a.end && !a.end.hasTime() && (a.end = U.applyTimezone(a.end.time(0)))); } function G(b, c, d) { let e; let f; let g; let h; let i; let j; let k; let l; let m; const n = []; if (c = c || W, d = d || X, b) if (b._recurring) { if (f = b.dow) for (e = {}, g = 0; g < f.length; g++)e[f[g]] = !0; for (h = c.clone().stripTime(); h.isBefore(d);)e && !e[h.day()] || (i = b.start, j = b.end, k = h.clone(), l = null, i && (k = k.time(i)), j && (l = h.clone().time(j)), m = a.extend({}, b), D(k, l, !i && !j, m), n.push(m)), h.add(1, 'days'); } else n.push(b); return n; } function H(b, c, d) { function e(a, b) { return d ? N(a, b, d) : c.allDay ? M(a, b) : L(a, b); } let f; let g; let h; let i; let j; let k; const l = {}; return c = c || {}, c.start || (c.start = b.start.clone()), void 0 === c.end && (c.end = b.end ? b.end.clone() : null), c.allDay == null && (c.allDay = b.allDay), E(c), f = { start: b._start.clone(), end: b._end ? b._end.clone() : U.getDefaultEventEnd(b._allDay, b._start), allDay: c.allDay }, E(f), g = b._end !== null && c.end === null, h = e(c.start, f.start), c.end ? (i = e(c.end, f.end), j = i.subtract(h)) : j = null, a.each(c, (a, b) => { x(a) && void 0 !== b && (l[a] = b); }), k = I(A(b._id), g, c.allDay, h, j, l), { dateDelta: h, durationDelta: j, undo: k }; } function I(b, c, d, e, f, g) { const h = U.getIsAmbigTimezone(); const i = []; return e && !e.valueOf() && (e = null), f && !f.valueOf() && (f = null), a.each(b, (b, j) => { let k; let l; k = { start: j.start.clone(), end: j.end ? j.end.clone() : null, allDay: j.allDay }, a.each(g, (a) => { k[a] = j[a]; }), l = { start: j._start, end: j._end, allDay: d }, E(l), c ? l.end = null : f && !l.end && (l.end = U.getDefaultEventEnd(l.allDay, l.start)), e && (l.start.add(e), l.end && l.end.add(e)), f && l.end.add(f), h && !l.allDay && (e || f) && (l.start.stripZone(), l.end && l.end.stripZone()), a.extend(j, g, l), Va(j), i.push(() => { a.extend(j, k), Va(j); }); }), function () { for (let a = 0; a < i.length; a++)i[a](); }; } function J(b) {
      let c; const d = U.options.businessHours; const e = {
        className: 'fc-nonbusiness', start: '09:00', end: '17:00', dow: [1, 2, 3, 4, 5], rendering: 'inverse-background',
      }; const f = U.getView(); return d && (c = a.extend({}, e, typeof d === 'object' ? d : {})), c ? (b && (c.start = null, c.end = null), G(C(c), f.start, f.end)) : [];
    } function K(a, b) { const c = b.source || {}; const d = ba(b.constraint, c.constraint, U.options.eventConstraint); const e = ba(b.overlap, c.overlap, U.options.eventOverlap); return Q(a, d, e, b); } function O(b, c, d) { let e; let f; return d && (e = a.extend({}, d, c), f = G(C(e))[0]), f ? K(b, f) : P(b); } function P(a) { return Q(a, U.options.selectConstraint, U.options.selectOverlap); } function Q(a, b, c, d) { let e; let f; let g; let h; let i; let j; if (b != null) { for (e = R(b), f = !1, h = 0; h < e.length; h++) if (S(e[h], a)) { f = !0; break; } if (!f) return !1; } for (g = U.getPeerEvents(a, d), h = 0; h < g.length; h++) if (i = g[h], T(i, a)) { if (c === !1) return !1; if (typeof c === 'function' && !c(i, d)) return !1; if (d) { if (j = ba(i.overlap, (i.source || {}).overlap), j === !1) return !1; if (typeof j === 'function' && !j(d, i)) return !1; } } return !0; } function R(a) { return a === 'businessHours' ? J() : typeof a === 'object' ? G(C(a)) : A(a); } function S(a, b) { const c = a.start.clone().stripZone(); const d = U.getEventEnd(a).stripZone(); return b.start >= c && b.end <= d; } function T(a, b) { const c = a.start.clone().stripZone(); const d = U.getEventEnd(a).stripZone(); return b.start < d && b.end > c; } var U = this; U.isFetchNeeded = c, U.fetchEvents = d, U.fetchEventSources = e, U.getEventSources = o, U.getEventSourceById = p, U.getEventSourcesByMatchArray = q, U.getEventSourcesByMatch = r, U.addEventSource = j, U.removeEventSource = l, U.removeEventSources = m, U.updateEvent = v, U.renderEvent = y, U.removeEvents = z, U.clientEvents = A, U.mutateEvent = H, U.normalizeEventDates = E, U.normalizeEventTimes = F; let W; let X; var Y = U.reportEvents; var Z = { events: [] }; var $ = [Z]; var ca = 0; var da = []; a.each((U.options.events ? [U.options.events] : []).concat(U.options.eventSources || []), (a, b) => { const c = k(b); c && $.push(c); }), U.rezoneArrayEventSources = function () { let b; let c; let d; for (b = 0; b < $.length; b++) if (c = $[b].events, a.isArray(c)) for (d = 0; d < c.length; d++)B(c[d]); }, U.getBusinessHoursEvents = J, U.isEventSpanAllowed = K, U.isExternalSpanAllowed = O, U.isSelectionSpanAllowed = P, U.getEventCache = function () { return da; };
  } function Va(a) { a._allDay = a.allDay, a._start = a.start.clone(), a._end = a.end ? a.end.clone() : null; } var Wa = a.fullCalendar = { version: '2.9.0', internalApiVersion: 4 }; const Xa = Wa.views = {}; a.fn.fullCalendar = function (b) { const c = Array.prototype.slice.call(arguments, 1); let d = this; return this.each((e, f) => { let g; const h = a(f); let i = h.data('fullCalendar'); typeof b === 'string' ? i && a.isFunction(i[b]) && (g = i[b].apply(i, c), e || (d = g), b === 'destroy' && h.removeData('fullCalendar')) : i || (i = new zb(h, b), h.data('fullCalendar', i), i.render()); }), d; }; var Ya = ['header', 'buttonText', 'buttonIcons', 'themeButtonIcons']; Wa.intersectRanges = K, Wa.applyAll = aa, Wa.debounce = ja, Wa.isInt = ha, Wa.htmlEscape = ca, Wa.cssToStr = ea, Wa.proxy = ia, Wa.capitaliseFirstLetter = fa, Wa.getOuterRect = n, Wa.getClientRect = o, Wa.getContentRect = p, Wa.getScrollbarWidths = q; var Za = null; Wa.preventDefault = z, Wa.intersectRects = C, Wa.parseFieldSpecs = G, Wa.compareByFieldSpecs = H, Wa.compareByFieldSpec = I, Wa.flexibleCompare = J, Wa.computeIntervalUnit = O, Wa.divideRangeByDuration = Q, Wa.divideDurationByDuration = R, Wa.multiplyDuration = S, Wa.durationHasTime = T; const $a = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat']; var _a = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond']; Wa.log = function () { const a = window.console; return a && a.log ? a.log.apply(a, arguments) : void 0; }, Wa.warn = function () { const a = window.console; return a && a.warn ? a.warn.apply(a, arguments) : Wa.log.apply(Wa, arguments); }; let ab; let bb; let cb; var db = {}.hasOwnProperty; var eb = /^\s*\d{4}-\d\d$/; var fb = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/; const gb = b.fn; var hb = a.extend({}, gb); Wa.moment = function () { return la(arguments); }, Wa.moment.utc = function () { const a = la(arguments, !0); return a.hasTime() && a.utc(), a; }, Wa.moment.parseZone = function () { return la(arguments, !0, !0); }, gb.clone = function () { const a = hb.clone.apply(this, arguments); return na(this, a), this._fullCalendar && (a._fullCalendar = !0), a; }, gb.week = gb.weeks = function (a) { const b = (this._locale || this._lang)._fullCalendar_weekCalc; return a == null && typeof b === 'function' ? b(this) : b === 'ISO' ? hb.isoWeek.apply(this, arguments) : hb.week.apply(this, arguments); }, gb.time = function (a) {
    if (!this._fullCalendar) return hb.time.apply(this, arguments); if (a == null) {
      return b.duration({
        hours: this.hours(), minutes: this.minutes(), seconds: this.seconds(), milliseconds: this.milliseconds(),
      });
    } this._ambigTime = !1, b.isDuration(a) || b.isMoment(a) || (a = b.duration(a)); let c = 0; return b.isDuration(a) && (c = 24 * Math.floor(a.asDays())), this.hours(c + a.hours()).minutes(a.minutes()).seconds(a.seconds()).milliseconds(a.milliseconds());
  }, gb.stripTime = function () { let a; return this._ambigTime || (a = this.toArray(), this.utc(), bb(this, a.slice(0, 3)), this._ambigTime = !0, this._ambigZone = !0), this; }, gb.hasTime = function () { return !this._ambigTime; }, gb.stripZone = function () { let a; let b; return this._ambigZone || (a = this.toArray(), b = this._ambigTime, this.utc(), bb(this, a), this._ambigTime = b || !1, this._ambigZone = !0), this; }, gb.hasZone = function () { return !this._ambigZone; }, gb.local = function () { const a = this.toArray(); const b = this._ambigZone; return hb.local.apply(this, arguments), this._ambigTime = !1, this._ambigZone = !1, b && cb(this, a), this; }, gb.utc = function () { return hb.utc.apply(this, arguments), this._ambigTime = !1, this._ambigZone = !1, this; }, a.each(['zone', 'utcOffset'], (a, b) => { hb[b] && (gb[b] = function (a) { return a != null && (this._ambigTime = !1, this._ambigZone = !1), hb[b].apply(this, arguments); }); }), gb.format = function () {
    return this._fullCalendar && arguments[0] ? qa(this, arguments[0]) : this._ambigTime ? pa(this, 'YYYY-MM-DD') : this._ambigZone ? pa(this, 'YYYY-MM-DD[T]HH:mm:ss') : hb.format.apply(this, arguments);
  }, gb.toISOString = function () { return this._ambigTime ? pa(this, 'YYYY-MM-DD') : this._ambigZone ? pa(this, 'YYYY-MM-DD[T]HH:mm:ss') : hb.toISOString.apply(this, arguments); }, gb.isWithin = function (a, b) { const c = ma([this, a, b]); return c[0] >= c[1] && c[0] < c[2]; }, gb.isSame = function (a, b) { let c; return this._fullCalendar ? b ? (c = ma([this, a], !0), hb.isSame.call(c[0], c[1], b)) : (a = Wa.moment.parseZone(a), hb.isSame.call(this, a) && Boolean(this._ambigTime) === Boolean(a._ambigTime) && Boolean(this._ambigZone) === Boolean(a._ambigZone)) : hb.isSame.apply(this, arguments); }, a.each(['isBefore', 'isAfter'], (a, b) => { gb[b] = function (a, c) { let d; return this._fullCalendar ? (d = ma([this, a]), hb[b].call(d[0], d[1], c)) : hb[b].apply(this, arguments); }; }), ab = '_d' in b() && 'updateOffset' in b, bb = ab ? function (a, c) { a._d.setTime(Date.UTC.apply(Date, c)), b.updateOffset(a, !1); } : oa, cb = ab ? function (a, c) { a._d.setTime(+new Date(c[0] || 0, c[1] || 0, c[2] || 0, c[3] || 0, c[4] || 0, c[5] || 0, c[6] || 0)), b.updateOffset(a, !1); } : oa; var ib = { t(a) { return pa(a, 'a').charAt(0); }, T(a) { return pa(a, 'A').charAt(0); } }; Wa.formatRange = ta; var jb = {
    Y: 'year', M: 'month', D: 'day', d: 'day', A: 'second', a: 'second', T: 'second', t: 'second', H: 'second', h: 'second', m: 'second', s: 'second',
  }; var kb = {}; Wa.Class = ya, ya.extend = function () { let a; let b; const c = arguments.length; for (a = 0; c > a; a++)b = arguments[a], c - 1 > a && Aa(this, b); return za(this, b || {}); }, ya.mixin = function (a) { Aa(this, a); }; const lb = Wa.EmitterMixin = {
    on(b, c) { const d = function (a, b) { return c.apply(b.context || this, b.args || []); }; return c.guid || (c.guid = a.guid++), d.guid = c.guid, a(this).on(b, d), this; }, off(b, c) { return a(this).off(b, c), this; }, trigger(b) { const c = Array.prototype.slice.call(arguments, 1); return a(this).triggerHandler(b, { args: c }), this; }, triggerWith(b, c, d) { return a(this).triggerHandler(b, { context: c, args: d }), this; },
  }; const mb = Wa.ListenerMixin = (function () {
    let b = 0; const c = {
      listenerId: null, listenTo(b, c, d) { if (typeof c === 'object') for (const e in c)c.hasOwnProperty(e) && this.listenTo(b, e, c[e]); else typeof c === 'string' && b.on(`${c}.${this.getListenerNamespace()}`, a.proxy(d, this)); }, stopListeningTo(a, b) { a.off(`${b || ''}.${this.getListenerNamespace()}`); }, getListenerNamespace() { return this.listenerId == null && (this.listenerId = b++), `_listener${this.listenerId}`; },
    }; return c;
  }()); const nb = {
    isIgnoringMouse: !1, delayUnignoreMouse: null, initMouseIgnoring(a) { this.delayUnignoreMouse = ja(ia(this, 'unignoreMouse'), a || 1e3); }, tempIgnoreMouse() { this.isIgnoringMouse = !0, this.delayUnignoreMouse(); }, unignoreMouse() { this.isIgnoringMouse = !1; },
  }; const ob = ya.extend(mb, {
    isHidden: !0,
    options: null,
    el: null,
    margin: 10,
    constructor(a) { this.options = a || {}; },
    show() { this.isHidden && (this.el || this.render(), this.el.show(), this.position(), this.isHidden = !1, this.trigger('show')); },
    hide() { this.isHidden || (this.el.hide(), this.isHidden = !0, this.trigger('hide')); },
    render() {
      const b = this; const c = this.options; this.el = a('<div class="fc-popover"/>').addClass(c.className || '').css({ top: 0, left: 0 }).append(c.content)
        .appendTo(c.parentEl), this.el.on('click', '.fc-close', () => { b.hide(); }), c.autoHide && this.listenTo(a(document), 'mousedown', this.documentMousedown);
    },
    documentMousedown(b) { this.el && !a(b.target).closest(this.el).length && this.hide(); },
    removeElement() { this.hide(), this.el && (this.el.remove(), this.el = null), this.stopListeningTo(a(document), 'mousedown'); },
    position() { let b; let c; let d; let e; let f; const g = this.options; const h = this.el.offsetParent().offset(); const i = this.el.outerWidth(); const j = this.el.outerHeight(); const k = a(window); let l = m(this.el); e = g.top || 0, f = void 0 !== g.left ? g.left : void 0 !== g.right ? g.right - i : 0, l.is(window) || l.is(document) ? (l = k, b = 0, c = 0) : (d = l.offset(), b = d.top, c = d.left), b += k.scrollTop(), c += k.scrollLeft(), g.viewportConstrain !== !1 && (e = Math.min(e, b + l.outerHeight() - j - this.margin), e = Math.max(e, b + this.margin), f = Math.min(f, c + l.outerWidth() - i - this.margin), f = Math.max(f, c + this.margin)), this.el.css({ top: e - h.top, left: f - h.left }); },
    trigger(a) { this.options[a] && this.options[a].apply(this, Array.prototype.slice.call(arguments, 1)); },
  }); const pb = Wa.CoordCache = ya.extend({
    els: null, forcedOffsetParentEl: null, origin: null, boundingRect: null, isHorizontal: !1, isVertical: !1, lefts: null, rights: null, tops: null, bottoms: null, constructor(b) { this.els = a(b.els), this.isHorizontal = b.isHorizontal, this.isVertical = b.isVertical, this.forcedOffsetParentEl = b.offsetParent ? a(b.offsetParent) : null; }, build() { const a = this.forcedOffsetParentEl || this.els.eq(0).offsetParent(); this.origin = a.offset(), this.boundingRect = this.queryBoundingRect(), this.isHorizontal && this.buildElHorizontals(), this.isVertical && this.buildElVerticals(); }, clear() { this.origin = null, this.boundingRect = null, this.lefts = null, this.rights = null, this.tops = null, this.bottoms = null; }, ensureBuilt() { this.origin || this.build(); }, queryBoundingRect() { const a = m(this.els.eq(0)); return a.is(document) ? void 0 : o(a); }, buildElHorizontals() { const b = []; const c = []; this.els.each((d, e) => { const f = a(e); const g = f.offset().left; const h = f.outerWidth(); b.push(g), c.push(g + h); }), this.lefts = b, this.rights = c; }, buildElVerticals() { const b = []; const c = []; this.els.each((d, e) => { const f = a(e); const g = f.offset().top; const h = f.outerHeight(); b.push(g), c.push(g + h); }), this.tops = b, this.bottoms = c; }, getHorizontalIndex(a) { this.ensureBuilt(); let b; const c = this.boundingRect; const d = this.lefts; const e = this.rights; const f = d.length; if (!c || a >= c.left && a < c.right) for (b = 0; f > b; b++) if (a >= d[b] && a < e[b]) return b; }, getVerticalIndex(a) { this.ensureBuilt(); let b; const c = this.boundingRect; const d = this.tops; const e = this.bottoms; const f = d.length; if (!c || a >= c.top && a < c.bottom) for (b = 0; f > b; b++) if (a >= d[b] && a < e[b]) return b; }, getLeftOffset(a) { return this.ensureBuilt(), this.lefts[a]; }, getLeftPosition(a) { return this.ensureBuilt(), this.lefts[a] - this.origin.left; }, getRightOffset(a) { return this.ensureBuilt(), this.rights[a]; }, getRightPosition(a) { return this.ensureBuilt(), this.rights[a] - this.origin.left; }, getWidth(a) { return this.ensureBuilt(), this.rights[a] - this.lefts[a]; }, getTopOffset(a) { return this.ensureBuilt(), this.tops[a]; }, getTopPosition(a) { return this.ensureBuilt(), this.tops[a] - this.origin.top; }, getBottomOffset(a) { return this.ensureBuilt(), this.bottoms[a]; }, getBottomPosition(a) { return this.ensureBuilt(), this.bottoms[a] - this.origin.top; }, getHeight(a) { return this.ensureBuilt(), this.bottoms[a] - this.tops[a]; },
  }); const qb = Wa.DragListener = ya.extend(mb, nb, {
    options: null,
    subjectEl: null,
    subjectHref: null,
    originX: null,
    originY: null,
    scrollEl: null,
    isInteracting: !1,
    isDistanceSurpassed: !1,
    isDelayEnded: !1,
    isDragging: !1,
    isTouch: !1,
    delay: null,
    delayTimeoutId: null,
    minDistance: null,
    handleTouchScrollProxy: null,
    constructor(a) { this.options = a || {}, this.handleTouchScrollProxy = ia(this, 'handleTouchScroll'), this.initMouseIgnoring(500); },
    startInteraction(b, c) { const d = x(b); if (b.type === 'mousedown') { if (this.isIgnoringMouse) return; if (!u(b)) return; b.preventDefault(); } this.isInteracting || (c = c || {}, this.delay = ba(c.delay, this.options.delay, 0), this.minDistance = ba(c.distance, this.options.distance, 0), this.subjectEl = this.options.subjectEl, this.isInteracting = !0, this.isTouch = d, this.isDelayEnded = !1, this.isDistanceSurpassed = !1, this.originX = v(b), this.originY = w(b), this.scrollEl = m(a(b.target)), this.bindHandlers(), this.initAutoScroll(), this.handleInteractionStart(b), this.startDelay(b), this.minDistance || this.handleDistanceSurpassed(b)); },
    handleInteractionStart(a) { this.trigger('interactionStart', a); },
    endInteraction(a, b) { this.isInteracting && (this.endDrag(a), this.delayTimeoutId && (clearTimeout(this.delayTimeoutId), this.delayTimeoutId = null), this.destroyAutoScroll(), this.unbindHandlers(), this.isInteracting = !1, this.handleInteractionEnd(a, b), this.isTouch && this.tempIgnoreMouse()); },
    handleInteractionEnd(a, b) { this.trigger('interactionEnd', a, b || !1); },
    bindHandlers() {
      const b = this; let c = 1; this.isTouch ? (this.listenTo(a(document), {
        touchmove: this.handleTouchMove, touchend: this.endInteraction, touchcancel: this.endInteraction, touchstart(a) { c ? c-- : b.endInteraction(a, !0); },
      }), !A(this.handleTouchScrollProxy) && this.scrollEl && this.listenTo(this.scrollEl, 'scroll', this.handleTouchScroll)) : this.listenTo(a(document), { mousemove: this.handleMouseMove, mouseup: this.endInteraction }), this.listenTo(a(document), { selectstart: z, contextmenu: z });
    },
    unbindHandlers() { this.stopListeningTo(a(document)), B(this.handleTouchScrollProxy), this.scrollEl && this.stopListeningTo(this.scrollEl, 'scroll'); },
    startDrag(a, b) { this.startInteraction(a, b), this.isDragging || (this.isDragging = !0, this.handleDragStart(a)); },
    handleDragStart(a) { this.trigger('dragStart', a), this.initHrefHack(); },
    handleMove(a) { let b; const c = v(a) - this.originX; const d = w(a) - this.originY; const e = this.minDistance; this.isDistanceSurpassed || (b = c * c + d * d, b >= e * e && this.handleDistanceSurpassed(a)), this.isDragging && this.handleDrag(c, d, a); },
    handleDrag(a, b, c) { this.trigger('drag', a, b, c), this.updateAutoScroll(c); },
    endDrag(a) { this.isDragging && (this.isDragging = !1, this.handleDragEnd(a)); },
    handleDragEnd(a) { this.trigger('dragEnd', a), this.destroyHrefHack(); },
    startDelay(a) { const b = this; this.delay ? this.delayTimeoutId = setTimeout(() => { b.handleDelayEnd(a); }, this.delay) : this.handleDelayEnd(a); },
    handleDelayEnd(a) { this.isDelayEnded = !0, this.isDistanceSurpassed && this.startDrag(a); },
    handleDistanceSurpassed(a) { this.isDistanceSurpassed = !0, this.isDelayEnded && this.startDrag(a); },
    handleTouchMove(a) { this.isDragging && a.preventDefault(), this.handleMove(a); },
    handleMouseMove(a) { this.handleMove(a); },
    handleTouchScroll(a) { this.isDragging || this.endInteraction(a, !0); },
    initHrefHack() { const a = this.subjectEl; (this.subjectHref = a ? a.attr('href') : null) && a.removeAttr('href'); },
    destroyHrefHack() { const a = this.subjectEl; const b = this.subjectHref; setTimeout(() => { b && a.attr('href', b); }, 0); },
    trigger(a) { this.options[a] && this.options[a].apply(this, Array.prototype.slice.call(arguments, 1)), this[`_${a}`] && this[`_${a}`].apply(this, Array.prototype.slice.call(arguments, 1)); },
  }); qb.mixin({
    isAutoScroll: !1, scrollBounds: null, scrollTopVel: null, scrollLeftVel: null, scrollIntervalId: null, scrollSensitivity: 30, scrollSpeed: 200, scrollIntervalMs: 50, initAutoScroll() { const a = this.scrollEl; this.isAutoScroll = this.options.scroll && a && !a.is(window) && !a.is(document), this.isAutoScroll && this.listenTo(a, 'scroll', ja(this.handleDebouncedScroll, 100)); }, destroyAutoScroll() { this.endAutoScroll(), this.isAutoScroll && this.stopListeningTo(this.scrollEl, 'scroll'); }, computeScrollBounds() { this.isAutoScroll && (this.scrollBounds = n(this.scrollEl)); }, updateAutoScroll(a) { let b; let c; let d; let e; const f = this.scrollSensitivity; const g = this.scrollBounds; let h = 0; let i = 0; g && (b = (f - (w(a) - g.top)) / f, c = (f - (g.bottom - w(a))) / f, d = (f - (v(a) - g.left)) / f, e = (f - (g.right - v(a))) / f, b >= 0 && b <= 1 ? h = b * this.scrollSpeed * -1 : c >= 0 && c <= 1 && (h = c * this.scrollSpeed), d >= 0 && d <= 1 ? i = d * this.scrollSpeed * -1 : e >= 0 && e <= 1 && (i = e * this.scrollSpeed)), this.setScrollVel(h, i); }, setScrollVel(a, b) { this.scrollTopVel = a, this.scrollLeftVel = b, this.constrainScrollVel(), !this.scrollTopVel && !this.scrollLeftVel || this.scrollIntervalId || (this.scrollIntervalId = setInterval(ia(this, 'scrollIntervalFunc'), this.scrollIntervalMs)); }, constrainScrollVel() { const a = this.scrollEl; this.scrollTopVel < 0 ? a.scrollTop() <= 0 && (this.scrollTopVel = 0) : this.scrollTopVel > 0 && a.scrollTop() + a[0].clientHeight >= a[0].scrollHeight && (this.scrollTopVel = 0), this.scrollLeftVel < 0 ? a.scrollLeft() <= 0 && (this.scrollLeftVel = 0) : this.scrollLeftVel > 0 && a.scrollLeft() + a[0].clientWidth >= a[0].scrollWidth && (this.scrollLeftVel = 0); }, scrollIntervalFunc() { const a = this.scrollEl; const b = this.scrollIntervalMs / 1e3; this.scrollTopVel && a.scrollTop(a.scrollTop() + this.scrollTopVel * b), this.scrollLeftVel && a.scrollLeft(a.scrollLeft() + this.scrollLeftVel * b), this.constrainScrollVel(), this.scrollTopVel || this.scrollLeftVel || this.endAutoScroll(); }, endAutoScroll() { this.scrollIntervalId && (clearInterval(this.scrollIntervalId), this.scrollIntervalId = null, this.handleScrollEnd()); }, handleDebouncedScroll() { this.scrollIntervalId || this.handleScrollEnd(); }, handleScrollEnd() {},
  }); const rb = qb.extend({
    component: null, origHit: null, hit: null, coordAdjust: null, constructor(a, b) { qb.call(this, b), this.component = a; }, handleInteractionStart(a) { let b; let c; let d; const e = this.subjectEl; this.computeCoords(), a ? (c = { left: v(a), top: w(a) }, d = c, e && (b = n(e), d = D(d, b)), this.origHit = this.queryHit(d.left, d.top), e && this.options.subjectCenter && (this.origHit && (b = C(this.origHit, b) || b), d = E(b)), this.coordAdjust = F(d, c)) : (this.origHit = null, this.coordAdjust = null), qb.prototype.handleInteractionStart.apply(this, arguments); }, computeCoords() { this.component.prepareHits(), this.computeScrollBounds(); }, handleDragStart(a) { let b; qb.prototype.handleDragStart.apply(this, arguments), b = this.queryHit(v(a), w(a)), b && this.handleHitOver(b); }, handleDrag(a, b, c) { let d; qb.prototype.handleDrag.apply(this, arguments), d = this.queryHit(v(c), w(c)), Ba(d, this.hit) || (this.hit && this.handleHitOut(), d && this.handleHitOver(d)); }, handleDragEnd() { this.handleHitDone(), qb.prototype.handleDragEnd.apply(this, arguments); }, handleHitOver(a) { const b = Ba(a, this.origHit); this.hit = a, this.trigger('hitOver', this.hit, b, this.origHit); }, handleHitOut() { this.hit && (this.trigger('hitOut', this.hit), this.handleHitDone(), this.hit = null); }, handleHitDone() { this.hit && this.trigger('hitDone', this.hit); }, handleInteractionEnd() { qb.prototype.handleInteractionEnd.apply(this, arguments), this.origHit = null, this.hit = null, this.component.releaseHits(); }, handleScrollEnd() { qb.prototype.handleScrollEnd.apply(this, arguments), this.computeCoords(); }, queryHit(a, b) { return this.coordAdjust && (a += this.coordAdjust.left, b += this.coordAdjust.top), this.component.queryHit(a, b); },
  }); const sb = ya.extend(mb, {
    options: null,
    sourceEl: null,
    el: null,
    parentEl: null,
    top0: null,
    left0: null,
    y0: null,
    x0: null,
    topDelta: null,
    leftDelta: null,
    isFollowing: !1,
    isHidden: !1,
    isAnimating: !1,
    constructor(b, c) { this.options = c = c || {}, this.sourceEl = b, this.parentEl = c.parentEl ? a(c.parentEl) : b.parent(); },
    start(b) { this.isFollowing || (this.isFollowing = !0, this.y0 = w(b), this.x0 = v(b), this.topDelta = 0, this.leftDelta = 0, this.isHidden || this.updatePosition(), x(b) ? this.listenTo(a(document), 'touchmove', this.handleMove) : this.listenTo(a(document), 'mousemove', this.handleMove)); },
    stop(b, c) { function d() { this.isAnimating = !1, e.removeElement(), this.top0 = this.left0 = null, c && c(); } var e = this; const f = this.options.revertDuration; this.isFollowing && !this.isAnimating && (this.isFollowing = !1, this.stopListeningTo(a(document)), b && f && !this.isHidden ? (this.isAnimating = !0, this.el.animate({ top: this.top0, left: this.left0 }, { duration: f, complete: d })) : d()); },
    getEl() {
      let a = this.el; return a || (this.sourceEl.width(), a = this.el = this.sourceEl.clone().addClass(this.options.additionalClass || '').css({
        position: 'absolute', visibility: '', display: this.isHidden ? 'none' : '', margin: 0, right: 'auto', bottom: 'auto', width: this.sourceEl.width(), height: this.sourceEl.height(), opacity: this.options.opacity || '', zIndex: this.options.zIndex,
      }), a.addClass('fc-unselectable'), a.appendTo(this.parentEl)), a;
    },
    removeElement() { this.el && (this.el.remove(), this.el = null); },
    updatePosition() { let a; let b; this.getEl(), this.top0 === null && (this.sourceEl.width(), a = this.sourceEl.offset(), b = this.el.offsetParent().offset(), this.top0 = a.top - b.top, this.left0 = a.left - b.left), this.el.css({ top: this.top0 + this.topDelta, left: this.left0 + this.leftDelta }); },
    handleMove(a) { this.topDelta = w(a) - this.y0, this.leftDelta = v(a) - this.x0, this.isHidden || this.updatePosition(); },
    hide() { this.isHidden || (this.isHidden = !0, this.el && this.el.hide()); },
    show() { this.isHidden && (this.isHidden = !1, this.updatePosition(), this.getEl().show()); },
  }); const tb = Wa.Grid = ya.extend(mb, nb, {
    view: null,
    isRTL: null,
    start: null,
    end: null,
    el: null,
    elsByFill: null,
    eventTimeFormat: null,
    displayEventTime: null,
    displayEventEnd: null,
    minResizeDuration: null,
    largeUnit: null,
    dayDragListener: null,
    segDragListener: null,
    segResizeListener: null,
    externalDragListener: null,
    constructor(a) { this.view = a, this.isRTL = a.opt('isRTL'), this.elsByFill = {}, this.dayDragListener = this.buildDayDragListener(), this.initMouseIgnoring(); },
    computeEventTimeFormat() { return this.view.opt('smallTimeFormat'); },
    computeDisplayEventTime() { return !0; },
    computeDisplayEventEnd() { return !0; },
    setRange(a) { this.start = a.start.clone(), this.end = a.end.clone(), this.rangeUpdated(), this.processRangeOptions(); },
    rangeUpdated() {},
    processRangeOptions() { let a; let b; const c = this.view; this.eventTimeFormat = c.opt('eventTimeFormat') || c.opt('timeFormat') || this.computeEventTimeFormat(), a = c.opt('displayEventTime'), a == null && (a = this.computeDisplayEventTime()), b = c.opt('displayEventEnd'), b == null && (b = this.computeDisplayEventEnd()), this.displayEventTime = a, this.displayEventEnd = b; },
    spanToSegs(a) {},
    diffDates(a, b) { return this.largeUnit ? N(a, b, this.largeUnit) : L(a, b); },
    prepareHits() {},
    releaseHits() {},
    queryHit(a, b) {},
    getHitSpan(a) {},
    getHitEl(a) {},
    setElement(a) { this.el = a, y(a), this.bindDayHandler('touchstart', this.dayTouchStart), this.bindDayHandler('mousedown', this.dayMousedown), this.bindSegHandlers(), this.bindGlobalHandlers(); },
    bindDayHandler(b, c) { const d = this; this.el.on(b, (b) => (a(b.target).is('.fc-event-container *, .fc-more') || a(b.target).closest('.fc-popover').length ? void 0 : c.call(d, b))); },
    removeElement() { this.unbindGlobalHandlers(), this.clearDragListeners(), this.el.remove(); },
    renderSkeleton() {},
    renderDates() {},
    unrenderDates() {},
    bindGlobalHandlers() { this.listenTo(a(document), { dragstart: this.externalDragStart, sortstart: this.externalDragStart }); },
    unbindGlobalHandlers() { this.stopListeningTo(a(document)); },
    dayMousedown(a) { this.isIgnoringMouse || this.dayDragListener.startInteraction(a, {}); },
    dayTouchStart(a) { const b = this.view; (b.isSelected || b.selectedEvent) && this.tempIgnoreMouse(), this.dayDragListener.startInteraction(a, { delay: this.view.opt('longPressDelay') }); },
    buildDayDragListener() {
      let a; let b; const c = this; const d = this.view; const e = d.opt('selectable'); var f = new rb(this, {
        scroll: d.opt('dragScroll'), interactionStart() { a = f.origHit; }, dragStart() { d.unselect(); }, hitOver(d, f, h) { h && (f || (a = null), e && (b = c.computeSelection(c.getHitSpan(h), c.getHitSpan(d)), b ? c.renderSelection(b) : b === !1 && g())); }, hitOut() { a = null, b = null, c.unrenderSelection(), h(); }, interactionEnd(e, f) { f || (a && !c.isIgnoringMouse && d.triggerDayClick(c.getHitSpan(a), c.getHitEl(a), e), b && d.reportSelection(b, e), h()); },
      }); return f;
    },
    clearDragListeners() { this.dayDragListener.endInteraction(), this.segDragListener && this.segDragListener.endInteraction(), this.segResizeListener && this.segResizeListener.endInteraction(), this.externalDragListener && this.externalDragListener.endInteraction(); },
    renderEventLocationHelper(a, b) { const c = this.fabricateHelperEvent(a, b); return this.renderHelper(c, b); },
    fabricateHelperEvent(a, b) { const c = b ? X(b.event) : {}; return c.start = a.start.clone(), c.end = a.end ? a.end.clone() : null, c.allDay = null, this.view.calendar.normalizeEventDates(c), c.className = (c.className || []).concat('fc-helper'), b || (c.editable = !1), c; },
    renderHelper(a, b) {},
    unrenderHelper() {},
    renderSelection(a) { this.renderHighlight(a); },
    unrenderSelection() { this.unrenderHighlight(); },
    computeSelection(a, b) { const c = this.computeSelectionSpan(a, b); return c && !this.view.calendar.isSelectionSpanAllowed(c) ? !1 : c; },
    computeSelectionSpan(a, b) { const c = [a.start, a.end, b.start, b.end]; return c.sort(ga), { start: c[0].clone(), end: c[3].clone() }; },
    renderHighlight(a) { this.renderFill('highlight', this.spanToSegs(a)); },
    unrenderHighlight() { this.unrenderFill('highlight'); },
    highlightSegClasses() { return ['fc-highlight']; },
    renderBusinessHours() {},
    unrenderBusinessHours() {},
    getNowIndicatorUnit() {},
    renderNowIndicator(a) {},
    unrenderNowIndicator() {},
    renderFill(a, b) {},
    unrenderFill(a) { const b = this.elsByFill[a]; b && (b.remove(), delete this.elsByFill[a]); },
    renderFillSegEls(b, c) { let d; const e = this; const f = this[`${b}SegEl`]; let g = ''; const h = []; if (c.length) { for (d = 0; d < c.length; d++)g += this.fillSegHtml(b, c[d]); a(g).each((b, d) => { const g = c[b]; let i = a(d); f && (i = f.call(e, g, i)), i && (i = a(i), i.is(e.fillSegTag) && (g.el = i, h.push(g))); }); } return h; },
    fillSegTag: 'div',
    fillSegHtml(a, b) { const c = this[`${a}SegClasses`]; const d = this[`${a}SegCss`]; const e = c ? c.call(this, b) : []; const f = ea(d ? d.call(this, b) : {}); return `<${this.fillSegTag}${e.length ? ` class="${e.join(' ')}"` : ''}${f ? ` style="${f}"` : ''} />`; },
    getDayClasses(a) { const b = this.view; const c = b.calendar.getNow(); const d = [`fc-${$a[a.day()]}`]; return b.intervalDuration.as('months') == 1 && a.month() != b.intervalStart.month() && d.push('fc-other-month'), a.isSame(c, 'day') ? d.push('fc-today', b.highlightStateClass) : c > a ? d.push('fc-past') : d.push('fc-future'), d; },
  }); tb.mixin({
    mousedOverSeg: null,
    isDraggingSeg: !1,
    isResizingSeg: !1,
    isDraggingExternal: !1,
    segs: null,
    renderEvents(a) { let b; const c = []; const d = []; for (b = 0; b < a.length; b++)(Da(a[b]) ? c : d).push(a[b]); this.segs = [].concat(this.renderBgEvents(c), this.renderFgEvents(d)); },
    renderBgEvents(a) { const b = this.eventsToSegs(a); return this.renderBgSegs(b) || b; },
    renderFgEvents(a) { const b = this.eventsToSegs(a); return this.renderFgSegs(b) || b; },
    unrenderEvents() { this.handleSegMouseout(), this.clearDragListeners(), this.unrenderFgSegs(), this.unrenderBgSegs(), this.segs = null; },
    getEventSegs() { return this.segs || []; },
    renderFgSegs(a) {},
    unrenderFgSegs() {},
    renderFgSegEls(b, c) { let d; const e = this.view; let f = ''; const g = []; if (b.length) { for (d = 0; d < b.length; d++)f += this.fgSegHtml(b[d], c); a(f).each((c, d) => { const f = b[c]; const h = e.resolveEventEl(f.event, a(d)); h && (h.data('fc-seg', f), f.el = h, g.push(f)); }); } return g; },
    fgSegHtml(a, b) {},
    renderBgSegs(a) { return this.renderFill('bgEvent', a); },
    unrenderBgSegs() { this.unrenderFill('bgEvent'); },
    bgEventSegEl(a, b) { return this.view.resolveEventEl(a.event, b); },
    bgEventSegClasses(a) { const b = a.event; const c = b.source || {}; return ['fc-bgevent'].concat(b.className, c.className || []); },
    bgEventSegCss(a) { return { 'background-color': this.getSegSkinCss(a)['background-color'] }; },
    businessHoursSegClasses(a) { return ['fc-nonbusiness', 'fc-bgevent']; },
    bindSegHandlers() { this.bindSegHandler('touchstart', this.handleSegTouchStart), this.bindSegHandler('touchend', this.handleSegTouchEnd), this.bindSegHandler('mouseenter', this.handleSegMouseover), this.bindSegHandler('mouseleave', this.handleSegMouseout), this.bindSegHandler('mousedown', this.handleSegMousedown), this.bindSegHandler('click', this.handleSegClick); },
    bindSegHandler(b, c) { const d = this; this.el.on(b, '.fc-event-container > *', function (b) { const e = a(this).data('fc-seg'); return !e || d.isDraggingSeg || d.isResizingSeg ? void 0 : c.call(d, e, b); }); },
    handleSegClick(a, b) { return this.view.trigger('eventClick', a.el[0], a.event, b); },
    handleSegMouseover(a, b) { this.isIgnoringMouse || this.mousedOverSeg || (this.mousedOverSeg = a, a.el.addClass('fc-allow-mouse-resize'), this.view.trigger('eventMouseover', a.el[0], a.event, b)); },
    handleSegMouseout(a, b) { b = b || {}, this.mousedOverSeg && (a = a || this.mousedOverSeg, this.mousedOverSeg = null, a.el.removeClass('fc-allow-mouse-resize'), this.view.trigger('eventMouseout', a.el[0], a.event, b)); },
    handleSegMousedown(a, b) { const c = this.startSegResize(a, b, { distance: 5 }); !c && this.view.isEventDraggable(a.event) && this.buildSegDragListener(a).startInteraction(b, { distance: 5 }); },
    handleSegTouchStart(a, b) { let c; const d = this.view; const e = a.event; const f = d.isEventSelected(e); const g = d.isEventDraggable(e); const h = d.isEventResizable(e); let i = !1; f && h && (i = this.startSegResize(a, b)), i || !g && !h || (c = g ? this.buildSegDragListener(a) : this.buildSegSelectListener(a), c.startInteraction(b, { delay: f ? 0 : this.view.opt('longPressDelay') })), this.tempIgnoreMouse(); },
    handleSegTouchEnd(a, b) { this.tempIgnoreMouse(); },
    startSegResize(b, c, d) { return a(c.target).is('.fc-resizer') ? (this.buildSegResizeListener(b, a(c.target).is('.fc-start-resizer')).startInteraction(c, d), !0) : !1; },
    buildSegDragListener(a) {
      let b; let c; let d; const e = this; const f = this.view; const i = f.calendar; const j = a.el; const k = a.event; if (this.segDragListener) return this.segDragListener; var l = this.segDragListener = new rb(f, {
        scroll: f.opt('dragScroll'),
        subjectEl: j,
        subjectCenter: !0,
        interactionStart(d) {
          b = !1, c = new sb(a.el, {
            additionalClass: 'fc-dragging', parentEl: f.el, opacity: l.isTouch ? null : f.opt('dragOpacity'), revertDuration: f.opt('dragRevertDuration'), zIndex: 2,
          }), c.hide(), c.start(d);
        },
        dragStart(c) { l.isTouch && !f.isEventSelected(k) && f.selectEvent(k), b = !0, e.handleSegMouseout(a, c), e.segDragStart(a, c), f.hideEvent(k); },
        hitOver(b, h, j) { let m; a.hit && (j = a.hit), d = e.computeEventDrop(j.component.getHitSpan(j), b.component.getHitSpan(b), k), d && !i.isEventSpanAllowed(e.eventToSpan(d), k) && (g(), d = null), d && (m = f.renderDrag(d, a)) ? (m.addClass('fc-dragging'), l.isTouch || e.applyDragOpacity(m), c.hide()) : c.show(), h && (d = null); },
        hitOut() { f.unrenderDrag(), c.show(), d = null; },
        hitDone() { h(); },
        interactionEnd(g) { c.stop(!d, function () { b && (f.unrenderDrag(), f.showEvent(k), e.segDragStop(a, g)), d && f.reportEventDrop(k, d, this.largeUnit, j, g); }), e.segDragListener = null; },
      }); return l;
    },
    buildSegSelectListener(a) { const b = this; const c = this.view; const d = a.event; if (this.segDragListener) return this.segDragListener; var e = this.segDragListener = new qb({ dragStart(a) { e.isTouch && !c.isEventSelected(d) && c.selectEvent(d); }, interactionEnd(a) { b.segDragListener = null; } }); return e; },
    segDragStart(a, b) { this.isDraggingSeg = !0, this.view.trigger('eventDragStart', a.el[0], a.event, b, {}); },
    segDragStop(a, b) { this.isDraggingSeg = !1, this.view.trigger('eventDragStop', a.el[0], a.event, b, {}); },
    computeEventDrop(a, b, c) { let d; let e; const f = this.view.calendar; const g = a.start; const h = b.start; return g.hasTime() === h.hasTime() ? (d = this.diffDates(h, g), c.allDay && T(d) ? (e = { start: c.start.clone(), end: f.getEventEnd(c), allDay: !1 }, f.normalizeEventTimes(e)) : e = { start: c.start.clone(), end: c.end ? c.end.clone() : null, allDay: c.allDay }, e.start.add(d), e.end && e.end.add(d)) : e = { start: h.clone(), end: null, allDay: !h.hasTime() }, e; },
    applyDragOpacity(a) { const b = this.view.opt('dragOpacity'); b != null && a.each((a, c) => { c.style.opacity = b; }); },
    externalDragStart(b, c) { let d; let e; const f = this.view; f.opt('droppable') && (d = a((c ? c.item : null) || b.target), e = f.opt('dropAccept'), (a.isFunction(e) ? e.call(d[0], d) : d.is(e)) && (this.isDraggingExternal || this.listenToExternalDrag(d, b, c))); },
    listenToExternalDrag(a, b, c) {
      let d; const e = this; const f = this.view.calendar; const i = Ia(a); const j = e.externalDragListener = new rb(this, {
        interactionStart() { e.isDraggingExternal = !0; }, hitOver(a) { d = e.computeExternalDrop(a.component.getHitSpan(a), i), d && !f.isExternalSpanAllowed(e.eventToSpan(d), d, i.eventProps) && (g(), d = null), d && e.renderDrag(d); }, hitOut() { d = null; }, hitDone() { h(), e.unrenderDrag(); }, interactionEnd(b) { d && e.view.reportExternalDrop(i, d, a, b, c), e.isDraggingExternal = !1, e.externalDragListener = null; },
      }); j.startDrag(b);
    },
    computeExternalDrop(a, b) { const c = this.view.calendar; const d = { start: c.applyTimezone(a.start), end: null }; return b.startTime && !d.start.hasTime() && d.start.time(b.startTime), b.duration && (d.end = d.start.clone().add(b.duration)), d; },
    renderDrag(a, b) {},
    unrenderDrag() {},
    buildSegResizeListener(a, b) {
      let c; let d; const e = this; const f = this.view; const i = f.calendar; const j = a.el; const k = a.event; const l = i.getEventEnd(k); const m = this.segResizeListener = new rb(this, {
        scroll: f.opt('dragScroll'), subjectEl: j, interactionStart() { c = !1; }, dragStart(b) { c = !0, e.handleSegMouseout(a, b), e.segResizeStart(a, b); }, hitOver(c, h, j) { const m = e.getHitSpan(j); const n = e.getHitSpan(c); d = b ? e.computeEventStartResize(m, n, k) : e.computeEventEndResize(m, n, k), d && (i.isEventSpanAllowed(e.eventToSpan(d), k) ? d.start.isSame(k.start) && d.end.isSame(l) && (d = null) : (g(), d = null)), d && (f.hideEvent(k), e.renderEventResize(d, a)); }, hitOut() { d = null; }, hitDone() { e.unrenderEventResize(), f.showEvent(k), h(); }, interactionEnd(b) { c && e.segResizeStop(a, b), d && f.reportEventResize(k, d, this.largeUnit, j, b), e.segResizeListener = null; },
      }); return m;
    },
    segResizeStart(a, b) { this.isResizingSeg = !0, this.view.trigger('eventResizeStart', a.el[0], a.event, b, {}); },
    segResizeStop(a, b) { this.isResizingSeg = !1, this.view.trigger('eventResizeStop', a.el[0], a.event, b, {}); },
    computeEventStartResize(a, b, c) { return this.computeEventResize('start', a, b, c); },
    computeEventEndResize(a, b, c) { return this.computeEventResize('end', a, b, c); },
    computeEventResize(a, b, c, d) { let e; let f; const g = this.view.calendar; const h = this.diffDates(c[a], b[a]); return e = { start: d.start.clone(), end: g.getEventEnd(d), allDay: d.allDay }, e.allDay && T(h) && (e.allDay = !1, g.normalizeEventTimes(e)), e[a].add(h), e.start.isBefore(e.end) || (f = this.minResizeDuration || (d.allDay ? g.defaultAllDayEventDuration : g.defaultTimedEventDuration), a == 'start' ? e.start = e.end.clone().subtract(f) : e.end = e.start.clone().add(f)), e; },
    renderEventResize(a, b) {},
    unrenderEventResize() {},
    getEventTimeText(a, b, c) { return b == null && (b = this.eventTimeFormat), c == null && (c = this.displayEventEnd), this.displayEventTime && a.start.hasTime() ? c && a.end ? this.view.formatRange(a, b) : a.start.format(b) : ''; },
    getSegClasses(a, b, c) { const d = this.view; const e = a.event; const f = ['fc-event', a.isStart ? 'fc-start' : 'fc-not-start', a.isEnd ? 'fc-end' : 'fc-not-end'].concat(e.className, e.source ? e.source.className : []); return b && f.push('fc-draggable'), c && f.push('fc-resizable'), d.isEventSelected(e) && f.push('fc-selected'), f; },
    getSegSkinCss(a) { const b = a.event; const c = this.view; const d = b.source || {}; const e = b.color; const f = d.color; const g = c.opt('eventColor'); return { 'background-color': b.backgroundColor || e || d.backgroundColor || f || c.opt('eventBackgroundColor') || g, 'border-color': b.borderColor || e || d.borderColor || f || c.opt('eventBorderColor') || g, color: b.textColor || d.textColor || c.opt('eventTextColor') }; },
    eventToSegs(a) { return this.eventsToSegs([a]); },
    eventToSpan(a) { return this.eventToSpans(a)[0]; },
    eventToSpans(a) { const b = this.eventToRange(a); return this.eventRangeToSpans(b, a); },
    eventsToSegs(b, c) { const d = this; const e = Ga(b); const f = []; return a.each(e, (a, b) => { let e; let g = []; for (e = 0; e < b.length; e++)g.push(d.eventToRange(b[e])); if (Ea(b[0])) for (g = d.invertRanges(g), e = 0; e < g.length; e++)f.push.apply(f, d.eventRangeToSegs(g[e], b[0], c)); else for (e = 0; e < g.length; e++)f.push.apply(f, d.eventRangeToSegs(g[e], b[e], c)); }), f; },
    eventToRange(a) { return { start: a.start.clone().stripZone(), end: (a.end ? a.end.clone() : this.view.calendar.getDefaultEventEnd(a.allDay != null ? a.allDay : !a.start.hasTime(), a.start)).stripZone() }; },
    eventRangeToSegs(a, b, c) { let d; const e = this.eventRangeToSpans(a, b); const f = []; for (d = 0; d < e.length; d++)f.push.apply(f, this.eventSpanToSegs(e[d], b, c)); return f; },
    eventRangeToSpans(b, c) { return [a.extend({}, b)]; },
    eventSpanToSegs(a, b, c) { let d; let e; const f = c ? c(a) : this.spanToSegs(a); for (d = 0; d < f.length; d++)e = f[d], e.event = b, e.eventStartMS = +a.start, e.eventDurationMS = a.end - a.start; return f; },
    invertRanges(a) { let b; let c; const d = this.view; const e = d.start.clone(); const f = d.end.clone(); const g = []; let h = e; for (a.sort(Ha), b = 0; b < a.length; b++)c = a[b], c.start > h && g.push({ start: h, end: c.start }), h = c.end; return f > h && g.push({ start: h, end: f }), g; },
    sortEventSegs(a) { a.sort(ia(this, 'compareEventSegs')); },
    compareEventSegs(a, b) { return a.eventStartMS - b.eventStartMS || b.eventDurationMS - a.eventDurationMS || b.event.allDay - a.event.allDay || H(a.event, b.event, this.view.eventOrderSpecs); },
  }), Wa.isBgEvent = Da, Wa.dataAttrPrefix = ''; const ub = Wa.DayTableMixin = {
    breakOnWeeks: !1,
    dayDates: null,
    dayIndices: null,
    daysPerRow: null,
    rowCnt: null,
    colCnt: null,
    colHeadFormat: null,
    updateDayTable() { for (var a, b, c, d = this.view, e = this.start.clone(), f = -1, g = [], h = []; e.isBefore(this.end);)d.isHiddenDay(e) ? g.push(f + 0.5) : (f++, g.push(f), h.push(e.clone())), e.add(1, 'days'); if (this.breakOnWeeks) { for (b = h[0].day(), a = 1; a < h.length && h[a].day() != b; a++);c = Math.ceil(h.length / a); } else c = 1, a = h.length; this.dayDates = h, this.dayIndices = g, this.daysPerRow = a, this.rowCnt = c, this.updateDayTableCols(); },
    updateDayTableCols() {
      this.colCnt = this.computeColCnt(),
      this.colHeadFormat = this.view.opt('columnFormat') || this.computeColHeadFormat();
    },
    computeColCnt() { return this.daysPerRow; },
    getCellDate(a, b) { return this.dayDates[this.getCellDayIndex(a, b)].clone(); },
    getCellRange(a, b) { const c = this.getCellDate(a, b); const d = c.clone().add(1, 'days'); return { start: c, end: d }; },
    getCellDayIndex(a, b) { return a * this.daysPerRow + this.getColDayIndex(b); },
    getColDayIndex(a) { return this.isRTL ? this.colCnt - 1 - a : a; },
    getDateDayIndex(a) { const b = this.dayIndices; const c = a.diff(this.start, 'days'); return c < 0 ? b[0] - 1 : c >= b.length ? b[b.length - 1] + 1 : b[c]; },
    computeColHeadFormat() { return this.rowCnt > 1 || this.colCnt > 10 ? 'ddd' : this.colCnt > 1 ? this.view.opt('dayOfMonthFormat') : 'dddd'; },
    sliceRangeByRow(a) {
      let b; let c; let d; let e; let f; const g = this.daysPerRow; const h = this.view.computeDayRange(a); const i = this.getDateDayIndex(h.start); const j = this.getDateDayIndex(h.end.clone().subtract(1, 'days')); const k = []; for (b = 0; b < this.rowCnt; b++) {
        c = b * g, d = c + g - 1, e = Math.max(i, c), f = Math.min(j, d), e = Math.ceil(e), f = Math.floor(f), f >= e && k.push({
          row: b, firstRowDayIndex: e - c, lastRowDayIndex: f - c, isStart: e === i, isEnd: f === j,
        });
      } return k;
    },
    sliceRangeByDay(a) {
      let b; let c; let d; let e; let f; let g; const h = this.daysPerRow; const i = this.view.computeDayRange(a); const j = this.getDateDayIndex(i.start); const k = this.getDateDayIndex(i.end.clone().subtract(1, 'days')); const l = []; for (b = 0; b < this.rowCnt; b++) {
        for (c = b * h, d = c + h - 1, e = c; d >= e; e++) {
          f = Math.max(j, e), g = Math.min(k, e), f = Math.ceil(f), g = Math.floor(g), g >= f && l.push({
            row: b, firstRowDayIndex: f - c, lastRowDayIndex: g - c, isStart: f === j, isEnd: g === k,
          });
        }
      } return l;
    },
    renderHeadHtml() { const a = this.view; return `<div class="fc-row ${a.widgetHeaderClass}"><table><thead>${this.renderHeadTrHtml()}</thead></table></div>`; },
    renderHeadIntroHtml() { return this.renderIntroHtml(); },
    renderHeadTrHtml() { return `<tr>${this.isRTL ? '' : this.renderHeadIntroHtml()}${this.renderHeadDateCellsHtml()}${this.isRTL ? this.renderHeadIntroHtml() : ''}</tr>`; },
    renderHeadDateCellsHtml() { let a; let b; const c = []; for (a = 0; a < this.colCnt; a++)b = this.getCellDate(0, a), c.push(this.renderHeadDateCellHtml(b)); return c.join(''); },
    renderHeadDateCellHtml(a, b, c) { const d = this.view; return `<th class="fc-day-header ${d.widgetHeaderClass} fc-${$a[a.day()]}"${this.rowCnt == 1 ? ` data-date="${a.format('YYYY-MM-DD')}"` : ''}${b > 1 ? ` colspan="${b}"` : ''}${c ? ` ${c}` : ''}>${ca(a.format(this.colHeadFormat))}</th>`; },
    renderBgTrHtml(a) { return `<tr>${this.isRTL ? '' : this.renderBgIntroHtml(a)}${this.renderBgCellsHtml(a)}${this.isRTL ? this.renderBgIntroHtml(a) : ''}</tr>`; },
    renderBgIntroHtml(a) { return this.renderIntroHtml(); },
    renderBgCellsHtml(a) { let b; let c; const d = []; for (b = 0; b < this.colCnt; b++)c = this.getCellDate(a, b), d.push(this.renderBgCellHtml(c)); return d.join(''); },
    renderBgCellHtml(a, b) { const c = this.view; const d = this.getDayClasses(a); return d.unshift('fc-day', c.widgetContentClass), `<td class="${d.join(' ')}" data-date="${a.format('YYYY-MM-DD')}"${b ? ` ${b}` : ''}></td>`; },
    renderIntroHtml() {},
    bookendCells(a) { const b = this.renderIntroHtml(); b && (this.isRTL ? a.append(b) : a.prepend(b)); },
  }; const vb = Wa.DayGrid = tb.extend(ub, {
    numbersVisible: !1,
    bottomCoordPadding: 0,
    rowEls: null,
    cellEls: null,
    helperEls: null,
    rowCoordCache: null,
    colCoordCache: null,
    renderDates(a) { let b; let c; const d = this.view; const e = this.rowCnt; const f = this.colCnt; let g = ''; for (b = 0; e > b; b++)g += this.renderDayRowHtml(b, a); for (this.el.html(g), this.rowEls = this.el.find('.fc-row'), this.cellEls = this.el.find('.fc-day'), this.rowCoordCache = new pb({ els: this.rowEls, isVertical: !0 }), this.colCoordCache = new pb({ els: this.cellEls.slice(0, this.colCnt), isHorizontal: !0 }), b = 0; e > b; b++) for (c = 0; f > c; c++)d.trigger('dayRender', null, this.getCellDate(b, c), this.getCellEl(b, c)); },
    unrenderDates() { this.removeSegPopover(); },
    renderBusinessHours() { const a = this.view.calendar.getBusinessHoursEvents(!0); const b = this.eventsToSegs(a); this.renderFill('businessHours', b, 'bgevent'); },
    unrenderBusinessHours() { this.unrenderFill('businessHours'); },
    renderDayRowHtml(a, b) { const c = this.view; const d = ['fc-row', 'fc-week', c.widgetContentClass]; return b && d.push('fc-rigid'), `<div class="${d.join(' ')}"><div class="fc-bg"><table>${this.renderBgTrHtml(a)}</table></div><div class="fc-content-skeleton"><table>${this.numbersVisible ? `<thead>${this.renderNumberTrHtml(a)}</thead>` : ''}</table></div></div>`; },
    renderNumberTrHtml(a) { return `<tr>${this.isRTL ? '' : this.renderNumberIntroHtml(a)}${this.renderNumberCellsHtml(a)}${this.isRTL ? this.renderNumberIntroHtml(a) : ''}</tr>`; },
    renderNumberIntroHtml(a) { return this.renderIntroHtml(); },
    renderNumberCellsHtml(a) { let b; let c; const d = []; for (b = 0; b < this.colCnt; b++)c = this.getCellDate(a, b), d.push(this.renderNumberCellHtml(c)); return d.join(''); },
    renderNumberCellHtml(a) { let b; return this.view.dayNumbersVisible ? (b = this.getDayClasses(a), b.unshift('fc-day-number'), `<td class="${b.join(' ')}" data-date="${a.format()}">${a.date()}</td>`) : '<td/>'; },
    computeEventTimeFormat() { return this.view.opt('extraSmallTimeFormat'); },
    computeDisplayEventEnd() { return this.colCnt == 1; },
    rangeUpdated() { this.updateDayTable(); },
    spanToSegs(a) { let b; let c; const d = this.sliceRangeByRow(a); for (b = 0; b < d.length; b++)c = d[b], this.isRTL ? (c.leftCol = this.daysPerRow - 1 - c.lastRowDayIndex, c.rightCol = this.daysPerRow - 1 - c.firstRowDayIndex) : (c.leftCol = c.firstRowDayIndex, c.rightCol = c.lastRowDayIndex); return d; },
    prepareHits() { this.colCoordCache.build(), this.rowCoordCache.build(), this.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; },
    releaseHits() { this.colCoordCache.clear(), this.rowCoordCache.clear(); },
    queryHit(a, b) { const c = this.colCoordCache.getHorizontalIndex(a); const d = this.rowCoordCache.getVerticalIndex(b); return d != null && c != null ? this.getCellHit(d, c) : void 0; },
    getHitSpan(a) { return this.getCellRange(a.row, a.col); },
    getHitEl(a) { return this.getCellEl(a.row, a.col); },
    getCellHit(a, b) {
      return {
        row: a, col: b, component: this, left: this.colCoordCache.getLeftOffset(b), right: this.colCoordCache.getRightOffset(b), top: this.rowCoordCache.getTopOffset(a), bottom: this.rowCoordCache.getBottomOffset(a),
      };
    },
    getCellEl(a, b) { return this.cellEls.eq(a * this.colCnt + b); },
    renderDrag(a, b) { return this.renderHighlight(this.eventToSpan(a)), b && !b.el.closest(this.el).length ? this.renderEventLocationHelper(a, b) : void 0; },
    unrenderDrag() { this.unrenderHighlight(), this.unrenderHelper(); },
    renderEventResize(a, b) { return this.renderHighlight(this.eventToSpan(a)), this.renderEventLocationHelper(a, b); },
    unrenderEventResize() { this.unrenderHighlight(), this.unrenderHelper(); },
    renderHelper(b, c) { let d; const e = []; let f = this.eventToSegs(b); return f = this.renderFgSegEls(f), d = this.renderSegRows(f), this.rowEls.each((b, f) => { let g; const h = a(f); const i = a('<div class="fc-helper-skeleton"><table/></div>'); g = c && c.row === b ? c.el.position().top : h.find('.fc-content-skeleton tbody').position().top, i.css('top', g).find('table').append(d[b].tbodyEl), h.append(i), e.push(i[0]); }), this.helperEls = a(e); },
    unrenderHelper() { this.helperEls && (this.helperEls.remove(), this.helperEls = null); },
    fillSegTag: 'td',
    renderFill(b, c, d) { let e; let f; let g; const h = []; for (c = this.renderFillSegEls(b, c), e = 0; e < c.length; e++)f = c[e], g = this.renderFillRow(b, f, d), this.rowEls.eq(f.row).append(g), h.push(g[0]); return this.elsByFill[b] = a(h), c; },
    renderFillRow(b, c, d) { let e; let f; const g = this.colCnt; const h = c.leftCol; const i = c.rightCol + 1; return d = d || b.toLowerCase(), e = a(`<div class="fc-${d}-skeleton"><table><tr/></table></div>`), f = e.find('tr'), h > 0 && f.append(`<td colspan="${h}"/>`), f.append(c.el.attr('colspan', i - h)), g > i && f.append(`<td colspan="${g - i}"/>`), this.bookendCells(f), e; },
  }); vb.mixin({
    rowStructs: null,
    unrenderEvents() { this.removeSegPopover(), tb.prototype.unrenderEvents.apply(this, arguments); },
    getEventSegs() { return tb.prototype.getEventSegs.call(this).concat(this.popoverSegs || []); },
    renderBgSegs(b) { const c = a.grep(b, (a) => a.event.allDay); return tb.prototype.renderBgSegs.call(this, c); },
    renderFgSegs(b) { let c; return b = this.renderFgSegEls(b), c = this.rowStructs = this.renderSegRows(b), this.rowEls.each((b, d) => { a(d).find('.fc-content-skeleton > table').append(c[b].tbodyEl); }), b; },
    unrenderFgSegs() { for (var a, b = this.rowStructs || []; a = b.pop();)a.tbodyEl.remove(); this.rowStructs = null; },
    renderSegRows(a) { let b; let c; const d = []; for (b = this.groupSegRows(a), c = 0; c < b.length; c++)d.push(this.renderSegRow(c, b[c])); return d; },
    fgSegHtml(a, b) { let c; let d; const e = this.view; const f = a.event; const g = e.isEventDraggable(f); const h = !b && f.allDay && a.isStart && e.isEventResizableFromStart(f); const i = !b && f.allDay && a.isEnd && e.isEventResizableFromEnd(f); const j = this.getSegClasses(a, g, h || i); const k = ea(this.getSegSkinCss(a)); let l = ''; return j.unshift('fc-day-grid-event', 'fc-h-event'), a.isStart && (c = this.getEventTimeText(f), c && (l = `<span class="fc-time">${ca(c)}</span>`)), d = `<span class="fc-title">${ca(f.title || '') || '&nbsp;'}</span>`, `<a class="${j.join(' ')}"${f.url ? ` href="${ca(f.url)}"` : ''}${k ? ` style="${k}"` : ''}><div class="fc-content">${this.isRTL ? `${d} ${l}` : `${l} ${d}`}</div>${h ? '<div class="fc-resizer fc-start-resizer" />' : ''}${i ? '<div class="fc-resizer fc-end-resizer" />' : ''}</a>`; },
    renderSegRow(b, c) {
      function d(b) { for (;b > g;)k = (r[e - 1] || [])[g], k ? k.attr('rowspan', parseInt(k.attr('rowspan') || 1, 10) + 1) : (k = a('<td/>'), h.append(k)), q[e][g] = k, r[e][g] = k, g++; } let e; let f; let g; let h; let i; let j; let k; const l = this.colCnt; const m = this.buildSegLevels(c); const n = Math.max(1, m.length); const o = a('<tbody/>'); const p = []; var q = []; var r = []; for (e = 0; n > e; e++) { if (f = m[e], g = 0, h = a('<tr/>'), p.push([]), q.push([]), r.push([]), f) for (i = 0; i < f.length; i++) { for (j = f[i], d(j.leftCol), k = a('<td class="fc-event-container"/>').append(j.el), j.leftCol != j.rightCol ? k.attr('colspan', j.rightCol - j.leftCol + 1) : r[e][g] = k; g <= j.rightCol;)q[e][g] = k, p[e][g] = j, g++; h.append(k); }d(l), this.bookendCells(h), o.append(h); } return {
        row: b, tbodyEl: o, cellMatrix: q, segMatrix: p, segLevels: m, segs: c,
      };
    },
    buildSegLevels(a) { let b; let c; let d; const e = []; for (this.sortEventSegs(a), b = 0; b < a.length; b++) { for (c = a[b], d = 0; d < e.length && Ja(c, e[d]); d++);c.level = d, (e[d] || (e[d] = [])).push(c); } for (d = 0; d < e.length; d++)e[d].sort(Ka); return e; },
    groupSegRows(a) { let b; const c = []; for (b = 0; b < this.rowCnt; b++)c.push([]); for (b = 0; b < a.length; b++)c[a[b].row].push(a[b]); return c; },
  }), vb.mixin({
    segPopover: null,
    popoverSegs: null,
    removeSegPopover() { this.segPopover && this.segPopover.hide(); },
    limitRows(a) { let b; let c; const d = this.rowStructs || []; for (b = 0; b < d.length; b++) this.unlimitRow(b), c = a ? typeof a === 'number' ? a : this.computeRowLevelLimit(b) : !1, c !== !1 && this.limitRow(b, c); },
    computeRowLevelLimit(b) { function c(b, c) { f = Math.max(f, a(c).outerHeight()); } let d; let e; let f; const g = this.rowEls.eq(b); const h = g.height(); const i = this.rowStructs[b].tbodyEl.children(); for (d = 0; d < i.length; d++) if (e = i.eq(d).removeClass('fc-limited'), f = 0, e.find('> td > :first-child').each(c), e.position().top + f > h) return d; return !1; },
    limitRow(b, c) { function d(d) { for (;d > w;)j = t.getCellSegs(b, w, c), j.length && (m = f[c - 1][w], s = t.renderMoreLink(b, w, j), r = a('<div/>').append(s), m.append(r), v.push(r[0])), w++; } let e; let f; let g; let h; let i; let j; let k; let l; let m; let n; let o; let p; let q; let r; let s; var t = this; const u = this.rowStructs[b]; var v = []; var w = 0; if (c && c < u.segLevels.length) { for (e = u.segLevels[c - 1], f = u.cellMatrix, g = u.tbodyEl.children().slice(c).addClass('fc-limited').get(), h = 0; h < e.length; h++) { for (i = e[h], d(i.leftCol), l = [], k = 0; w <= i.rightCol;)j = this.getCellSegs(b, w, c), l.push(j), k += j.length, w++; if (k) { for (m = f[c - 1][i.leftCol], n = m.attr('rowspan') || 1, o = [], p = 0; p < l.length; p++)q = a('<td class="fc-more-cell"/>').attr('rowspan', n), j = l[p], s = this.renderMoreLink(b, i.leftCol + p, [i].concat(j)), r = a('<div/>').append(s), q.append(r), o.push(q[0]), v.push(q[0]); m.addClass('fc-limited').after(a(o)), g.push(m[0]); } }d(this.colCnt), u.moreEls = a(v), u.limitedEls = a(g); } },
    unlimitRow(a) { const b = this.rowStructs[a]; b.moreEls && (b.moreEls.remove(), b.moreEls = null), b.limitedEls && (b.limitedEls.removeClass('fc-limited'), b.limitedEls = null); },
    renderMoreLink(b, c, d) {
      const e = this; const f = this.view; return a('<a class="fc-more"/>').text(this.getMoreLinkText(d.length)).on('click', function (g) {
        let h = f.opt('eventLimitClick'); const i = e.getCellDate(b, c); const j = a(this); const k = e.getCellEl(b, c); const l = e.getCellSegs(b, c); const m = e.resliceDaySegs(l, i); const n = e.resliceDaySegs(d, i); typeof h === 'function' && (h = f.trigger('eventLimitClick', null, {
          date: i, dayEl: k, moreEl: j, segs: m, hiddenSegs: n,
        }, g)), h === 'popover' ? e.showSegPopover(b, c, j, m) : typeof h === 'string' && f.calendar.zoomTo(i, h);
      });
    },
    showSegPopover(a, b, c, d) {
      let e; let f; const g = this; const h = this.view; const i = c.parent(); e = this.rowCnt == 1 ? h.el : this.rowEls.eq(a), f = {
        className: 'fc-more-popover', content: this.renderSegPopoverContent(a, b, d), parentEl: this.el, top: e.offset().top, autoHide: !0, viewportConstrain: h.opt('popoverViewportConstrain'), hide() { g.segPopover.removeElement(), g.segPopover = null, g.popoverSegs = null; },
      }, this.isRTL ? f.right = i.offset().left + i.outerWidth() + 1 : f.left = i.offset().left - 1, this.segPopover = new ob(f), this.segPopover.show();
    },
    renderSegPopoverContent(b, c, d) { let e; const f = this.view; const g = f.opt('theme'); const h = this.getCellDate(b, c).format(f.opt('dayPopoverFormat')); const i = a(`<div class="fc-header ${f.widgetHeaderClass}"><span class="fc-close ${g ? 'ui-icon ui-icon-closethick' : 'fc-icon fc-icon-x'}"></span><span class="fc-title">${ca(h)}</span><div class="fc-clear"/></div><div class="fc-body ${f.widgetContentClass}"><div class="fc-event-container"></div></div>`); const j = i.find('.fc-event-container'); for (d = this.renderFgSegEls(d, !0), this.popoverSegs = d, e = 0; e < d.length; e++) this.prepareHits(), d[e].hit = this.getCellHit(b, c), this.releaseHits(), j.append(d[e].el); return i; },
    resliceDaySegs(b, c) { const d = a.map(b, (a) => a.event); const e = c.clone(); const f = e.clone().add(1, 'days'); const g = { start: e, end: f }; return b = this.eventsToSegs(d, (a) => { const b = K(a, g); return b ? [b] : []; }), this.sortEventSegs(b), b; },
    getMoreLinkText(a) { const b = this.view.opt('eventLimitText'); return typeof b === 'function' ? b(a) : `+${a} ${b}`; },
    getCellSegs(a, b, c) { for (var d, e = this.rowStructs[a].segMatrix, f = c || 0, g = []; f < e.length;)d = e[f][b], d && g.push(d), f++; return g; },
  }); const wb = Wa.TimeGrid = tb.extend(ub, {
    slotDuration: null,
    snapDuration: null,
    snapsPerSlot: null,
    minTime: null,
    maxTime: null,
    labelFormat: null,
    labelInterval: null,
    colEls: null,
    slatContainerEl: null,
    slatEls: null,
    nowIndicatorEls: null,
    colCoordCache: null,
    slatCoordCache: null,
    constructor() { tb.apply(this, arguments), this.processOptions(); },
    renderDates() { this.el.html(this.renderHtml()), this.colEls = this.el.find('.fc-day'), this.slatContainerEl = this.el.find('.fc-slats'), this.slatEls = this.slatContainerEl.find('tr'), this.colCoordCache = new pb({ els: this.colEls, isHorizontal: !0 }), this.slatCoordCache = new pb({ els: this.slatEls, isVertical: !0 }), this.renderContentSkeleton(); },
    renderHtml() { return `<div class="fc-bg"><table>${this.renderBgTrHtml(0)}</table></div><div class="fc-slats"><table>${this.renderSlatRowHtml()}</table></div>`; },
    renderSlatRowHtml() { for (var a, c, d, e = this.view, f = this.isRTL, g = '', h = b.duration(+this.minTime); h < this.maxTime;)a = this.start.clone().time(h), c = ha(R(h, this.labelInterval)), d = `<td class="fc-axis fc-time ${e.widgetContentClass}" ${e.axisStyleAttr()}>${c ? `<span>${ca(a.format(this.labelFormat))}</span>` : ''}</td>`, g += `<tr data-time="${a.format('HH:mm:ss')}"${c ? '' : ' class="fc-minor"'}>${f ? '' : d}<td class="${e.widgetContentClass}"/>${f ? d : ''}</tr>`, h.add(this.slotDuration); return g; },
    processOptions() { let c; const d = this.view; let e = d.opt('slotDuration'); let f = d.opt('snapDuration'); e = b.duration(e), f = f ? b.duration(f) : e, this.slotDuration = e, this.snapDuration = f, this.snapsPerSlot = e / f, this.minResizeDuration = f, this.minTime = b.duration(d.opt('minTime')), this.maxTime = b.duration(d.opt('maxTime')), c = d.opt('slotLabelFormat'), a.isArray(c) && (c = c[c.length - 1]), this.labelFormat = c || d.opt('axisFormat') || d.opt('smallTimeFormat'), c = d.opt('slotLabelInterval'), this.labelInterval = c ? b.duration(c) : this.computeLabelInterval(e); },
    computeLabelInterval(a) { let c; let d; let e; for (c = Nb.length - 1; c >= 0; c--) if (d = b.duration(Nb[c]), e = R(d, a), ha(e) && e > 1) return d; return b.duration(a); },
    computeEventTimeFormat() { return this.view.opt('noMeridiemTimeFormat'); },
    computeDisplayEventEnd() { return !0; },
    prepareHits() { this.colCoordCache.build(), this.slatCoordCache.build(); },
    releaseHits() { this.colCoordCache.clear(); },
    queryHit(a, b) {
      const c = this.snapsPerSlot; const d = this.colCoordCache; const e = this.slatCoordCache; const f = d.getHorizontalIndex(a); const g = e.getVerticalIndex(b); if (f != null && g != null) {
        const h = e.getTopOffset(g); const i = e.getHeight(g); const j = (b - h) / i; const k = Math.floor(j * c); const l = g * c + k; const m = h + k / c * i; const n = h + (k + 1) / c * i; return {
          col: f, snap: l, component: this, left: d.getLeftOffset(f), right: d.getRightOffset(f), top: m, bottom: n,
        };
      }
    },
    getHitSpan(a) { let b; const c = this.getCellDate(0, a.col); const d = this.computeSnapTime(a.snap); return c.time(d), b = c.clone().add(this.snapDuration), { start: c, end: b }; },
    getHitEl(a) { return this.colEls.eq(a.col); },
    rangeUpdated() { this.updateDayTable(); },
    computeSnapTime(a) { return b.duration(this.minTime + this.snapDuration * a); },
    spanToSegs(a) { let b; const c = this.sliceRangeByTimes(a); for (b = 0; b < c.length; b++) this.isRTL ? c[b].col = this.daysPerRow - 1 - c[b].dayIndex : c[b].col = c[b].dayIndex; return c; },
    sliceRangeByTimes(a) { let b; let c; let d; let e; const f = []; for (c = 0; c < this.daysPerRow; c++)d = this.dayDates[c].clone(), e = { start: d.clone().time(this.minTime), end: d.clone().time(this.maxTime) }, b = K(a, e), b && (b.dayIndex = c, f.push(b)); return f; },
    updateSize(a) { this.slatCoordCache.build(), a && this.updateSegVerticals([].concat(this.fgSegs || [], this.bgSegs || [], this.businessSegs || [])); },
    getTotalSlatHeight() { return this.slatContainerEl.outerHeight(); },
    computeDateTop(a, c) { return this.computeTimeTop(b.duration(a - c.clone().stripTime())); },
    computeTimeTop(a) { let b; let c; const d = this.slatEls.length; let e = (a - this.minTime) / this.slotDuration; return e = Math.max(0, e), e = Math.min(d, e), b = Math.floor(e), b = Math.min(b, d - 1), c = e - b, this.slatCoordCache.getTopPosition(b) + this.slatCoordCache.getHeight(b) * c; },
    renderDrag(a, b) { return b ? this.renderEventLocationHelper(a, b) : void this.renderHighlight(this.eventToSpan(a)); },
    unrenderDrag() { this.unrenderHelper(), this.unrenderHighlight(); },
    renderEventResize(a, b) { return this.renderEventLocationHelper(a, b); },
    unrenderEventResize() { this.unrenderHelper(); },
    renderHelper(a, b) { return this.renderHelperSegs(this.eventToSegs(a), b); },
    unrenderHelper() { this.unrenderHelperSegs(); },
    renderBusinessHours() { const a = this.view.calendar.getBusinessHoursEvents(); const b = this.eventsToSegs(a); this.renderBusinessSegs(b); },
    unrenderBusinessHours() { this.unrenderBusinessSegs(); },
    getNowIndicatorUnit() { return 'minute'; },
    renderNowIndicator(b) { let c; const d = this.spanToSegs({ start: b, end: b }); const e = this.computeDateTop(b, b); const f = []; for (c = 0; c < d.length; c++)f.push(a('<div class="fc-now-indicator fc-now-indicator-line"></div>').css('top', e).appendTo(this.colContainerEls.eq(d[c].col))[0]); d.length > 0 && f.push(a('<div class="fc-now-indicator fc-now-indicator-arrow"></div>').css('top', e).appendTo(this.el.find('.fc-content-skeleton'))[0]), this.nowIndicatorEls = a(f); },
    unrenderNowIndicator() { this.nowIndicatorEls && (this.nowIndicatorEls.remove(), this.nowIndicatorEls = null); },
    renderSelection(a) { this.view.opt('selectHelper') ? this.renderEventLocationHelper(a) : this.renderHighlight(a); },
    unrenderSelection() { this.unrenderHelper(), this.unrenderHighlight(); },
    renderHighlight(a) { this.renderHighlightSegs(this.spanToSegs(a)); },
    unrenderHighlight() { this.unrenderHighlightSegs(); },
  }); wb.mixin({
    colContainerEls: null,
    fgContainerEls: null,
    bgContainerEls: null,
    helperContainerEls: null,
    highlightContainerEls: null,
    businessContainerEls: null,
    fgSegs: null,
    bgSegs: null,
    helperSegs: null,
    highlightSegs: null,
    businessSegs: null,
    renderContentSkeleton() { let b; let c; let d = ''; for (b = 0; b < this.colCnt; b++)d += '<td><div class="fc-content-col"><div class="fc-event-container fc-helper-container"></div><div class="fc-event-container"></div><div class="fc-highlight-container"></div><div class="fc-bgevent-container"></div><div class="fc-business-container"></div></div></td>'; c = a(`<div class="fc-content-skeleton"><table><tr>${d}</tr></table></div>`), this.colContainerEls = c.find('.fc-content-col'), this.helperContainerEls = c.find('.fc-helper-container'), this.fgContainerEls = c.find('.fc-event-container:not(.fc-helper-container)'), this.bgContainerEls = c.find('.fc-bgevent-container'), this.highlightContainerEls = c.find('.fc-highlight-container'), this.businessContainerEls = c.find('.fc-business-container'), this.bookendCells(c.find('tr')), this.el.append(c); },
    renderFgSegs(a) { return a = this.renderFgSegsIntoContainers(a, this.fgContainerEls), this.fgSegs = a, a; },
    unrenderFgSegs() { this.unrenderNamedSegs('fgSegs'); },
    renderHelperSegs(b, c) {
      let d; let e; let f; const g = []; for (b = this.renderFgSegsIntoContainers(b, this.helperContainerEls), d = 0; d < b.length; d++) {
        e = b[d], c && c.col === e.col && (f = c.el, e.el.css({
          left: f.css('left'), right: f.css('right'), 'margin-left': f.css('margin-left'), 'margin-right': f.css('margin-right'),
        })), g.push(e.el[0]);
      } return this.helperSegs = b, a(g);
    },
    unrenderHelperSegs() { this.unrenderNamedSegs('helperSegs'); },
    renderBgSegs(a) { return a = this.renderFillSegEls('bgEvent', a), this.updateSegVerticals(a), this.attachSegsByCol(this.groupSegsByCol(a), this.bgContainerEls), this.bgSegs = a, a; },
    unrenderBgSegs() { this.unrenderNamedSegs('bgSegs'); },
    renderHighlightSegs(a) { a = this.renderFillSegEls('highlight', a), this.updateSegVerticals(a), this.attachSegsByCol(this.groupSegsByCol(a), this.highlightContainerEls), this.highlightSegs = a; },
    unrenderHighlightSegs() { this.unrenderNamedSegs('highlightSegs'); },
    renderBusinessSegs(a) { a = this.renderFillSegEls('businessHours', a), this.updateSegVerticals(a), this.attachSegsByCol(this.groupSegsByCol(a), this.businessContainerEls), this.businessSegs = a; },
    unrenderBusinessSegs() { this.unrenderNamedSegs('businessSegs'); },
    groupSegsByCol(a) { let b; const c = []; for (b = 0; b < this.colCnt; b++)c.push([]); for (b = 0; b < a.length; b++)c[a[b].col].push(a[b]); return c; },
    attachSegsByCol(a, b) { let c; let d; let e; for (c = 0; c < this.colCnt; c++) for (d = a[c], e = 0; e < d.length; e++)b.eq(c).append(d[e].el); },
    unrenderNamedSegs(a) { let b; const c = this[a]; if (c) { for (b = 0; b < c.length; b++)c[b].el.remove(); this[a] = null; } },
    renderFgSegsIntoContainers(a, b) { let c; let d; for (a = this.renderFgSegEls(a), c = this.groupSegsByCol(a), d = 0; d < this.colCnt; d++) this.updateFgSegCoords(c[d]); return this.attachSegsByCol(c, b), a; },
    fgSegHtml(a, b) { let c; let d; let e; const f = this.view; const g = a.event; const h = f.isEventDraggable(g); const i = !b && a.isStart && f.isEventResizableFromStart(g); const j = !b && a.isEnd && f.isEventResizableFromEnd(g); const k = this.getSegClasses(a, h, i || j); const l = ea(this.getSegSkinCss(a)); return k.unshift('fc-time-grid-event', 'fc-v-event'), f.isMultiDayEvent(g) ? (a.isStart || a.isEnd) && (c = this.getEventTimeText(a), d = this.getEventTimeText(a, 'LT'), e = this.getEventTimeText(a, null, !1)) : (c = this.getEventTimeText(g), d = this.getEventTimeText(g, 'LT'), e = this.getEventTimeText(g, null, !1)), `<a class="${k.join(' ')}"${g.url ? ` href="${ca(g.url)}"` : ''}${l ? ` style="${l}"` : ''}><div class="fc-content">${c ? `<div class="fc-time" data-start="${ca(e)}" data-full="${ca(d)}"><span>${ca(c)}</span></div>` : ''}${g.title ? `<div class="fc-title">${ca(g.title)}</div>` : ''}</div><div class="fc-bg"/>${j ? '<div class="fc-resizer fc-end-resizer" />' : ''}</a>`; },
    updateSegVerticals(a) { this.computeSegVerticals(a), this.assignSegVerticals(a); },
    computeSegVerticals(a) { let b; let c; for (b = 0; b < a.length; b++)c = a[b], c.top = this.computeDateTop(c.start, c.start), c.bottom = this.computeDateTop(c.end, c.start); },
    assignSegVerticals(a) { let b; let c; for (b = 0; b < a.length; b++)c = a[b], c.el.css(this.generateSegVerticalCss(c)); },
    generateSegVerticalCss(a) { return { top: a.top, bottom: -a.bottom }; },
    updateFgSegCoords(a) { this.computeSegVerticals(a), this.computeFgSegHorizontals(a), this.assignSegVerticals(a), this.assignFgSegHorizontals(a); },
    computeFgSegHorizontals(a) { let b; let c; let d; if (this.sortEventSegs(a), b = La(a), Ma(b), c = b[0]) { for (d = 0; d < c.length; d++)Na(c[d]); for (d = 0; d < c.length; d++) this.computeFgSegForwardBack(c[d], 0, 0); } },
    computeFgSegForwardBack(a, b, c) { let d; const e = a.forwardSegs; if (void 0 === a.forwardCoord) for (e.length ? (this.sortForwardSegs(e), this.computeFgSegForwardBack(e[0], b + 1, c), a.forwardCoord = e[0].backwardCoord) : a.forwardCoord = 1, a.backwardCoord = a.forwardCoord - (a.forwardCoord - c) / (b + 1), d = 0; d < e.length; d++) this.computeFgSegForwardBack(e[d], 0, a.forwardCoord); },
    sortForwardSegs(a) { a.sort(ia(this, 'compareForwardSegs')); },
    compareForwardSegs(a, b) { return b.forwardPressure - a.forwardPressure || (a.backwardCoord || 0) - (b.backwardCoord || 0) || this.compareEventSegs(a, b); },
    assignFgSegHorizontals(a) { let b; let c; for (b = 0; b < a.length; b++)c = a[b], c.el.css(this.generateFgSegHorizontalCss(c)), c.bottom - c.top < 30 && c.el.addClass('fc-short'); },
    generateFgSegHorizontalCss(a) { let b; let c; const d = this.view.opt('slotEventOverlap'); const e = a.backwardCoord; let f = a.forwardCoord; const g = this.generateSegVerticalCss(a); return d && (f = Math.min(1, e + 2 * (f - e))), this.isRTL ? (b = 1 - f, c = e) : (b = e, c = 1 - f), g.zIndex = a.level + 1, g.left = `${100 * b}%`, g.right = `${100 * c}%`, d && a.forwardPressure && (g[this.isRTL ? 'marginLeft' : 'marginRight'] = 20), g; },
  }); const xb = Wa.View = ya.extend(lb, mb, {
    type: null,
    name: null,
    title: null,
    calendar: null,
    options: null,
    el: null,
    displaying: null,
    isSkeletonRendered: !1,
    isEventsRendered: !1,
    start: null,
    end: null,
    intervalStart: null,
    intervalEnd: null,
    intervalDuration: null,
    intervalUnit: null,
    isRTL: !1,
    isSelected: !1,
    selectedEvent: null,
    eventOrderSpecs: null,
    widgetHeaderClass: null,
    widgetContentClass: null,
    highlightStateClass: null,
    nextDayThreshold: null,
    isHiddenDayHash: null,
    isNowIndicatorRendered: null,
    initialNowDate: null,
    initialNowQueriedMs: null,
    nowIndicatorTimeoutID: null,
    nowIndicatorIntervalID: null,
    constructor(a, c, d, e) { this.calendar = a, this.type = this.name = c, this.options = d, this.intervalDuration = e || b.duration(1, 'day'), this.nextDayThreshold = b.duration(this.opt('nextDayThreshold')), this.initThemingProps(), this.initHiddenDays(), this.isRTL = this.opt('isRTL'), this.eventOrderSpecs = G(this.opt('eventOrder')), this.initialize(); },
    initialize() {},
    opt(a) { return this.options[a]; },
    trigger(a, b) { const c = this.calendar; return c.trigger.apply(c, [a, b || this].concat(Array.prototype.slice.call(arguments, 2), [this])); },
    setDate(a) { this.setRange(this.computeRange(a)); },
    setRange(b) { a.extend(this, b), this.updateTitle(); },
    computeRange(a) {
      let b; let c; const d = O(this.intervalDuration); let e = a.clone().startOf(d); let f = e.clone().add(this.intervalDuration); return /year|month|week|day/.test(d) ? (e.stripTime(), f.stripTime()) : (e.hasTime() || (e = this.calendar.time(0)), f.hasTime() || (f = this.calendar.time(0))), b = e.clone(), b = this.skipHiddenDays(b), c = f.clone(), c = this.skipHiddenDays(c, -1, !0), {
        intervalUnit: d, intervalStart: e, intervalEnd: f, start: b, end: c,
      };
    },
    computePrevDate(a) { return this.massageCurrentDate(a.clone().startOf(this.intervalUnit).subtract(this.intervalDuration), -1); },
    computeNextDate(a) { return this.massageCurrentDate(a.clone().startOf(this.intervalUnit).add(this.intervalDuration)); },
    massageCurrentDate(a, b) { return this.intervalDuration.as('days') <= 1 && this.isHiddenDay(a) && (a = this.skipHiddenDays(a, b), a.startOf('day')), a; },
    updateTitle() { this.title = this.computeTitle(); },
    computeTitle() { return this.formatRange({ start: this.calendar.applyTimezone(this.intervalStart), end: this.calendar.applyTimezone(this.intervalEnd) }, this.opt('titleFormat') || this.computeTitleFormat(), this.opt('titleRangeSeparator')); },
    computeTitleFormat() { return this.intervalUnit == 'year' ? 'YYYY' : this.intervalUnit == 'month' ? this.opt('monthYearFormat') : this.intervalDuration.as('days') > 1 ? 'll' : 'LL'; },
    formatRange(a, b, c) { let d = a.end; return d.hasTime() || (d = d.clone().subtract(1)), ta(a.start, d, b, c, this.opt('isRTL')); },
    setElement(a) { this.el = a, this.bindGlobalHandlers(); },
    removeElement() { this.clear(), this.isSkeletonRendered && (this.unrenderSkeleton(), this.isSkeletonRendered = !1), this.unbindGlobalHandlers(), this.el.remove(); },
    display(a, b) { const c = this; let d = null; return b != null && this.displaying && (d = this.queryScroll()), this.calendar.freezeContentHeight(), ka(this.clear(), () => c.displaying = ka(c.displayView(a), () => { b != null ? c.setScroll(b) : c.forceScroll(c.computeInitialScroll(d)), c.calendar.unfreezeContentHeight(), c.triggerRender(); })); },
    clear() { const b = this; const c = this.displaying; return c ? ka(c, () => (b.displaying = null, b.clearEvents(), b.clearView())) : a.when(); },
    displayView(a) { this.isSkeletonRendered || (this.renderSkeleton(), this.isSkeletonRendered = !0), a && this.setDate(a), this.render && this.render(), this.renderDates(), this.updateSize(), this.renderBusinessHours(), this.startNowIndicator(); },
    clearView() { this.unselect(), this.stopNowIndicator(), this.triggerUnrender(), this.unrenderBusinessHours(), this.unrenderDates(), this.destroy && this.destroy(); },
    renderSkeleton() {},
    unrenderSkeleton() {},
    renderDates() {},
    unrenderDates() {},
    triggerRender() { this.trigger('viewRender', this, this, this.el); },
    triggerUnrender() { this.trigger('viewDestroy', this, this, this.el); },
    bindGlobalHandlers() { this.listenTo(a(document), 'mousedown', this.handleDocumentMousedown), this.listenTo(a(document), 'touchstart', this.processUnselect); },
    unbindGlobalHandlers() { this.stopListeningTo(a(document)); },
    initThemingProps() { const a = this.opt('theme') ? 'ui' : 'fc'; this.widgetHeaderClass = `${a}-widget-header`, this.widgetContentClass = `${a}-widget-content`, this.highlightStateClass = `${a}-state-highlight`; },
    renderBusinessHours() {},
    unrenderBusinessHours() {},
    startNowIndicator() { let a; let c; let d; const e = this; this.opt('nowIndicator') && (a = this.getNowIndicatorUnit(), a && (c = ia(this, 'updateNowIndicator'), this.initialNowDate = this.calendar.getNow(), this.initialNowQueriedMs = +new Date(), this.renderNowIndicator(this.initialNowDate), this.isNowIndicatorRendered = !0, d = this.initialNowDate.clone().startOf(a).add(1, a) - this.initialNowDate, this.nowIndicatorTimeoutID = setTimeout(() => { e.nowIndicatorTimeoutID = null, c(), d = +b.duration(1, a), d = Math.max(100, d), e.nowIndicatorIntervalID = setInterval(c, d); }, d))); },
    updateNowIndicator() { this.isNowIndicatorRendered && (this.unrenderNowIndicator(), this.renderNowIndicator(this.initialNowDate.clone().add(new Date() - this.initialNowQueriedMs))); },
    stopNowIndicator() { this.isNowIndicatorRendered && (this.nowIndicatorTimeoutID && (clearTimeout(this.nowIndicatorTimeoutID), this.nowIndicatorTimeoutID = null), this.nowIndicatorIntervalID && (clearTimeout(this.nowIndicatorIntervalID), this.nowIndicatorIntervalID = null), this.unrenderNowIndicator(), this.isNowIndicatorRendered = !1); },
    getNowIndicatorUnit() {},
    renderNowIndicator(a) {},
    unrenderNowIndicator() {},
    updateSize(a) { let b; a && (b = this.queryScroll()), this.updateHeight(a), this.updateWidth(a), this.updateNowIndicator(), a && this.setScroll(b); },
    updateWidth(a) {},
    updateHeight(a) { const b = this.calendar; this.setHeight(b.getSuggestedViewHeight(), b.isHeightAuto()); },
    setHeight(a, b) {},
    computeInitialScroll(a) { return 0; },
    queryScroll() {},
    setScroll(a) {},
    forceScroll(a) { const b = this; this.setScroll(a), setTimeout(() => { b.setScroll(a); }, 0); },
    displayEvents(a) { const b = this.queryScroll(); this.clearEvents(), this.renderEvents(a), this.isEventsRendered = !0, this.setScroll(b), this.triggerEventRender(); },
    clearEvents() { let a; this.isEventsRendered && (a = this.queryScroll(), this.triggerEventUnrender(), this.destroyEvents && this.destroyEvents(), this.unrenderEvents(), this.setScroll(a), this.isEventsRendered = !1); },
    renderEvents(a) {},
    unrenderEvents() {},
    triggerEventRender() { this.renderedEventSegEach(function (a) { this.trigger('eventAfterRender', a.event, a.event, a.el); }), this.trigger('eventAfterAllRender'); },
    triggerEventUnrender() { this.renderedEventSegEach(function (a) { this.trigger('eventDestroy', a.event, a.event, a.el); }); },
    resolveEventEl(b, c) { const d = this.trigger('eventRender', b, b, c); return d === !1 ? c = null : d && d !== !0 && (c = a(d)), c; },
    showEvent(a) { this.renderedEventSegEach((a) => { a.el.css('visibility', ''); }, a); },
    hideEvent(a) {
      this.renderedEventSegEach((a) => {
        a.el.css('visibility', 'hidden');
      }, a);
    },
    renderedEventSegEach(a, b) { let c; const d = this.getEventSegs(); for (c = 0; c < d.length; c++)b && d[c].event._id !== b._id || d[c].el && a.call(this, d[c]); },
    getEventSegs() { return []; },
    isEventDraggable(a) { const b = a.source || {}; return ba(a.startEditable, b.startEditable, this.opt('eventStartEditable'), a.editable, b.editable, this.opt('editable')); },
    reportEventDrop(a, b, c, d, e) { const f = this.calendar; const g = f.mutateEvent(a, b, c); const h = function () { g.undo(), f.reportEventChange(); }; this.triggerEventDrop(a, g.dateDelta, h, d, e), f.reportEventChange(); },
    triggerEventDrop(a, b, c, d, e) { this.trigger('eventDrop', d[0], a, b, c, e, {}); },
    reportExternalDrop(b, c, d, e, f) { let g; let h; const i = b.eventProps; i && (g = a.extend({}, i, c), h = this.calendar.renderEvent(g, b.stick)[0]), this.triggerExternalDrop(h, c, d, e, f); },
    triggerExternalDrop(a, b, c, d, e) { this.trigger('drop', c[0], b.start, d, e), a && this.trigger('eventReceive', null, a); },
    renderDrag(a, b) {},
    unrenderDrag() {},
    isEventResizableFromStart(a) { return this.opt('eventResizableFromStart') && this.isEventResizable(a); },
    isEventResizableFromEnd(a) { return this.isEventResizable(a); },
    isEventResizable(a) { const b = a.source || {}; return ba(a.durationEditable, b.durationEditable, this.opt('eventDurationEditable'), a.editable, b.editable, this.opt('editable')); },
    reportEventResize(a, b, c, d, e) { const f = this.calendar; const g = f.mutateEvent(a, b, c); const h = function () { g.undo(), f.reportEventChange(); }; this.triggerEventResize(a, g.durationDelta, h, d, e), f.reportEventChange(); },
    triggerEventResize(a, b, c, d, e) { this.trigger('eventResize', d[0], a, b, c, e, {}); },
    select(a, b) { this.unselect(b), this.renderSelection(a), this.reportSelection(a, b); },
    renderSelection(a) {},
    reportSelection(a, b) { this.isSelected = !0, this.triggerSelect(a, b); },
    triggerSelect(a, b) { this.trigger('select', null, this.calendar.applyTimezone(a.start), this.calendar.applyTimezone(a.end), b); },
    unselect(a) { this.isSelected && (this.isSelected = !1, this.destroySelection && this.destroySelection(), this.unrenderSelection(), this.trigger('unselect', null, a)); },
    unrenderSelection() {},
    selectEvent(a) { this.selectedEvent && this.selectedEvent === a || (this.unselectEvent(), this.renderedEventSegEach((a) => { a.el.addClass('fc-selected'); }, a), this.selectedEvent = a); },
    unselectEvent() { this.selectedEvent && (this.renderedEventSegEach((a) => { a.el.removeClass('fc-selected'); }, this.selectedEvent), this.selectedEvent = null); },
    isEventSelected(a) { return this.selectedEvent && this.selectedEvent._id === a._id; },
    handleDocumentMousedown(a) { u(a) && this.processUnselect(a); },
    processUnselect(a) { this.processRangeUnselect(a), this.processEventUnselect(a); },
    processRangeUnselect(b) { let c; this.isSelected && this.opt('unselectAuto') && (c = this.opt('unselectCancel'), c && a(b.target).closest(c).length || this.unselect(b)); },
    processEventUnselect(b) { this.selectedEvent && (a(b.target).closest('.fc-selected').length || this.unselectEvent()); },
    triggerDayClick(a, b, c) { this.trigger('dayClick', b, this.calendar.applyTimezone(a.start), c); },
    initHiddenDays() { let b; const c = this.opt('hiddenDays') || []; const d = []; let e = 0; for (this.opt('weekends') === !1 && c.push(0, 6), b = 0; b < 7; b++)(d[b] = a.inArray(b, c) !== -1) || e++; if (!e) throw 'invalid hiddenDays'; this.isHiddenDayHash = d; },
    isHiddenDay(a) { return b.isMoment(a) && (a = a.day()), this.isHiddenDayHash[a]; },
    skipHiddenDays(a, b, c) { const d = a.clone(); for (b = b || 1; this.isHiddenDayHash[(d.day() + (c ? b : 0) + 7) % 7];)d.add(b, 'days'); return d; },
    computeDayRange(a) { let b; const c = a.start.clone().stripTime(); const d = a.end; let e = null; return d && (e = d.clone().stripTime(), b = +d.time(), b && b >= this.nextDayThreshold && e.add(1, 'days')), (!d || c >= e) && (e = c.clone().add(1, 'days')), { start: c, end: e }; },
    isMultiDayEvent(a) { const b = this.computeDayRange(a); return b.end.diff(b.start, 'days') > 1; },
  }); const yb = Wa.Scroller = ya.extend({
    el: null, scrollEl: null, overflowX: null, overflowY: null, constructor(a) { a = a || {}, this.overflowX = a.overflowX || a.overflow || 'auto', this.overflowY = a.overflowY || a.overflow || 'auto'; }, render() { this.el = this.renderEl(), this.applyOverflow(); }, renderEl() { return this.scrollEl = a('<div class="fc-scroller"></div>'); }, clear() { this.setHeight('auto'), this.applyOverflow(); }, destroy() { this.el.remove(); }, applyOverflow() { this.scrollEl.css({ 'overflow-x': this.overflowX, 'overflow-y': this.overflowY }); }, lockOverflow(a) { let b = this.overflowX; let c = this.overflowY; a = a || this.getScrollbarWidths(), b === 'auto' && (b = a.top || a.bottom || this.scrollEl[0].scrollWidth - 1 > this.scrollEl[0].clientWidth ? 'scroll' : 'hidden'), c === 'auto' && (c = a.left || a.right || this.scrollEl[0].scrollHeight - 1 > this.scrollEl[0].clientHeight ? 'scroll' : 'hidden'), this.scrollEl.css({ 'overflow-x': b, 'overflow-y': c }); }, setHeight(a) { this.scrollEl.height(a); }, getScrollTop() { return this.scrollEl.scrollTop(); }, setScrollTop(a) { this.scrollEl.scrollTop(a); }, getClientWidth() { return this.scrollEl[0].clientWidth; }, getClientHeight() { return this.scrollEl[0].clientHeight; }, getScrollbarWidths() { return q(this.scrollEl); },
  }); var zb = Wa.Calendar = ya.extend({
    dirDefaults: null, langDefaults: null, overrides: null, dynamicOverrides: null, options: null, viewSpecCache: null, view: null, header: null, loadingLevel: 0, constructor: Qa, initialize() {}, populateOptionsHash() { let a; let b; let d; let e; a = ba(this.dynamicOverrides.lang, this.overrides.lang), b = Ab[a], b || (a = zb.defaults.lang, b = Ab[a] || {}), d = ba(this.dynamicOverrides.isRTL, this.overrides.isRTL, b.isRTL, zb.defaults.isRTL), e = d ? zb.rtlDefaults : {}, this.dirDefaults = e, this.langDefaults = b, this.options = c([zb.defaults, e, b, this.overrides, this.dynamicOverrides]), Ra(this.options); }, getViewSpec(a) { const b = this.viewSpecCache; return b[a] || (b[a] = this.buildViewSpec(a)); }, getUnitViewSpec(b) { let c; let d; let e; if (a.inArray(b, _a) != -1) for (c = this.header.getViewsWithButtons(), a.each(Wa.views, (a) => { c.push(a); }), d = 0; d < c.length; d++) if (e = this.getViewSpec(c[d]), e && e.singleUnit == b) return e; }, buildViewSpec(a) { for (var d, e, f, g, h = this.overrides.views || {}, i = [], j = [], k = [], l = a; l;)d = Xa[l], e = h[l], l = null, typeof d === 'function' && (d = { 'class': d }), d && (i.unshift(d), j.unshift(d.defaults || {}), f = f || d.duration, l = l || d.type), e && (k.unshift(e), f = f || e.duration, l = l || e.type); return d = W(i), d.type = a, d.class ? (f && (f = b.duration(f), f.valueOf() && (d.duration = f, g = O(f), f.as(g) === 1 && (d.singleUnit = g, k.unshift(h[g] || {})))), d.defaults = c(j), d.overrides = c(k), this.buildViewSpecOptions(d), this.buildViewSpecButtonText(d, a), d) : !1; }, buildViewSpecOptions(a) { a.options = c([zb.defaults, a.defaults, this.dirDefaults, this.langDefaults, this.overrides, a.overrides, this.dynamicOverrides]), Ra(a.options); }, buildViewSpecButtonText(a, b) { function c(c) { const d = c.buttonText || {}; return d[b] || (a.singleUnit ? d[a.singleUnit] : null); }a.buttonTextOverride = c(this.dynamicOverrides) || c(this.overrides) || a.overrides.buttonText, a.buttonTextDefault = c(this.langDefaults) || c(this.dirDefaults) || a.defaults.buttonText || c(zb.defaults) || (a.duration ? this.humanizeDuration(a.duration) : null) || b; }, instantiateView(a) { const b = this.getViewSpec(a); return new b.class(this, a, b.options, b.duration); }, isValidViewType(a) { return Boolean(this.getViewSpec(a)); }, pushLoading() { this.loadingLevel++ || this.trigger('loading', null, !0, this.view); }, popLoading() { --this.loadingLevel || this.trigger('loading', null, !1, this.view); }, buildSelectSpan(a, b) { let c; const d = this.moment(a).stripZone(); return c = b ? this.moment(b).stripZone() : d.hasTime() ? d.clone().add(this.defaultTimedEventDuration) : d.clone().add(this.defaultAllDayEventDuration), { start: d, end: c }; },
  }); zb.mixin(lb), zb.mixin({
    optionHandlers: null, bindOption(a, b) { this.bindOptions([a], b); }, bindOptions(a, b) { let c; const d = { func: b, names: a }; for (c = 0; c < a.length; c++) this.registerOptionHandlerObj(a[c], d); this.triggerOptionHandlerObj(d); }, registerOptionHandlerObj(a, b) { (this.optionHandlers[a] || (this.optionHandlers[a] = [])).push(b); }, triggerOptionHandlers(a) { let b; const c = this.optionHandlers[a] || []; for (b = 0; b < c.length; b++) this.triggerOptionHandlerObj(c[b]); }, triggerOptionHandlerObj(a) { let b; const c = a.names; const d = []; for (b = 0; b < c.length; b++)d.push(this.options[c[b]]); a.func.apply(this, d); },
  }), zb.defaults = {
    titleRangeSeparator: ' – ',
    monthYearFormat: 'MMMM YYYY',
    defaultTimedEventDuration: '02:00:00',
    defaultAllDayEventDuration: { days: 1 },
    forceEventDuration: !1,
    nextDayThreshold: '09:00:00',
    defaultView: 'month',
    aspectRatio: 1.35,
    header: { left: 'title', center: '', right: 'today prev,next' },
    weekends: !0,
    weekNumbers: !1,
    weekNumberTitle: 'W',
    weekNumberCalculation: 'local',
    scrollTime: '06:00:00',
    lazyFetching: !0,
    startParam: 'start',
    endParam: 'end',
    timezoneParam: 'timezone',
    timezone: !1,
    isRTL: !1,
    buttonText: {
      prev: 'prev', next: 'next', prevYear: 'prev year', nextYear: 'next year', year: 'year', today: 'today', month: 'month', week: 'week', day: 'day',
    },
    buttonIcons: {
      prev: 'left-single-arrow', next: 'right-single-arrow', prevYear: 'left-double-arrow', nextYear: 'right-double-arrow',
    },
    theme: !1,
    themeButtonIcons: {
      prev: 'circle-triangle-w', next: 'circle-triangle-e', prevYear: 'seek-prev', nextYear: 'seek-next',
    },
    dragOpacity: 0.75,
    dragRevertDuration: 500,
    dragScroll: !0,
    unselectAuto: !0,
    dropAccept: '*',
    eventOrder: 'title',
    eventLimit: !1,
    eventLimitText: 'more',
    eventLimitClick: 'popover',
    dayPopoverFormat: 'LL',
    handleWindowResize: !0,
    windowResizeDelay: 200,
    longPressDelay: 1e3,
  }, zb.englishDefaults = { dayPopoverFormat: 'dddd, MMMM D' }, zb.rtlDefaults = {
    header: { left: 'next,prev today', center: '', right: 'title' },
    buttonIcons: {
      prev: 'right-single-arrow', next: 'left-single-arrow', prevYear: 'right-double-arrow', nextYear: 'left-double-arrow',
    },
    themeButtonIcons: {
      prev: 'circle-triangle-e', next: 'circle-triangle-w', nextYear: 'seek-prev', prevYear: 'seek-next',
    },
  }; var Ab = Wa.langs = {}; Wa.datepickerLang = function (b, c, d) { const e = Ab[b] || (Ab[b] = {}); e.isRTL = d.isRTL, e.weekNumberTitle = d.weekHeader, a.each(Bb, (a, b) => { e[a] = b(d); }), a.datepicker && (a.datepicker.regional[c] = a.datepicker.regional[b] = d, a.datepicker.regional.en = a.datepicker.regional[''], a.datepicker.setDefaults(d)); }, Wa.lang = function (b, d) { let e; let f; e = Ab[b] || (Ab[b] = {}), d && (e = Ab[b] = c([e, d])), f = Sa(b), a.each(Cb, (a, b) => { e[a] == null && (e[a] = b(f, e)); }), zb.defaults.lang = b; }; var Bb = { buttonText(a) { return { prev: da(a.prevText), next: da(a.nextText), today: da(a.currentText) }; }, monthYearFormat(a) { return a.showMonthAfterYear ? `YYYY[${a.yearSuffix}] MMMM` : `MMMM YYYY[${a.yearSuffix}]`; } }; var Cb = {
    dayOfMonthFormat(a, b) { let c = a.longDateFormat('l'); return c = c.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g, ''), b.isRTL ? c += ' ddd' : c = `ddd ${c}`, c; }, mediumTimeFormat(a) { return a.longDateFormat('LT').replace(/\s*a$/i, 'a'); }, smallTimeFormat(a) { return a.longDateFormat('LT').replace(':mm', '(:mm)').replace(/(\Wmm)$/, '($1)').replace(/\s*a$/i, 'a'); }, extraSmallTimeFormat(a) { return a.longDateFormat('LT').replace(':mm', '(:mm)').replace(/(\Wmm)$/, '($1)').replace(/\s*a$/i, 't'); }, hourFormat(a) { return a.longDateFormat('LT').replace(':mm', '').replace(/(\Wmm)$/, '').replace(/\s*a$/i, 'a'); }, noMeridiemTimeFormat(a) { return a.longDateFormat('LT').replace(/\s*a$/i, ''); },
  }; var Db = { smallDayDateFormat(a) { return a.isRTL ? 'D dd' : 'dd D'; }, weekFormat(a) { return a.isRTL ? `w[ ${a.weekNumberTitle}]` : `[${a.weekNumberTitle} ]w`; }, smallWeekFormat(a) { return a.isRTL ? `w[${a.weekNumberTitle}]` : `[${a.weekNumberTitle}]w`; } }; Wa.lang('en', zb.englishDefaults), Wa.sourceNormalizers = [], Wa.sourceFetchers = []; var Eb = { dataType: 'json', cache: !1 }; var Fb = 1; zb.prototype.normalizeEvent = function (a) {}, zb.prototype.getPeerEvents = function (a, b) { let c; let d; const e = this.getEventCache(); const f = []; for (c = 0; c < e.length; c++)d = e[c], b && b._id === d._id || f.push(d); return f; }; const Gb = Wa.BasicView = xb.extend({
    scroller: null, dayGridClass: vb, dayGrid: null, dayNumbersVisible: !1, weekNumbersVisible: !1, weekNumberWidth: null, headContainerEl: null, headRowEl: null, initialize() { this.dayGrid = this.instantiateDayGrid(), this.scroller = new yb({ overflowX: 'hidden', overflowY: 'auto' }); }, instantiateDayGrid() { const a = this.dayGridClass.extend(Hb); return new a(this); }, setRange(a) { xb.prototype.setRange.call(this, a), this.dayGrid.breakOnWeeks = /year|month|week/.test(this.intervalUnit), this.dayGrid.setRange(a); }, computeRange(a) { const b = xb.prototype.computeRange.call(this, a); return /year|month/.test(b.intervalUnit) && (b.start.startOf('week'), b.start = this.skipHiddenDays(b.start), b.end.weekday() && (b.end.add(1, 'week').startOf('week'), b.end = this.skipHiddenDays(b.end, -1, !0))), b; }, renderDates() { this.dayNumbersVisible = this.dayGrid.rowCnt > 1, this.weekNumbersVisible = this.opt('weekNumbers'), this.dayGrid.numbersVisible = this.dayNumbersVisible || this.weekNumbersVisible, this.el.addClass('fc-basic-view').html(this.renderSkeletonHtml()), this.renderHead(), this.scroller.render(); const b = this.scroller.el.addClass('fc-day-grid-container'); const c = a('<div class="fc-day-grid" />').appendTo(b); this.el.find('.fc-body > tr > td').append(b), this.dayGrid.setElement(c), this.dayGrid.renderDates(this.hasRigidRows()); }, renderHead() { this.headContainerEl = this.el.find('.fc-head-container').html(this.dayGrid.renderHeadHtml()), this.headRowEl = this.headContainerEl.find('.fc-row'); }, unrenderDates() { this.dayGrid.unrenderDates(), this.dayGrid.removeElement(), this.scroller.destroy(); }, renderBusinessHours() { this.dayGrid.renderBusinessHours(); }, unrenderBusinessHours() { this.dayGrid.unrenderBusinessHours(); }, renderSkeletonHtml() { return `<table><thead class="fc-head"><tr><td class="fc-head-container ${this.widgetHeaderClass}"></td></tr></thead><tbody class="fc-body"><tr><td class="${this.widgetContentClass}"></td></tr></tbody></table>`; }, weekNumberStyleAttr() { return this.weekNumberWidth !== null ? `style="width:${this.weekNumberWidth}px"` : ''; }, hasRigidRows() { const a = this.opt('eventLimit'); return a && typeof a !== 'number'; }, updateWidth() { this.weekNumbersVisible && (this.weekNumberWidth = k(this.el.find('.fc-week-number'))); }, setHeight(a, b) { let c; let d; const g = this.opt('eventLimit'); this.scroller.clear(), f(this.headRowEl), this.dayGrid.removeSegPopover(), g && typeof g === 'number' && this.dayGrid.limitRows(g), c = this.computeScrollerHeight(a), this.setGridHeight(c, b), g && typeof g !== 'number' && this.dayGrid.limitRows(g), b || (this.scroller.setHeight(c), d = this.scroller.getScrollbarWidths(), (d.left || d.right) && (e(this.headRowEl, d), c = this.computeScrollerHeight(a), this.scroller.setHeight(c)), this.scroller.lockOverflow(d)); }, computeScrollerHeight(a) { return a - l(this.el, this.scroller.el); }, setGridHeight(a, b) { b ? j(this.dayGrid.rowEls) : i(this.dayGrid.rowEls, a, !0); }, queryScroll() { return this.scroller.getScrollTop(); }, setScroll(a) { this.scroller.setScrollTop(a); }, prepareHits() { this.dayGrid.prepareHits(); }, releaseHits() { this.dayGrid.releaseHits(); }, queryHit(a, b) { return this.dayGrid.queryHit(a, b); }, getHitSpan(a) { return this.dayGrid.getHitSpan(a); }, getHitEl(a) { return this.dayGrid.getHitEl(a); }, renderEvents(a) { this.dayGrid.renderEvents(a), this.updateHeight(); }, getEventSegs() { return this.dayGrid.getEventSegs(); }, unrenderEvents() { this.dayGrid.unrenderEvents(); }, renderDrag(a, b) { return this.dayGrid.renderDrag(a, b); }, unrenderDrag() { this.dayGrid.unrenderDrag(); }, renderSelection(a) { this.dayGrid.renderSelection(a); }, unrenderSelection() { this.dayGrid.unrenderSelection(); },
  }); var Hb = {
    renderHeadIntroHtml() { const a = this.view; return a.weekNumbersVisible ? `<th class="fc-week-number ${a.widgetHeaderClass}" ${a.weekNumberStyleAttr()}><span>${ca(a.opt('weekNumberTitle'))}</span></th>` : ''; }, renderNumberIntroHtml(a) { const b = this.view; return b.weekNumbersVisible ? `<td class="fc-week-number" ${b.weekNumberStyleAttr()}><span>${this.getCellDate(a, 0).format('w')}</span></td>` : ''; }, renderBgIntroHtml() { const a = this.view; return a.weekNumbersVisible ? `<td class="fc-week-number ${a.widgetContentClass}" ${a.weekNumberStyleAttr()}></td>` : ''; }, renderIntroHtml() { const a = this.view; return a.weekNumbersVisible ? `<td class="fc-week-number" ${a.weekNumberStyleAttr()}></td>` : ''; },
  }; const Ib = Wa.MonthView = Gb.extend({ computeRange(a) { let b; const c = Gb.prototype.computeRange.call(this, a); return this.isFixedWeeks() && (b = Math.ceil(c.end.diff(c.start, 'weeks', !0)), c.end.add(6 - b, 'weeks')), c; }, setGridHeight(a, b) { b = b || this.opt('weekMode') === 'variable', b && (a *= this.rowCnt / 6), i(this.dayGrid.rowEls, a, !b); }, isFixedWeeks() { const a = this.opt('weekMode'); return a ? a === 'fixed' : this.opt('fixedWeekCount'); } }); Xa.basic = { 'class': Gb }, Xa.basicDay = { type: 'basic', duration: { days: 1 } }, Xa.basicWeek = { type: 'basic', duration: { weeks: 1 } }, Xa.month = { 'class': Ib, duration: { months: 1 }, defaults: { fixedWeekCount: !0 } }; const Jb = Wa.AgendaView = xb.extend({
    scroller: null, timeGridClass: wb, timeGrid: null, dayGridClass: vb, dayGrid: null, axisWidth: null, headContainerEl: null, noScrollRowEls: null, bottomRuleEl: null, initialize() { this.timeGrid = this.instantiateTimeGrid(), this.opt('allDaySlot') && (this.dayGrid = this.instantiateDayGrid()), this.scroller = new yb({ overflowX: 'hidden', overflowY: 'auto' }); }, instantiateTimeGrid() { const a = this.timeGridClass.extend(Kb); return new a(this); }, instantiateDayGrid() { const a = this.dayGridClass.extend(Lb); return new a(this); }, setRange(a) { xb.prototype.setRange.call(this, a), this.timeGrid.setRange(a), this.dayGrid && this.dayGrid.setRange(a); }, renderDates() { this.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml()), this.renderHead(), this.scroller.render(); const b = this.scroller.el.addClass('fc-time-grid-container'); const c = a('<div class="fc-time-grid" />').appendTo(b); this.el.find('.fc-body > tr > td').append(b), this.timeGrid.setElement(c), this.timeGrid.renderDates(), this.bottomRuleEl = a(`<hr class="fc-divider ${this.widgetHeaderClass}"/>`).appendTo(this.timeGrid.el), this.dayGrid && (this.dayGrid.setElement(this.el.find('.fc-day-grid')), this.dayGrid.renderDates(), this.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight()), this.noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)'); }, renderHead() { this.headContainerEl = this.el.find('.fc-head-container').html(this.timeGrid.renderHeadHtml()); }, unrenderDates() { this.timeGrid.unrenderDates(), this.timeGrid.removeElement(), this.dayGrid && (this.dayGrid.unrenderDates(), this.dayGrid.removeElement()), this.scroller.destroy(); }, renderSkeletonHtml() { return `<table><thead class="fc-head"><tr><td class="fc-head-container ${this.widgetHeaderClass}"></td></tr></thead><tbody class="fc-body"><tr><td class="${this.widgetContentClass}">${this.dayGrid ? `<div class="fc-day-grid"/><hr class="fc-divider ${this.widgetHeaderClass}"/>` : ''}</td></tr></tbody></table>`; }, axisStyleAttr() { return this.axisWidth !== null ? `style="width:${this.axisWidth}px"` : ''; }, renderBusinessHours() { this.timeGrid.renderBusinessHours(), this.dayGrid && this.dayGrid.renderBusinessHours(); }, unrenderBusinessHours() { this.timeGrid.unrenderBusinessHours(), this.dayGrid && this.dayGrid.unrenderBusinessHours(); }, getNowIndicatorUnit() { return this.timeGrid.getNowIndicatorUnit(); }, renderNowIndicator(a) { this.timeGrid.renderNowIndicator(a); }, unrenderNowIndicator() { this.timeGrid.unrenderNowIndicator(); }, updateSize(a) { this.timeGrid.updateSize(a), xb.prototype.updateSize.call(this, a); }, updateWidth() { this.axisWidth = k(this.el.find('.fc-axis')); }, setHeight(a, b) { let c; let d; let g; this.bottomRuleEl.hide(), this.scroller.clear(), f(this.noScrollRowEls), this.dayGrid && (this.dayGrid.removeSegPopover(), c = this.opt('eventLimit'), c && typeof c !== 'number' && (c = Mb), c && this.dayGrid.limitRows(c)), b || (d = this.computeScrollerHeight(a), this.scroller.setHeight(d), g = this.scroller.getScrollbarWidths(), (g.left || g.right) && (e(this.noScrollRowEls, g), d = this.computeScrollerHeight(a), this.scroller.setHeight(d)), this.scroller.lockOverflow(g), this.timeGrid.getTotalSlatHeight() < d && this.bottomRuleEl.show()); }, computeScrollerHeight(a) { return a - l(this.el, this.scroller.el); }, computeInitialScroll() { const a = b.duration(this.opt('scrollTime')); let c = this.timeGrid.computeTimeTop(a); return c = Math.ceil(c), c && c++, c; }, queryScroll() { return this.scroller.getScrollTop(); }, setScroll(a) { this.scroller.setScrollTop(a); }, prepareHits() { this.timeGrid.prepareHits(), this.dayGrid && this.dayGrid.prepareHits(); }, releaseHits() { this.timeGrid.releaseHits(), this.dayGrid && this.dayGrid.releaseHits(); }, queryHit(a, b) { let c = this.timeGrid.queryHit(a, b); return !c && this.dayGrid && (c = this.dayGrid.queryHit(a, b)), c; }, getHitSpan(a) { return a.component.getHitSpan(a); }, getHitEl(a) { return a.component.getHitEl(a); }, renderEvents(a) { let b; let c; const d = []; const e = []; let f = []; for (c = 0; c < a.length; c++)a[c].allDay ? d.push(a[c]) : e.push(a[c]); b = this.timeGrid.renderEvents(e), this.dayGrid && (f = this.dayGrid.renderEvents(d)), this.updateHeight(); }, getEventSegs() { return this.timeGrid.getEventSegs().concat(this.dayGrid ? this.dayGrid.getEventSegs() : []); }, unrenderEvents() { this.timeGrid.unrenderEvents(), this.dayGrid && this.dayGrid.unrenderEvents(); }, renderDrag(a, b) { return a.start.hasTime() ? this.timeGrid.renderDrag(a, b) : this.dayGrid ? this.dayGrid.renderDrag(a, b) : void 0; }, unrenderDrag() { this.timeGrid.unrenderDrag(), this.dayGrid && this.dayGrid.unrenderDrag(); }, renderSelection(a) { a.start.hasTime() || a.end.hasTime() ? this.timeGrid.renderSelection(a) : this.dayGrid && this.dayGrid.renderSelection(a); }, unrenderSelection() { this.timeGrid.unrenderSelection(), this.dayGrid && this.dayGrid.unrenderSelection(); },
  }); var Kb = { renderHeadIntroHtml() { let a; const b = this.view; return b.opt('weekNumbers') ? (a = this.start.format(b.opt('smallWeekFormat')), `<th class="fc-axis fc-week-number ${b.widgetHeaderClass}" ${b.axisStyleAttr()}><span>${ca(a)}</span></th>`) : `<th class="fc-axis ${b.widgetHeaderClass}" ${b.axisStyleAttr()}></th>`; }, renderBgIntroHtml() { const a = this.view; return `<td class="fc-axis ${a.widgetContentClass}" ${a.axisStyleAttr()}></td>`; }, renderIntroHtml() { const a = this.view; return `<td class="fc-axis" ${a.axisStyleAttr()}></td>`; } }; var Lb = { renderBgIntroHtml() { const a = this.view; return `<td class="fc-axis ${a.widgetContentClass}" ${a.axisStyleAttr()}><span>${a.opt('allDayHtml') || ca(a.opt('allDayText'))}</span></td>`; }, renderIntroHtml() { const a = this.view; return `<td class="fc-axis" ${a.axisStyleAttr()}></td>`; } }; var Mb = 5; var Nb = [{ hours: 1 }, { minutes: 30 }, { minutes: 15 }, { seconds: 30 }, { seconds: 15 }]; return Xa.agenda = {
    'class': Jb,
    defaults: {
      allDaySlot: !0, allDayText: 'all-day', slotDuration: '00:30:00', minTime: '00:00:00', maxTime: '24:00:00', slotEventOverlap: !0,
    },
  }, Xa.agendaDay = { type: 'agenda', duration: { days: 1 } }, Xa.agendaWeek = { type: 'agenda', duration: { weeks: 1 } }, Wa;
}));
