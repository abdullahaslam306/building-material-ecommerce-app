!(function (a) {
  function b(a) { this.owner = a; } function c(a, b) { if (Object.create)b.prototype = Object.create(a.prototype); else { const c = function () {}; c.prototype = a.prototype, b.prototype = new c(); } return b.prototype.constructor = b, b; } function d(a) { const b = this.internal = new e(this); b.loadConfig(a), b.beforeInit(a), b.init(), b.afterInit(a), (function c(a, b, d) { Object.keys(a).forEach((e) => { b[e] = a[e].bind(d), Object.keys(a[e]).length > 0 && c(a[e], b[e], d); }); }(h, this, this)); } function e(b) { const c = this; c.d3 = a.d3 ? a.d3 : typeof require !== 'undefined' ? require('d3') : void 0, c.api = b, c.config = c.getDefaultConfig(), c.data = {}, c.cache = {}, c.axes = {}; } function f(a) { b.call(this, a); } function g(a, b) {
    function c(a, b) { a.attr('transform', (a) => `translate(${Math.ceil(b(a) + u)}, 0)`); } function d(a, b) { a.attr('transform', (a) => `translate(0,${Math.ceil(b(a))})`); } function e(a) { const b = a[0]; const c = a[a.length - 1]; return c > b ? [b, c] : [c, b]; } function f(a) { let b; let c; const d = []; if (a.ticks) return a.ticks.apply(a, n); for (c = a.domain(), b = Math.ceil(c[0]); b < c[1]; b++)d.push(b); return d.length > 0 && d[0] > 0 && d.unshift(d[0] - (d[1] - d[0])), d; } function g() { let a; const c = p.copy(); return b.isCategory && (a = p.domain(), c.domain([a[0], a[1] - 1])), c; } function h(a) { const b = m ? m(a) : a; return typeof b !== 'undefined' ? b : ''; } function i(a) { if (A) return A; const b = { h: 11.5, w: 5.5 }; return a.select('text').text(h).each(function (a) { const c = this.getBoundingClientRect(); const d = h(a); const e = c.height; const f = d ? c.width / d.length : void 0; e && f && (b.h = e, b.w = f); }).text(''), A = b, b; } function j(c) { return b.withoutTransition ? c : a.transition(c); } function k(m) { m.each(function () { function m(a, c) { function d(a, b) { f = void 0; for (let h = 1; h < b.length; h++) if (b.charAt(h) === ' ' && (f = h), e = b.substr(0, h + 1), g = U.w * e.length, g > c) return d(a.concat(b.substr(0, f || h)), b.slice(f ? f + 1 : h)); return a.concat(b); } let e; let f; let g; const i = h(a); const j = []; return Object.prototype.toString.call(i) === '[object Array]' ? i : ((!c || c <= 0) && (c = X ? 95 : b.isCategory ? Math.ceil(F(G[1]) - F(G[0])) - 12 : 110), d(j, `${i}`)); } function n(a, b) { let c = U.h; return b === 0 && (c = q === 'left' || q === 'right' ? -((V[a.index] - 1) * (U.h / 2) - 3) : '.71em'), c; } function v(a) { const b = p(a) + (o ? 0 : u); return L[0] < b && b < L[1] ? r : 0; } function w(a) { return a ? a > 0 ? 'start' : 'end' : 'middle'; } function x(a) { return a ? `rotate(${a})` : ''; } function y(a) { return a ? 8 * Math.sin(Math.PI * (a / 180)) : 0; } function z(a) { return a ? 11.5 - 2.5 * (a / 15) * (a > 0 ? 1 : -1) : W; } let A; let B; let C; const D = k.g = a.select(this); let E = this.__chart__ || p; var F = this.__chart__ = g(); var G = t || f(F); const H = D.selectAll('.tick').data(G, F); const I = H.enter().insert('g', '.domain').attr('class', 'tick').style('opacity', 1e-6); const J = H.exit().remove(); const K = j(H).style('opacity', 1); var L = p.rangeExtent ? p.rangeExtent() : e(p.range()); const M = D.selectAll('.domain').data([0]); const N = (M.enter().append('path').attr('class', 'domain'), j(M)); I.append('line'), I.append('text'); const O = I.select('line'); const P = K.select('line'); const Q = I.select('text'); const R = K.select('text'); b.isCategory ? (u = Math.ceil((F(1) - F(0)) / 2), B = o ? 0 : u, C = o ? u : 0) : u = B = 0; let S; let T; var U = i(D.select('.tick')); var V = []; var W = Math.max(r, 0) + s; var X = q === 'left' || q === 'right'; S = H.select('text'), T = S.selectAll('tspan').data((a, c) => { const d = b.tickMultiline ? m(a, b.tickWidth) : [].concat(h(a)); return V[c] = d.length, d.map((a) => ({ index: c, splitted: a })); }), T.enter().append('tspan'), T.exit().remove(), T.text((a) => a.splitted); const Y = b.tickTextRotate; switch (q) { case 'bottom': A = c, O.attr('y2', r), Q.attr('y', W), P.attr('x1', B).attr('x2', B).attr('y2', v), R.attr('x', 0).attr('y', z(Y)).style('text-anchor', w(Y)).attr('transform', x(Y)), T.attr('x', 0).attr('dy', n).attr('dx', y(Y)), N.attr('d', `M${L[0]},${l}V0H${L[1]}V${l}`); break; case 'top': A = c, O.attr('y2', -r), Q.attr('y', -W), P.attr('x2', 0).attr('y2', -r), R.attr('x', 0).attr('y', -W), S.style('text-anchor', 'middle'), T.attr('x', 0).attr('dy', '0em'), N.attr('d', `M${L[0]},${-l}V0H${L[1]}V${-l}`); break; case 'left': A = d, O.attr('x2', -r), Q.attr('x', -W), P.attr('x2', -r).attr('y1', C).attr('y2', C), R.attr('x', -W).attr('y', u), S.style('text-anchor', 'end'), T.attr('x', -W).attr('dy', n), N.attr('d', `M${-l},${L[0]}H0V${L[1]}H${-l}`); break; case 'right': A = d, O.attr('x2', r), Q.attr('x', W), P.attr('x2', r).attr('y2', 0), R.attr('x', W).attr('y', 0), S.style('text-anchor', 'start'), T.attr('x', W).attr('dy', n), N.attr('d', `M${l},${L[0]}H0V${L[1]}H${l}`); } if (F.rangeBand) { const Z = F; const $ = Z.rangeBand() / 2; E = F = function (a) { return Z(a) + $; }; } else E.rangeBand ? E = F : J.call(A, F); I.call(A, E), K.call(A, F); }); } let l; let m; let n; let o; var p = a.scale.linear(); var q = 'bottom'; var r = 6; var s = 3; var t = null; var u = 0; let v = !0; return b = b || {}, l = b.withOuterTick ? 6 : 0, k.scale = function (a) { return arguments.length ? (p = a, k) : p; }, k.orient = function (a) {
      return arguments.length ? (q = a in {
        top: 1, right: 1, bottom: 1, left: 1,
      } ? `${a}` : 'bottom', k) : q;
    }, k.tickFormat = function (a) { return arguments.length ? (m = a, k) : m; }, k.tickCentered = function (a) { return arguments.length ? (o = a, k) : o; }, k.tickOffset = function () { return u; }, k.tickInterval = function () { let a; let c; return b.isCategory ? a = 2 * u : (c = k.g.select('path.domain').node().getTotalLength() - 2 * l, a = c / k.g.selectAll('line').size()), a === 1 / 0 ? 0 : a; }, k.ticks = function () { return arguments.length ? (n = arguments, k) : n; }, k.tickCulling = function (a) { return arguments.length ? (v = a, k) : v; }, k.tickValues = function (a) { if (typeof a === 'function')t = function () { return a(p.domain()); }; else { if (!arguments.length) return t; t = a; } return k; }, k;
  } let h; let i; let j; const k = { version: '0.4.11' }; k.generate = function (a) { return new d(a); }, k.chart = { fn: d.prototype, internal: { fn: e.prototype, axis: { fn: f.prototype } } }, h = k.chart.fn, i = k.chart.internal.fn, j = k.chart.internal.axis.fn, i.beforeInit = function () {}, i.afterInit = function () {}, i.init = function () { const a = this; const b = a.config; if (a.initParams(), b.data_url)a.convertUrlToData(b.data_url, b.data_mimeType, b.data_headers, b.data_keys, a.initWithData); else if (b.data_json)a.initWithData(a.convertJsonToData(b.data_json, b.data_keys)); else if (b.data_rows)a.initWithData(a.convertRowsToData(b.data_rows)); else { if (!b.data_columns) throw Error('url or json or rows or columns is required.'); a.initWithData(a.convertColumnsToData(b.data_columns)); } }, i.initParams = function () { const a = this; const b = a.d3; const c = a.config; a.clipId = `c3-${+new Date()}-clip`, a.clipIdForXAxis = `${a.clipId}-xaxis`, a.clipIdForYAxis = `${a.clipId}-yaxis`, a.clipIdForGrid = `${a.clipId}-grid`, a.clipIdForSubchart = `${a.clipId}-subchart`, a.clipPath = a.getClipPath(a.clipId), a.clipPathForXAxis = a.getClipPath(a.clipIdForXAxis), a.clipPathForYAxis = a.getClipPath(a.clipIdForYAxis), a.clipPathForGrid = a.getClipPath(a.clipIdForGrid), a.clipPathForSubchart = a.getClipPath(a.clipIdForSubchart), a.dragStart = null, a.dragging = !1, a.flowing = !1, a.cancelClick = !1, a.mouseover = !1, a.transiting = !1, a.color = a.generateColor(), a.levelColor = a.generateLevelColor(), a.dataTimeFormat = c.data_xLocaltime ? b.time.format : b.time.format.utc, a.axisTimeFormat = c.axis_x_localtime ? b.time.format : b.time.format.utc, a.defaultAxisTimeFormat = a.axisTimeFormat.multi([['.%L', function (a) { return a.getMilliseconds(); }], [':%S', function (a) { return a.getSeconds(); }], ['%I:%M', function (a) { return a.getMinutes(); }], ['%I %p', function (a) { return a.getHours(); }], ['%-m/%-d', function (a) { return a.getDay() && a.getDate() !== 1; }], ['%-m/%-d', function (a) { return a.getDate() !== 1; }], ['%-m/%-d', function (a) { return a.getMonth(); }], ['%Y/%-m/%-d', function () { return !0; }]]), a.hiddenTargetIds = [], a.hiddenLegendIds = [], a.focusedTargetIds = [], a.defocusedTargetIds = [], a.xOrient = c.axis_rotated ? 'left' : 'bottom', a.yOrient = c.axis_rotated ? c.axis_y_inner ? 'top' : 'bottom' : c.axis_y_inner ? 'right' : 'left', a.y2Orient = c.axis_rotated ? c.axis_y2_inner ? 'bottom' : 'top' : c.axis_y2_inner ? 'left' : 'right', a.subXOrient = c.axis_rotated ? 'left' : 'bottom', a.isLegendRight = c.legend_position === 'right', a.isLegendInset = c.legend_position === 'inset', a.isLegendTop = c.legend_inset_anchor === 'top-left' || c.legend_inset_anchor === 'top-right', a.isLegendLeft = c.legend_inset_anchor === 'top-left' || c.legend_inset_anchor === 'bottom-left', a.legendStep = 0, a.legendItemWidth = 0, a.legendItemHeight = 0, a.currentMaxTickWidths = { x: 0, y: 0, y2: 0 }, a.rotated_padding_left = 30, a.rotated_padding_right = c.axis_rotated && !c.axis_x_show ? 0 : 30, a.rotated_padding_top = 5, a.withoutFadeIn = {}, a.intervalForObserveInserted = void 0, a.axes.subx = b.selectAll([]); }, i.initChartElements = function () { this.initBar && this.initBar(), this.initLine && this.initLine(), this.initArc && this.initArc(), this.initGauge && this.initGauge(), this.initText && this.initText(); }, i.initWithData = function (a) {
    let b; let c; const d = this; const e = d.d3; const g = d.config; let h = !0; d.axis = new f(d), d.initPie && d.initPie(), d.initBrush && d.initBrush(), d.initZoom && d.initZoom(), g.bindto ? typeof g.bindto.node === 'function' ? d.selectChart = g.bindto : d.selectChart = e.select(g.bindto) : d.selectChart = e.selectAll([]), d.selectChart.empty() && (d.selectChart = e.select(document.createElement('div')).style('opacity', 0), d.observeInserted(d.selectChart), h = !1), d.selectChart.html('').classed('c3', !0), d.data.xs = {}, d.data.targets = d.convertDataToTargets(a), g.data_filter && (d.data.targets = d.data.targets.filter(g.data_filter)), g.data_hide && d.addHiddenTargetIds(g.data_hide === !0 ? d.mapToIds(d.data.targets) : g.data_hide), g.legend_hide && d.addHiddenLegendIds(g.legend_hide === !0 ? d.mapToIds(d.data.targets) : g.legend_hide), d.hasType('gauge') && (g.legend_show = !1), d.updateSizes(), d.updateScales(), d.x.domain(e.extent(d.getXDomain(d.data.targets))), d.y.domain(d.getYDomain(d.data.targets, 'y')), d.y2.domain(d.getYDomain(d.data.targets, 'y2')), d.subX.domain(d.x.domain()), d.subY.domain(d.y.domain()), d.subY2.domain(d.y2.domain()), d.orgXDomain = d.x.domain(), d.brush && d.brush.scale(d.subX), g.zoom_enabled && d.zoom.scale(d.x), d.svg = d.selectChart.append('svg').style('overflow', 'hidden').on('mouseenter', () => g.onmouseover.call(d)).on('mouseleave', () => g.onmouseout.call(d)), d.config.svg_classname && d.svg.attr('class', d.config.svg_classname), b = d.svg.append('defs'), d.clipChart = d.appendClip(b, d.clipId), d.clipXAxis = d.appendClip(b, d.clipIdForXAxis), d.clipYAxis = d.appendClip(b, d.clipIdForYAxis), d.clipGrid = d.appendClip(b, d.clipIdForGrid), d.clipSubchart = d.appendClip(b, d.clipIdForSubchart), d.updateSvgSize(), c = d.main = d.svg.append('g').attr('transform', d.getTranslate('main')), d.initSubchart && d.initSubchart(), d.initTooltip && d.initTooltip(), d.initLegend && d.initLegend(), d.initTitle && d.initTitle(), c.append('text').attr('class', `${l.text} ${l.empty}`).attr('text-anchor', 'middle').attr('dominant-baseline', 'middle'), d.initRegion(), d.initGrid(), c.append('g').attr('clip-path', d.clipPath).attr('class', l.chart), g.grid_lines_front && d.initGridLines(), d.initEventRect(), d.initChartElements(), c.insert('rect', g.zoom_privileged ? null : `g.${l.regions}`).attr('class', l.zoomRect).attr('width', d.width).attr('height', d.height)
      .style('opacity', 0)
      .on('dblclick.zoom', null), g.axis_x_extent && d.brush.extent(d.getDefaultExtent()), d.axis.init(), d.updateTargets(d.data.targets), h && (d.updateDimension(), d.config.oninit.call(d), d.redraw({
      withTransition: !1, withTransform: !0, withUpdateXDomain: !0, withUpdateOrgXDomain: !0, withTransitionForAxis: !1,
    })), d.bindResize(), d.api.element = d.selectChart.node();
  }, i.smoothLines = function (a, b) {
    const c = this; b === 'grid' && a.each(function () {
      const a = c.d3.select(this); const b = a.attr('x1'); const d = a.attr('x2'); const e = a.attr('y1'); const f = a.attr('y2'); a.attr({
        x1: Math.ceil(b), x2: Math.ceil(d), y1: Math.ceil(e), y2: Math.ceil(f),
      });
    });
  }, i.updateSizes = function () {
    const a = this; const b = a.config; const c = a.legend ? a.getLegendHeight() : 0; const d = a.legend ? a.getLegendWidth() : 0; const e = a.isLegendRight || a.isLegendInset ? 0 : c; const f = a.hasArcType(); const g = b.axis_rotated || f ? 0 : a.getHorizontalAxisHeight('x'); const h = b.subchart_show && !f ? b.subchart_size_height + g : 0; a.currentWidth = a.getCurrentWidth(), a.currentHeight = a.getCurrentHeight(), a.margin = b.axis_rotated ? {
      top: a.getHorizontalAxisHeight('y2') + a.getCurrentPaddingTop(), right: f ? 0 : a.getCurrentPaddingRight(), bottom: a.getHorizontalAxisHeight('y') + e + a.getCurrentPaddingBottom(), left: h + (f ? 0 : a.getCurrentPaddingLeft()),
    } : {
      top: 4 + a.getCurrentPaddingTop(), right: f ? 0 : a.getCurrentPaddingRight(), bottom: g + h + e + a.getCurrentPaddingBottom(), left: f ? 0 : a.getCurrentPaddingLeft(),
    }, a.margin2 = b.axis_rotated ? {
      top: a.margin.top, right: NaN, bottom: 20 + e, left: a.rotated_padding_left,
    } : {
      top: a.currentHeight - h - e, right: NaN, bottom: g + e, left: a.margin.left,
    }, a.margin3 = {
      top: 0, right: NaN, bottom: 0, left: 0,
    }, a.updateSizeForLegend && a.updateSizeForLegend(c, d), a.width = a.currentWidth - a.margin.left - a.margin.right, a.height = a.currentHeight - a.margin.top - a.margin.bottom, a.width < 0 && (a.width = 0), a.height < 0 && (a.height = 0), a.width2 = b.axis_rotated ? a.margin.left - a.rotated_padding_left - a.rotated_padding_right : a.width, a.height2 = b.axis_rotated ? a.height : a.currentHeight - a.margin2.top - a.margin2.bottom, a.width2 < 0 && (a.width2 = 0), a.height2 < 0 && (a.height2 = 0), a.arcWidth = a.width - (a.isLegendRight ? d + 10 : 0), a.arcHeight = a.height - (a.isLegendRight ? 0 : 10), a.hasType('gauge') && !b.gauge_fullCircle && (a.arcHeight += a.height - a.getGaugeLabelHeight()), a.updateRadius && a.updateRadius(), a.isLegendRight && f && (a.margin3.left = a.arcWidth / 2 + 1.1 * a.radiusExpanded);
  }, i.updateTargets = function (a) { const b = this; b.updateTargetsForText(a), b.updateTargetsForBar(a), b.updateTargetsForLine(a), b.hasArcType() && b.updateTargetsForArc && b.updateTargetsForArc(a), b.updateTargetsForSubchart && b.updateTargetsForSubchart(a), b.showTargets(); }, i.showTargets = function () {
    const a = this; a.svg.selectAll(`.${l.target}`).filter((b) => a.isTargetToShow(b.id)).transition().duration(a.config.transition_duration)
      .style('opacity', 1);
  }, i.redraw = function (a, b) {
    let c; let d; let e; let f; let g; let h; let i; let j; let k; let m; let n; let o; let p; let q; let r; let s; let t; let u; let v; let x; let y; let z; let A; let B; let C; let D; let E; let F; let G; const H = this; const I = H.main; const J = H.d3; const K = H.config; const L = H.getShapeIndices(H.isAreaType); const M = H.getShapeIndices(H.isBarType); const N = H.getShapeIndices(H.isLineType); const O = H.hasArcType(); const P = H.filterTargetsToShow(H.data.targets); const Q = H.xv.bind(H); if (a = a || {}, c = w(a, 'withY', !0), d = w(a, 'withSubchart', !0), e = w(a, 'withTransition', !0), h = w(a, 'withTransform', !1), i = w(a, 'withUpdateXDomain', !1), j = w(a, 'withUpdateOrgXDomain', !1), k = w(a, 'withTrimXDomain', !0), p = w(a, 'withUpdateXAxis', i), m = w(a, 'withLegend', !1), n = w(a, 'withEventRect', !0), o = w(a, 'withDimension', !0), f = w(a, 'withTransitionForExit', e), g = w(a, 'withTransitionForAxis', e), v = e ? K.transition_duration : 0, x = f ? v : 0, y = g ? v : 0, b = b || H.axis.generateTransitions(y), m && K.legend_show ? H.updateLegend(H.mapToIds(H.data.targets), a, b) : o && H.updateDimension(!0), H.isCategorized() && P.length === 0 && H.x.domain([0, H.axes.x.selectAll('.tick').size()]), P.length ? (H.updateXDomain(P, i, j, k), K.axis_x_tick_values || (B = H.axis.updateXAxisTickValues(P))) : (H.xAxis.tickValues([]), H.subXAxis.tickValues([])), K.zoom_rescale && !a.flow && (E = H.x.orgDomain()), H.y.domain(H.getYDomain(P, 'y', E)), H.y2.domain(H.getYDomain(P, 'y2', E)), !K.axis_y_tick_values && K.axis_y_tick_count && H.yAxis.tickValues(H.axis.generateTickValues(H.y.domain(), K.axis_y_tick_count)), !K.axis_y2_tick_values && K.axis_y2_tick_count && H.y2Axis.tickValues(H.axis.generateTickValues(H.y2.domain(), K.axis_y2_tick_count)), H.axis.redraw(b, O), H.axis.updateLabels(e), (i || p) && P.length) if (K.axis_x_tick_culling && B) { for (C = 1; C < B.length; C++) if (B.length / C < K.axis_x_tick_culling_max) { D = C; break; }H.svg.selectAll(`.${l.axisX} .tick text`).each(function (a) { const b = B.indexOf(a); b >= 0 && J.select(this).style('display', b % D ? 'none' : 'block'); }); } else H.svg.selectAll(`.${l.axisX} .tick text`).style('display', 'block'); q = H.generateDrawArea ? H.generateDrawArea(L, !1) : void 0, r = H.generateDrawBar ? H.generateDrawBar(M) : void 0, s = H.generateDrawLine ? H.generateDrawLine(N, !1) : void 0, t = H.generateXYForText(L, M, N, !0), u = H.generateXYForText(L, M, N, !1), c && (H.subY.domain(H.getYDomain(P, 'y')), H.subY2.domain(H.getYDomain(P, 'y2'))), H.updateXgridFocus(), I.select(`text.${l.text}.${l.empty}`).attr('x', H.width / 2).attr('y', H.height / 2).text(K.data_empty_label_text)
      .transition()
      .style('opacity', P.length ? 0 : 1), H.updateGrid(v), H.updateRegion(v), H.updateBar(x), H.updateLine(x), H.updateArea(x), H.updateCircle(), H.hasDataLabel() && H.updateText(x), H.redrawTitle && H.redrawTitle(), H.redrawArc && H.redrawArc(v, x, h), H.redrawSubchart && H.redrawSubchart(d, b, v, x, L, M, N), I.selectAll(`.${l.selectedCircles}`).filter(H.isBarType.bind(H)).selectAll('circle').remove(), K.interaction_enabled && !a.flow && n && (H.redrawEventRect(), H.updateZoom && H.updateZoom()), H.updateCircleY(), F = (H.config.axis_rotated ? H.circleY : H.circleX).bind(H), G = (H.config.axis_rotated ? H.circleX : H.circleY).bind(H), a.flow && (A = H.generateFlow({
      targets: P, flow: a.flow, duration: a.flow.duration, drawBar: r, drawLine: s, drawArea: q, cx: F, cy: G, xv: Q, xForText: t, yForText: u,
    })), (v || A) && H.isTabVisible() ? J.transition().duration(v).each(() => { const b = []; [H.redrawBar(r, !0), H.redrawLine(s, !0), H.redrawArea(q, !0), H.redrawCircle(F, G, !0), H.redrawText(t, u, a.flow, !0), H.redrawRegion(!0), H.redrawGrid(!0)].forEach((a) => { a.forEach((a) => { b.push(a); }); }), z = H.generateWait(), b.forEach((a) => { z.add(a); }); }).call(z, () => { A && A(), K.onrendered && K.onrendered.call(H); }) : (H.redrawBar(r), H.redrawLine(s), H.redrawArea(q), H.redrawCircle(F, G), H.redrawText(t, u, a.flow), H.redrawRegion(), H.redrawGrid(), K.onrendered && K.onrendered.call(H)), H.mapToIds(H.data.targets).forEach((a) => { H.withoutFadeIn[a] = !0; });
  }, i.updateAndRedraw = function (a) { let b; const c = this; const d = c.config; a = a || {}, a.withTransition = w(a, 'withTransition', !0), a.withTransform = w(a, 'withTransform', !1), a.withLegend = w(a, 'withLegend', !1), a.withUpdateXDomain = !0, a.withUpdateOrgXDomain = !0, a.withTransitionForExit = !1, a.withTransitionForTransform = w(a, 'withTransitionForTransform', a.withTransition), c.updateSizes(), a.withLegend && d.legend_show || (b = c.axis.generateTransitions(a.withTransitionForAxis ? d.transition_duration : 0), c.updateScales(), c.updateSvgSize(), c.transformAll(a.withTransitionForTransform, b)), c.redraw(a, b); }, i.redrawWithoutRescale = function () {
    this.redraw({
      withY: !1, withSubchart: !1, withEventRect: !1, withTransitionForAxis: !1,
    });
  }, i.isTimeSeries = function () { return this.config.axis_x_type === 'timeseries'; }, i.isCategorized = function () { return this.config.axis_x_type.indexOf('categor') >= 0; }, i.isCustomX = function () { const a = this; const b = a.config; return !a.isTimeSeries() && (b.data_x || v(b.data_xs)); }, i.isTimeSeriesY = function () { return this.config.axis_y_type === 'timeseries'; }, i.getTranslate = function (a) { let b; let c; const d = this; const e = d.config; return a === 'main' ? (b = s(d.margin.left), c = s(d.margin.top)) : a === 'context' ? (b = s(d.margin2.left), c = s(d.margin2.top)) : a === 'legend' ? (b = d.margin3.left, c = d.margin3.top) : a === 'x' ? (b = 0, c = e.axis_rotated ? 0 : d.height) : a === 'y' ? (b = 0, c = e.axis_rotated ? d.height : 0) : a === 'y2' ? (b = e.axis_rotated ? 0 : d.width, c = e.axis_rotated ? 1 : 0) : a === 'subx' ? (b = 0, c = e.axis_rotated ? 0 : d.height2) : a === 'arc' && (b = d.arcWidth / 2, c = d.arcHeight / 2), `translate(${b},${c})`; }, i.initialOpacity = function (a) { return a.value !== null && this.withoutFadeIn[a.id] ? 1 : 0; }, i.initialOpacityForCircle = function (a) { return a.value !== null && this.withoutFadeIn[a.id] ? this.opacityForCircle(a) : 0; }, i.opacityForCircle = function (a) { const b = this.config.point_show ? 1 : 0; return m(a.value) ? this.isScatterType(a) ? 0.5 : b : 0; }, i.opacityForText = function () { return this.hasDataLabel() ? 1 : 0; }, i.xx = function (a) { return a ? this.x(a.x) : null; }, i.xv = function (a) { const b = this; let c = a.value; return b.isTimeSeries() ? c = b.parseDate(a.value) : b.isCategorized() && typeof a.value === 'string' && (c = b.config.axis_x_categories.indexOf(a.value)), Math.ceil(b.x(c)); }, i.yv = function (a) { const b = this; const c = a.axis && a.axis === 'y2' ? b.y2 : b.y; return Math.ceil(c(a.value)); }, i.subxx = function (a) { return a ? this.subX(a.x) : null; }, i.transformMain = function (a, b) { let c; let d; let e; const f = this; b && b.axisX ? c = b.axisX : (c = f.main.select(`.${l.axisX}`), a && (c = c.transition())), b && b.axisY ? d = b.axisY : (d = f.main.select(`.${l.axisY}`), a && (d = d.transition())), b && b.axisY2 ? e = b.axisY2 : (e = f.main.select(`.${l.axisY2}`), a && (e = e.transition())), (a ? f.main.transition() : f.main).attr('transform', f.getTranslate('main')), c.attr('transform', f.getTranslate('x')), d.attr('transform', f.getTranslate('y')), e.attr('transform', f.getTranslate('y2')), f.main.select(`.${l.chartArcs}`).attr('transform', f.getTranslate('arc')); }, i.transformAll = function (a, b) { const c = this; c.transformMain(a, b), c.config.subchart_show && c.transformContext(a, b), c.legend && c.transformLegend(a); }, i.updateSvgSize = function () {
    const a = this; const b = a.svg.select('.c3-brush .background'); a.svg.attr('width', a.currentWidth).attr('height', a.currentHeight), a.svg.selectAll([`#${a.clipId}`, `#${a.clipIdForGrid}`]).select('rect').attr('width', a.width).attr('height', a.height), a.svg.select(`#${a.clipIdForXAxis}`).select('rect').attr('x', a.getXAxisClipX.bind(a)).attr('y', a.getXAxisClipY.bind(a))
      .attr('width', a.getXAxisClipWidth.bind(a))
      .attr('height', a.getXAxisClipHeight.bind(a)), a.svg.select(`#${a.clipIdForYAxis}`).select('rect').attr('x', a.getYAxisClipX.bind(a)).attr('y', a.getYAxisClipY.bind(a))
      .attr('width', a.getYAxisClipWidth.bind(a))
      .attr('height', a.getYAxisClipHeight.bind(a)), a.svg.select(`#${a.clipIdForSubchart}`).select('rect').attr('width', a.width).attr('height', b.size() ? b.attr('height') : 0), a.svg.select(`.${l.zoomRect}`).attr('width', a.width).attr('height', a.height), a.selectChart.style('max-height', `${a.currentHeight}px`);
  }, i.updateDimension = function (a) { const b = this; a || (b.config.axis_rotated ? (b.axes.x.call(b.xAxis), b.axes.subx.call(b.subXAxis)) : (b.axes.y.call(b.yAxis), b.axes.y2.call(b.y2Axis))), b.updateSizes(), b.updateScales(), b.updateSvgSize(), b.transformAll(!1); }, i.observeInserted = function (b) {
    let c; const d = this; return typeof MutationObserver === 'undefined' ? void a.console.error('MutationObserver not defined.') : (c = new MutationObserver((e) => {
      e.forEach((e) => {
        e.type === 'childList' && e.previousSibling && (c.disconnect(), d.intervalForObserveInserted = a.setInterval(() => {
          b.node().parentNode && (a.clearInterval(d.intervalForObserveInserted), d.updateDimension(), d.brush && d.brush.update(), d.config.oninit.call(d), d.redraw({
            withTransform: !0, withUpdateXDomain: !0, withUpdateOrgXDomain: !0, withTransition: !1, withTransitionForTransform: !1, withLegend: !0,
          }), b.transition().style('opacity', 1));
        }, 10));
      });
    }), void c.observe(b.node(), { attributes: !0, childList: !0, characterData: !0 }));
  }, i.bindResize = function () { const b = this; const c = b.config; if (b.resizeFunction = b.generateResize(), b.resizeFunction.add(() => { c.onresize.call(b); }), c.resize_auto && b.resizeFunction.add(() => { void 0 !== b.resizeTimeout && a.clearTimeout(b.resizeTimeout), b.resizeTimeout = a.setTimeout(() => { delete b.resizeTimeout, b.api.flush(); }, 100); }), b.resizeFunction.add(() => { c.onresized.call(b); }), a.attachEvent)a.attachEvent('onresize', b.resizeFunction); else if (a.addEventListener)a.addEventListener('resize', b.resizeFunction, !1); else { let d = a.onresize; d ? d.add && d.remove || (d = b.generateResize(), d.add(a.onresize)) : d = b.generateResize(), d.add(b.resizeFunction), a.onresize = d; } }, i.generateResize = function () { function a() { b.forEach((a) => { a(); }); } var b = []; return a.add = function (a) { b.push(a); }, a.remove = function (a) { for (let c = 0; c < b.length; c++) if (b[c] === a) { b.splice(c, 1); break; } }, a; }, i.endall = function (a, b) { let c = 0; a.each(() => { ++c; }).each('end', function () { --c || b.apply(this, arguments); }); }, i.generateWait = function () { const a = []; const b = function (b, c) { var d = setInterval(() => { let b = 0; a.forEach((a) => { if (a.empty()) return void (b += 1); try { a.transition(); } catch (c) { b += 1; } }), b === a.length && (clearInterval(d), c && c()); }, 10); }; return b.add = function (b) { a.push(b); }, b; }, i.parseDate = function (b) { let c; const d = this; return b instanceof Date ? c = b : typeof b === 'string' ? c = d.dataTimeFormat(d.config.data_xFormat).parse(b) : typeof b !== 'number' || isNaN(b) || (c = new Date(+b)), c && !isNaN(+c) || a.console.error(`Failed to parse x '${b}' to Date object`), c; }, i.isTabVisible = function () { let a; return typeof document.hidden !== 'undefined' ? a = 'hidden' : typeof document.mozHidden !== 'undefined' ? a = 'mozHidden' : typeof document.msHidden !== 'undefined' ? a = 'msHidden' : typeof document.webkitHidden !== 'undefined' && (a = 'webkitHidden'), !document[a]; }, i.getDefaultConfig = function () {
    const a = {
      bindto: '#chart',
      svg_classname: void 0,
      size_width: void 0,
      size_height: void 0,
      padding_left: void 0,
      padding_right: void 0,
      padding_top: void 0,
      padding_bottom: void 0,
      resize_auto: !0,
      zoom_enabled: !1,
      zoom_extent: void 0,
      zoom_privileged: !1,
      zoom_rescale: !1,
      zoom_onzoom() {},
      zoom_onzoomstart() {},
      zoom_onzoomend() {},
      zoom_x_min: void 0,
      zoom_x_max: void 0,
      interaction_brighten: !0,
      interaction_enabled: !0,
      onmouseover() {},
      onmouseout() {},
      onresize() {},
      onresized() {},
      oninit() {},
      onrendered() {},
      transition_duration: 350,
      data_x: void 0,
      data_xs: {},
      data_xFormat: '%Y-%m-%d',
      data_xLocaltime: !0,
      data_xSort: !0,
      data_idConverter(a) { return a; },
      data_names: {},
      data_classes: {},
      data_groups: [],
      data_axes: {},
      data_type: void 0,
      data_types: {},
      data_labels: {},
      data_order: 'desc',
      data_regions: {},
      data_color: void 0,
      data_colors: {},
      data_hide: !1,
      data_filter: void 0,
      data_selection_enabled: !1,
      data_selection_grouped: !1,
      data_selection_isselectable() { return !0; },
      data_selection_multiple: !0,
      data_selection_draggable: !1,
      data_onclick() {},
      data_onmouseover() {},
      data_onmouseout() {},
      data_onselected() {},
      data_onunselected() {},
      data_url: void 0,
      data_headers: void 0,
      data_json: void 0,
      data_rows: void 0,
      data_columns: void 0,
      data_mimeType: void 0,
      data_keys: void 0,
      data_empty_label_text: '',
      subchart_show: !1,
      subchart_size_height: 60,
      subchart_axis_x_show: !0,
      subchart_onbrush() {},
      color_pattern: [],
      color_threshold: {},
      legend_show: !0,
      legend_hide: !1,
      legend_position: 'bottom',
      legend_inset_anchor: 'top-left',
      legend_inset_x: 10,
      legend_inset_y: 0,
      legend_inset_step: void 0,
      legend_item_onclick: void 0,
      legend_item_onmouseover: void 0,
      legend_item_onmouseout: void 0,
      legend_equally: !1,
      legend_padding: 0,
      legend_item_tile_width: 10,
      legend_item_tile_height: 10,
      axis_rotated: !1,
      axis_x_show: !0,
      axis_x_type: 'indexed',
      axis_x_localtime: !0,
      axis_x_categories: [],
      axis_x_tick_centered: !1,
      axis_x_tick_format: void 0,
      axis_x_tick_culling: {},
      axis_x_tick_culling_max: 10,
      axis_x_tick_count: void 0,
      axis_x_tick_fit: !0,
      axis_x_tick_values: null,
      axis_x_tick_rotate: 0,
      axis_x_tick_outer: !0,
      axis_x_tick_multiline: !0,
      axis_x_tick_width: null,
      axis_x_max: void 0,
      axis_x_min: void 0,
      axis_x_padding: {},
      axis_x_height: void 0,
      axis_x_extent: void 0,
      axis_x_label: {},
      axis_y_show: !0,
      axis_y_type: void 0,
      axis_y_max: void 0,
      axis_y_min: void 0,
      axis_y_inverted: !1,
      axis_y_center: void 0,
      axis_y_inner: void 0,
      axis_y_label: {},
      axis_y_tick_format: void 0,
      axis_y_tick_outer: !0,
      axis_y_tick_values: null,
      axis_y_tick_rotate: 0,
      axis_y_tick_count: void 0,
      axis_y_tick_time_value: void 0,
      axis_y_tick_time_interval: void 0,
      axis_y_padding: {},
      axis_y_default: void 0,
      axis_y2_show: !1,
      axis_y2_max: void 0,
      axis_y2_min: void 0,
      axis_y2_inverted: !1,
      axis_y2_center: void 0,
      axis_y2_inner: void 0,
      axis_y2_label: {},
      axis_y2_tick_format: void 0,
      axis_y2_tick_outer: !0,
      axis_y2_tick_values: null,
      axis_y2_tick_count: void 0,
      axis_y2_padding: {},
      axis_y2_default: void 0,
      grid_x_show: !1,
      grid_x_type: 'tick',
      grid_x_lines: [],
      grid_y_show: !1,
      grid_y_lines: [],
      grid_y_ticks: 10,
      grid_focus_show: !0,
      grid_lines_front: !0,
      point_show: !0,
      point_r: 2.5,
      point_sensitivity: 10,
      point_focus_expand_enabled: !0,
      point_focus_expand_r: void 0,
      point_select_r: void 0,
      line_connectNull: !1,
      line_step_type: 'step',
      bar_width: void 0,
      bar_width_ratio: 0.6,
      bar_width_max: void 0,
      bar_zerobased: !0,
      area_zerobased: !0,
      area_above: !1,
      pie_label_show: !0,
      pie_label_format: void 0,
      pie_label_threshold: 0.05,
      pie_label_ratio: void 0,
      pie_expand: {},
      pie_expand_duration: 50,
      gauge_fullCircle: !1,
      gauge_label_show: !0,
      gauge_label_format: void 0,
      gauge_min: 0,
      gauge_max: 100,
      gauge_startingAngle: -1 * Math.PI / 2,
      gauge_units: void 0,
      gauge_width: void 0,
      gauge_expand: {},
      gauge_expand_duration: 50,
      donut_label_show: !0,
      donut_label_format: void 0,
      donut_label_threshold: 0.05,
      donut_label_ratio: void 0,
      donut_width: void 0,
      donut_title: '',
      donut_expand: {},
      donut_expand_duration: 50,
      spline_interpolation_type: 'cardinal',
      regions: [],
      tooltip_show: !0,
      tooltip_grouped: !0,
      tooltip_format_title: void 0,
      tooltip_format_name: void 0,
      tooltip_format_value: void 0,
      tooltip_position: void 0,
      tooltip_contents(a, b, c, d) { return this.getTooltipContent ? this.getTooltipContent(a, b, c, d) : ''; },
      tooltip_init_show: !1,
      tooltip_init_x: 0,
      tooltip_init_position: { top: '0px', left: '50px' },
      tooltip_onshow() {},
      tooltip_onhide() {},
      title_text: void 0,
      title_padding: {
        top: 0, right: 0, bottom: 0, left: 0,
      },
      title_position: 'top-center',
    }; return Object.keys(this.additionalConfig).forEach(function (b) { a[b] = this.additionalConfig[b]; }, this), a;
  }, i.additionalConfig = {}, i.loadConfig = function (a) { function b() { const a = d.shift(); return a && c && typeof c === 'object' && a in c ? (c = c[a], b()) : a ? void 0 : c; } let c; let d; let e; const f = this.config; Object.keys(f).forEach((g) => { c = a, d = g.split('_'), e = b(), q(e) && (f[g] = e); }); }, i.getScale = function (a, b, c) { return (c ? this.d3.time.scale() : this.d3.scale.linear()).range([a, b]); }, i.getX = function (a, b, c, d) { let e; const f = this; let g = f.getScale(a, b, f.isTimeSeries()); const h = c ? g.domain(c) : g; f.isCategorized() ? (d = d || function () { return 0; }, g = function (a, b) { const c = h(a) + d(a); return b ? c : Math.ceil(c); }) : g = function (a, b) { const c = h(a); return b ? c : Math.ceil(c); }; for (e in h)g[e] = h[e]; return g.orgDomain = function () { return h.domain(); }, f.isCategorized() && (g.domain = function (a) { return arguments.length ? (h.domain(a), g) : (a = this.orgDomain(), [a[0], a[1] + 1]); }), g; }, i.getY = function (a, b, c) { const d = this.getScale(a, b, this.isTimeSeriesY()); return c && d.domain(c), d; }, i.getYScale = function (a) { return this.axis.getId(a) === 'y2' ? this.y2 : this.y; }, i.getSubYScale = function (a) { return this.axis.getId(a) === 'y2' ? this.subY2 : this.subY; }, i.updateScales = function () { const a = this; const b = a.config; const c = !a.x; a.xMin = b.axis_rotated ? 1 : 0, a.xMax = b.axis_rotated ? a.height : a.width, a.yMin = b.axis_rotated ? 0 : a.height, a.yMax = b.axis_rotated ? a.width : 1, a.subXMin = a.xMin, a.subXMax = a.xMax, a.subYMin = b.axis_rotated ? 0 : a.height2, a.subYMax = b.axis_rotated ? a.width2 : 1, a.x = a.getX(a.xMin, a.xMax, c ? void 0 : a.x.orgDomain(), () => a.xAxis.tickOffset()), a.y = a.getY(a.yMin, a.yMax, c ? b.axis_y_default : a.y.domain()), a.y2 = a.getY(a.yMin, a.yMax, c ? b.axis_y2_default : a.y2.domain()), a.subX = a.getX(a.xMin, a.xMax, a.orgXDomain, (b) => (b % 1 ? 0 : a.subXAxis.tickOffset())), a.subY = a.getY(a.subYMin, a.subYMax, c ? b.axis_y_default : a.subY.domain()), a.subY2 = a.getY(a.subYMin, a.subYMax, c ? b.axis_y2_default : a.subY2.domain()), a.xAxisTickFormat = a.axis.getXAxisTickFormat(), a.xAxisTickValues = a.axis.getXAxisTickValues(), a.yAxisTickValues = a.axis.getYAxisTickValues(), a.y2AxisTickValues = a.axis.getY2AxisTickValues(), a.xAxis = a.axis.getXAxis(a.x, a.xOrient, a.xAxisTickFormat, a.xAxisTickValues, b.axis_x_tick_outer), a.subXAxis = a.axis.getXAxis(a.subX, a.subXOrient, a.xAxisTickFormat, a.xAxisTickValues, b.axis_x_tick_outer), a.yAxis = a.axis.getYAxis(a.y, a.yOrient, b.axis_y_tick_format, a.yAxisTickValues, b.axis_y_tick_outer), a.y2Axis = a.axis.getYAxis(a.y2, a.y2Orient, b.axis_y2_tick_format, a.y2AxisTickValues, b.axis_y2_tick_outer), c || (a.brush && a.brush.scale(a.subX), b.zoom_enabled && a.zoom.scale(a.x)), a.updateArc && a.updateArc(); }, i.getYDomainMin = function (a) { let b; let c; let d; let e; let f; let g; const h = this; const i = h.config; const j = h.mapToIds(a); const k = h.getValuesAsIdKeyed(a); if (i.data_groups.length > 0) for (g = h.hasNegativeValueInTargets(a), b = 0; b < i.data_groups.length; b++) if (e = i.data_groups[b].filter((a) => j.indexOf(a) >= 0), e.length !== 0) for (d = e[0], g && k[d] && k[d].forEach((a, b) => { k[d][b] = a < 0 ? a : 0; }), c = 1; c < e.length; c++)f = e[c], k[f] && k[f].forEach((a, b) => { h.axis.getId(f) !== h.axis.getId(d) || !k[d] || g && +a > 0 || (k[d][b] += +a); }); return h.d3.min(Object.keys(k).map((a) => h.d3.min(k[a]))); }, i.getYDomainMax = function (a) { let b; let c; let d; let e; let f; let g; const h = this; const i = h.config; const j = h.mapToIds(a); const k = h.getValuesAsIdKeyed(a); if (i.data_groups.length > 0) for (g = h.hasPositiveValueInTargets(a), b = 0; b < i.data_groups.length; b++) if (e = i.data_groups[b].filter((a) => j.indexOf(a) >= 0), e.length !== 0) for (d = e[0], g && k[d] && k[d].forEach((a, b) => { k[d][b] = a > 0 ? a : 0; }), c = 1; c < e.length; c++)f = e[c], k[f] && k[f].forEach((a, b) => { h.axis.getId(f) !== h.axis.getId(d) || !k[d] || g && +a < 0 || (k[d][b] += +a); }); return h.d3.max(Object.keys(k).map((a) => h.d3.max(k[a]))); }, i.getYDomain = function (a, b, c) {
    let d; let e; let f; let g; let h; let i; let j; let k; let l; let n; let o; const p = this; const q = p.config; const r = a.filter((a) => p.axis.getId(a.id) === b); const s = c ? p.filterByXDomain(r, c) : r; const u = b === 'y2' ? q.axis_y2_min : q.axis_y_min; const w = b === 'y2' ? q.axis_y2_max : q.axis_y_max; let x = p.getYDomainMin(s); let y = p.getYDomainMax(s); const z = b === 'y2' ? q.axis_y2_center : q.axis_y_center; let A = p.hasType('bar', s) && q.bar_zerobased || p.hasType('area', s) && q.area_zerobased; const B = b === 'y2' ? q.axis_y2_inverted : q.axis_y_inverted; const C = p.hasDataLabel() && q.axis_rotated; const D = p.hasDataLabel() && !q.axis_rotated; return x = m(u) ? u : m(w) ? w > x ? x : w - 10 : x, y = m(w) ? w : m(u) ? y > u ? y : u + 10 : y, s.length === 0 ? b === 'y2' ? p.y2.domain() : p.y.domain() : (isNaN(x) && (x = 0), isNaN(y) && (y = x), x === y && (x < 0 ? y = 0 : x = 0), n = x >= 0 && y >= 0, o = x <= 0 && y <= 0, (m(u) && n || m(w) && o) && (A = !1), A && (n && (x = 0), o && (y = 0)), e = Math.abs(y - x), f = g = h = 0.1 * e, typeof z !== 'undefined' && (i = Math.max(Math.abs(x), Math.abs(y)), y = z + i, x = z - i), C ? (j = p.getDataLabelLength(x, y, 'width'), k = t(p.y.range()), l = [j[0] / k, j[1] / k],
    g += e * (l[1] / (1 - l[0] - l[1])), h += e * (l[0] / (1 - l[0] - l[1]))) : D && (j = p.getDataLabelLength(x, y, 'height'), g += p.axis.convertPixelsToAxisPadding(j[1], e), h += p.axis.convertPixelsToAxisPadding(j[0], e)), b === 'y' && v(q.axis_y_padding) && (g = p.axis.getPadding(q.axis_y_padding, 'top', g, e), h = p.axis.getPadding(q.axis_y_padding, 'bottom', h, e)), b === 'y2' && v(q.axis_y2_padding) && (g = p.axis.getPadding(q.axis_y2_padding, 'top', g, e), h = p.axis.getPadding(q.axis_y2_padding, 'bottom', h, e)), A && (n && (h = x), o && (g = -y)), d = [x - h, y + g], B ? d.reverse() : d);
  }, i.getXDomainMin = function (a) { const b = this; const c = b.config; return q(c.axis_x_min) ? b.isTimeSeries() ? this.parseDate(c.axis_x_min) : c.axis_x_min : b.d3.min(a, (a) => b.d3.min(a.values, (a) => a.x)); }, i.getXDomainMax = function (a) { const b = this; const c = b.config; return q(c.axis_x_max) ? b.isTimeSeries() ? this.parseDate(c.axis_x_max) : c.axis_x_max : b.d3.max(a, (a) => b.d3.max(a.values, (a) => a.x)); }, i.getXDomainPadding = function (a) { let b; let c; let d; let e; const f = this; const g = f.config; const h = a[1] - a[0]; return f.isCategorized() ? c = 0 : f.hasType('bar') ? (b = f.getMaxDataCount(), c = b > 1 ? h / (b - 1) / 2 : 0.5) : c = 0.01 * h, typeof g.axis_x_padding === 'object' && v(g.axis_x_padding) ? (d = m(g.axis_x_padding.left) ? g.axis_x_padding.left : c, e = m(g.axis_x_padding.right) ? g.axis_x_padding.right : c) : d = e = typeof g.axis_x_padding === 'number' ? g.axis_x_padding : c, { left: d, right: e }; }, i.getXDomain = function (a) { const b = this; const c = [b.getXDomainMin(a), b.getXDomainMax(a)]; let d = c[0]; let e = c[1]; const f = b.getXDomainPadding(c); let g = 0; let h = 0; return d - e !== 0 || b.isCategorized() || (b.isTimeSeries() ? (d = new Date(0.5 * d.getTime()), e = new Date(1.5 * e.getTime())) : (d = d === 0 ? 1 : 0.5 * d, e = e === 0 ? -1 : 1.5 * e)), (d || d === 0) && (g = b.isTimeSeries() ? new Date(d.getTime() - f.left) : d - f.left), (e || e === 0) && (h = b.isTimeSeries() ? new Date(e.getTime() + f.right) : e + f.right), [g, h]; }, i.updateXDomain = function (a, b, c, d, e) { const f = this; const g = f.config; return c && (f.x.domain(e || f.d3.extent(f.getXDomain(a))), f.orgXDomain = f.x.domain(), g.zoom_enabled && f.zoom.scale(f.x).updateScaleExtent(), f.subX.domain(f.x.domain()), f.brush && f.brush.scale(f.subX)), b && (f.x.domain(e || (!f.brush || f.brush.empty() ? f.orgXDomain : f.brush.extent())), g.zoom_enabled && f.zoom.scale(f.x).updateScaleExtent()), d && f.x.domain(f.trimXDomain(f.x.orgDomain())), f.x.domain(); }, i.trimXDomain = function (a) { const b = this.getZoomDomain(); const c = b[0]; const d = b[1]; return a[0] <= c && (a[1] = +a[1] + (c - a[0]), a[0] = c), d <= a[1] && (a[0] = +a[0] - (a[1] - d), a[1] = d), a; }, i.isX = function (a) { const b = this; const c = b.config; return c.data_x && a === c.data_x || v(c.data_xs) && x(c.data_xs, a); }, i.isNotX = function (a) { return !this.isX(a); }, i.getXKey = function (a) { const b = this; const c = b.config; return c.data_x ? c.data_x : v(c.data_xs) ? c.data_xs[a] : null; }, i.getXValuesOfXKey = function (a, b) { let c; const d = this; const e = b && v(b) ? d.mapToIds(b) : []; return e.forEach((b) => { d.getXKey(b) === a && (c = d.data.xs[b]); }), c; }, i.getIndexByX = function (a) { const b = this; const c = b.filterByX(b.data.targets, a); return c.length ? c[0].index : null; }, i.getXValue = function (a, b) { const c = this; return a in c.data.xs && c.data.xs[a] && m(c.data.xs[a][b]) ? c.data.xs[a][b] : b; }, i.getOtherTargetXs = function () { const a = this; const b = Object.keys(a.data.xs); return b.length ? a.data.xs[b[0]] : null; }, i.getOtherTargetX = function (a) { const b = this.getOtherTargetXs(); return b && a < b.length ? b[a] : null; }, i.addXs = function (a) { const b = this; Object.keys(a).forEach((c) => { b.config.data_xs[c] = a[c]; }); }, i.hasMultipleX = function (a) { return this.d3.set(Object.keys(a).map((b) => a[b])).size() > 1; }, i.isMultipleX = function () { return v(this.config.data_xs) || !this.config.data_xSort || this.hasType('scatter'); }, i.addName = function (a) { let b; const c = this; return a && (b = c.config.data_names[a.id], a.name = void 0 !== b ? b : a.id), a; }, i.getValueOnIndex = function (a, b) { const c = a.filter((a) => a.index === b); return c.length ? c[0] : null; }, i.updateTargetX = function (a, b) { const c = this; a.forEach((a) => { a.values.forEach((d, e) => { d.x = c.generateTargetX(b[e], a.id, e); }), c.data.xs[a.id] = b; }); }, i.updateTargetXs = function (a, b) { const c = this; a.forEach((a) => { b[a.id] && c.updateTargetX([a], b[a.id]); }); }, i.generateTargetX = function (a, b, c) { let d; const e = this; return d = e.isTimeSeries() ? a ? e.parseDate(a) : e.parseDate(e.getXValue(b, c)) : e.isCustomX() && !e.isCategorized() ? m(a) ? +a : e.getXValue(b, c) : c; }, i.cloneTarget = function (a) { return { id: a.id, id_org: a.id_org, values: a.values.map((a) => ({ x: a.x, value: a.value, id: a.id })) }; }, i.updateXs = function () { const a = this; a.data.targets.length && (a.xs = [], a.data.targets[0].values.forEach((b) => { a.xs[b.index] = b.x; })); }, i.getPrevX = function (a) { const b = this.xs[a - 1]; return typeof b !== 'undefined' ? b : null; }, i.getNextX = function (a) { const b = this.xs[a + 1]; return typeof b !== 'undefined' ? b : null; }, i.getMaxDataCount = function () { const a = this; return a.d3.max(a.data.targets, (a) => a.values.length); }, i.getMaxDataCountTarget = function (a) { let b; const c = a.length; let d = 0; return c > 1 ? a.forEach((a) => { a.values.length > d && (b = a, d = a.values.length); }) : b = c ? a[0] : null, b; }, i.getEdgeX = function (a) { const b = this; return a.length ? [b.d3.min(a, (a) => a.values[0].x), b.d3.max(a, (a) => a.values[a.values.length - 1].x)] : [0, 0]; }, i.mapToIds = function (a) { return a.map((a) => a.id); }, i.mapToTargetIds = function (a) { const b = this; return a ? [].concat(a) : b.mapToIds(b.data.targets); }, i.hasTarget = function (a, b) { let c; const d = this.mapToIds(a); for (c = 0; c < d.length; c++) if (d[c] === b) return !0; return !1; }, i.isTargetToShow = function (a) { return this.hiddenTargetIds.indexOf(a) < 0; }, i.isLegendToShow = function (a) { return this.hiddenLegendIds.indexOf(a) < 0; }, i.filterTargetsToShow = function (a) { const b = this; return a.filter((a) => b.isTargetToShow(a.id)); }, i.mapTargetsToUniqueXs = function (a) { const b = this; let c = b.d3.set(b.d3.merge(a.map((a) => a.values.map((a) => +a.x)))).values(); return c = b.isTimeSeries() ? c.map((a) => new Date(+a)) : c.map((a) => +a), c.sort((a, b) => (b > a ? -1 : a > b ? 1 : a >= b ? 0 : NaN)); }, i.addHiddenTargetIds = function (a) { this.hiddenTargetIds = this.hiddenTargetIds.concat(a); }, i.removeHiddenTargetIds = function (a) { this.hiddenTargetIds = this.hiddenTargetIds.filter((b) => a.indexOf(b) < 0); }, i.addHiddenLegendIds = function (a) { this.hiddenLegendIds = this.hiddenLegendIds.concat(a); }, i.removeHiddenLegendIds = function (a) { this.hiddenLegendIds = this.hiddenLegendIds.filter((b) => a.indexOf(b) < 0); }, i.getValuesAsIdKeyed = function (a) { const b = {}; return a.forEach((a) => { b[a.id] = [], a.values.forEach((c) => { b[a.id].push(c.value); }); }), b; }, i.checkValueInTargets = function (a, b) { let c; let d; let e; const f = Object.keys(a); for (c = 0; c < f.length; c++) for (e = a[f[c]].values, d = 0; d < e.length; d++) if (b(e[d].value)) return !0; return !1; }, i.hasNegativeValueInTargets = function (a) { return this.checkValueInTargets(a, (a) => a < 0); }, i.hasPositiveValueInTargets = function (a) { return this.checkValueInTargets(a, (a) => a > 0); }, i.isOrderDesc = function () { const a = this.config; return typeof a.data_order === 'string' && a.data_order.toLowerCase() === 'desc'; }, i.isOrderAsc = function () { const a = this.config; return typeof a.data_order === 'string' && a.data_order.toLowerCase() === 'asc'; }, i.orderTargets = function (a) { const b = this; const c = b.config; const d = b.isOrderAsc(); const e = b.isOrderDesc(); return d || e ? a.sort((a, b) => { const c = function (a, b) { return a + Math.abs(b.value); }; const e = a.values.reduce(c, 0); const f = b.values.reduce(c, 0); return d ? f - e : e - f; }) : n(c.data_order) && a.sort(c.data_order), a; }, i.filterByX = function (a, b) { return this.d3.merge(a.map((a) => a.values)).filter((a) => a.x - b === 0); }, i.filterRemoveNull = function (a) { return a.filter((a) => m(a.value)); }, i.filterByXDomain = function (a, b) { return a.map((a) => ({ id: a.id, id_org: a.id_org, values: a.values.filter((a) => b[0] <= a.x && a.x <= b[1]) })); }, i.hasDataLabel = function () { const a = this.config; return typeof a.data_labels === 'boolean' && a.data_labels ? !0 : !(typeof a.data_labels !== 'object' || !v(a.data_labels)); }, i.getDataLabelLength = function (a, b, c) {
    const d = this; const e = [0, 0]; const f = 1.3; return d.selectChart.select('svg').selectAll('.dummy').data([a, b]).enter()
      .append('text')
      .text((a) => d.dataLabelFormat(a.id)(a))
      .each(function (a, b) { e[b] = this.getBoundingClientRect()[c] * f; })
      .remove(), e;
  }, i.isNoneArc = function (a) { return this.hasTarget(this.data.targets, a.id); }, i.isArc = function (a) { return 'data' in a && this.hasTarget(this.data.targets, a.data.id); }, i.findSameXOfValues = function (a, b) { let c; const d = a[b].x; const e = []; for (c = b - 1; c >= 0 && d === a[c].x; c--)e.push(a[c]); for (c = b; c < a.length && d === a[c].x; c++)e.push(a[c]); return e; }, i.findClosestFromTargets = function (a, b) { let c; const d = this; return c = a.map((a) => d.findClosest(a.values, b)), d.findClosest(c, b); }, i.findClosest = function (a, b) { let c; const d = this; let e = d.config.point_sensitivity; return a.filter((a) => a && d.isBarType(a.id)).forEach((a) => { const b = d.main.select(`.${l.bars}${d.getTargetSelectorSuffix(a.id)} .${l.bar}-${a.index}`).node(); !c && d.isWithinBar(b) && (c = a); }), a.filter((a) => a && !d.isBarType(a.id)).forEach((a) => { const f = d.dist(a, b); e > f && (e = f, c = a); }), c; }, i.dist = function (a, b) { const c = this; const d = c.config; const e = d.axis_rotated ? 1 : 0; const f = d.axis_rotated ? 0 : 1; const g = c.circleY(a, a.index); const h = c.x(a.x); return Math.sqrt(Math.pow(h - b[e], 2) + Math.pow(g - b[f], 2)); }, i.convertValuesToStep = function (a) { let b; const c = [].concat(a); if (!this.isCategorized()) return a; for (b = a.length + 1; b > 0; b--)c[b] = c[b - 1]; return c[0] = { x: c[0].x - 1, value: c[0].value, id: c[0].id }, c[a.length + 1] = { x: c[a.length].x + 1, value: c[a.length].value, id: c[a.length].id }, c; }, i.updateDataAttributes = function (a, b) { const c = this; const d = c.config; const e = d[`data_${a}`]; return typeof b === 'undefined' ? e : (Object.keys(b).forEach((a) => { e[a] = b[a]; }), c.redraw({ withLegend: !0 }), e); }, i.convertUrlToData = function (a, b, c, d, e) { const f = this; const g = b || 'csv'; const h = f.d3.xhr(a); c && Object.keys(c).forEach((a) => { h.header(a, c[a]); }), h.get((a, b) => { let c; if (!b) throw new Error(`${a.responseURL} ${a.status} (${a.statusText})`); c = g === 'json' ? f.convertJsonToData(JSON.parse(b.response), d) : g === 'tsv' ? f.convertTsvToData(b.response) : f.convertCsvToData(b.response), e.call(f, c); }); }, i.convertXsvToData = function (a, b) { let c; const d = b.parseRows(a); return d.length === 1 ? (c = [{}], d[0].forEach((a) => { c[0][a] = null; })) : c = b.parse(a), c; }, i.convertCsvToData = function (a) { return this.convertXsvToData(a, this.d3.csv); }, i.convertTsvToData = function (a) { return this.convertXsvToData(a, this.d3.tsv); }, i.convertJsonToData = function (a, b) { let c; let d; const e = this; const f = []; return b ? (b.x ? (c = b.value.concat(b.x), e.config.data_x = b.x) : c = b.value, f.push(c), a.forEach((a) => { const b = []; c.forEach((c) => { let d = e.findValueInJson(a, c); p(d) && (d = null), b.push(d); }), f.push(b); }), d = e.convertRowsToData(f)) : (Object.keys(a).forEach((b) => { f.push([b].concat(a[b])); }), d = e.convertColumnsToData(f)), d; }, i.findValueInJson = function (a, b) { b = b.replace(/\[(\w+)\]/g, '.$1'), b = b.replace(/^\./, ''); for (let c = b.split('.'), d = 0; d < c.length; ++d) { const e = c[d]; if (!(e in a)) return; a = a[e]; } return a; }, i.convertRowsToData = function (a) { let b; let c; const d = a[0]; let e = {}; const f = []; for (b = 1; b < a.length; b++) { for (e = {}, c = 0; c < a[b].length; c++) { if (p(a[b][c])) throw new Error(`Source data is missing a component at (${b},${c})!`); e[d[c]] = a[b][c]; }f.push(e); } return f; }, i.convertColumnsToData = function (a) { let b; let c; let d; const e = []; for (b = 0; b < a.length; b++) for (d = a[b][0], c = 1; c < a[b].length; c++) { if (p(e[c - 1]) && (e[c - 1] = {}), p(a[b][c])) throw new Error(`Source data is missing a component at (${b},${c})!`); e[c - 1][d] = a[b][c]; } return e; }, i.convertDataToTargets = function (a, b) { let c; const d = this; const e = d.config; const f = d.d3.keys(a[0]).filter(d.isNotX, d); const g = d.d3.keys(a[0]).filter(d.isX, d); return f.forEach((c) => { const f = d.getXKey(c); d.isCustomX() || d.isTimeSeries() ? g.indexOf(f) >= 0 ? d.data.xs[c] = (b && d.data.xs[c] ? d.data.xs[c] : []).concat(a.map((a) => a[f]).filter(m).map((a, b) => d.generateTargetX(a, c, b))) : e.data_x ? d.data.xs[c] = d.getOtherTargetXs() : v(e.data_xs) && (d.data.xs[c] = d.getXValuesOfXKey(f, d.data.targets)) : d.data.xs[c] = a.map((a, b) => b); }), f.forEach((a) => { if (!d.data.xs[a]) throw new Error(`x is not defined for id = "${a}".`); }), c = f.map((b, c) => { const f = e.data_idConverter(b); return { id: f, id_org: b, values: a.map((a, g) => { let h; const i = d.getXKey(b); const j = a[i]; const k = a[b] === null || isNaN(a[b]) ? null : +a[b]; return d.isCustomX() && d.isCategorized() && c === 0 && !p(j) ? (c === 0 && g === 0 && (e.axis_x_categories = []), h = e.axis_x_categories.indexOf(j), h === -1 && (h = e.axis_x_categories.length, e.axis_x_categories.push(j))) : h = d.generateTargetX(j, b, g), (p(a[b]) || d.data.xs[b].length <= g) && (h = void 0), { x: h, value: k, id: f }; }).filter((a) => q(a.x)) }; }), c.forEach((a) => { let b; e.data_xSort && (a.values = a.values.sort((a, b) => { const c = a.x || a.x === 0 ? a.x : 1 / 0; const d = b.x || b.x === 0 ? b.x : 1 / 0; return c - d; })), b = 0, a.values.forEach((a) => { a.index = b++; }), d.data.xs[a.id].sort((a, b) => a - b); }), d.hasNegativeValue = d.hasNegativeValueInTargets(c), d.hasPositiveValue = d.hasPositiveValueInTargets(c), e.data_type && d.setTargetType(d.mapToIds(c).filter((a) => !(a in e.data_types)), e.data_type), c.forEach((a) => { d.addCache(a.id_org, a); }), c; }, i.load = function (a, b) { const c = this; a && (b.filter && (a = a.filter(b.filter)), (b.type || b.types) && a.forEach((a) => { const d = b.types && b.types[a.id] ? b.types[a.id] : b.type; c.setTargetType(a.id, d); }), c.data.targets.forEach((b) => { for (let c = 0; c < a.length; c++) if (b.id === a[c].id) { b.values = a[c].values, a.splice(c, 1); break; } }), c.data.targets = c.data.targets.concat(a)), c.updateTargets(c.data.targets), c.redraw({ withUpdateOrgXDomain: !0, withUpdateXDomain: !0, withLegend: !0 }), b.done && b.done(); }, i.loadFromArgs = function (a) { const b = this; a.data ? b.load(b.convertDataToTargets(a.data), a) : a.url ? b.convertUrlToData(a.url, a.mimeType, a.headers, a.keys, (c) => { b.load(b.convertDataToTargets(c), a); }) : a.json ? b.load(b.convertDataToTargets(b.convertJsonToData(a.json, a.keys)), a) : a.rows ? b.load(b.convertDataToTargets(b.convertRowsToData(a.rows)), a) : a.columns ? b.load(b.convertDataToTargets(b.convertColumnsToData(a.columns)), a) : b.load(null, a); }, i.unload = function (a, b) {
    const c = this; return b || (b = function () {}), a = a.filter((a) => c.hasTarget(c.data.targets, a)), a && a.length !== 0 ? (c.svg.selectAll(a.map((a) => c.selectorTarget(a))).transition().style('opacity', 0).remove()
      .call(c.endall, b), void a.forEach((a) => { c.withoutFadeIn[a] = !1, c.legend && c.legend.selectAll(`.${l.legendItem}${c.getTargetSelectorSuffix(a)}`).remove(), c.data.targets = c.data.targets.filter((b) => b.id !== a); })) : void b();
  }, i.categoryName = function (a) { const b = this.config; return a < b.axis_x_categories.length ? b.axis_x_categories[a] : a; }, i.initEventRect = function () { const a = this; a.main.select(`.${l.chart}`).append('g').attr('class', l.eventRects).style('fill-opacity', 0); }, i.redrawEventRect = function () { let a; let b; const c = this; const d = c.config; const e = c.isMultipleX(); const f = c.main.select(`.${l.eventRects}`).style('cursor', d.zoom_enabled ? d.axis_rotated ? 'ns-resize' : 'ew-resize' : null).classed(l.eventRectsMultiple, e).classed(l.eventRectsSingle, !e); f.selectAll(`.${l.eventRect}`).remove(), c.eventRect = f.selectAll(`.${l.eventRect}`), e ? (a = c.eventRect.data([0]), c.generateEventRectsForMultipleXs(a.enter()), c.updateEventRect(a)) : (b = c.getMaxDataCountTarget(c.data.targets), f.datum(b ? b.values : []), c.eventRect = f.selectAll(`.${l.eventRect}`), a = c.eventRect.data((a) => a), c.generateEventRectsForSingleX(a.enter()), c.updateEventRect(a), a.exit().remove()); }, i.updateEventRect = function (a) {
    let b; let c; let d; let e; let f; let g; const h = this; const i = h.config; a = a || h.eventRect.data((a) => a), h.isMultipleX() ? (b = 0, c = 0, d = h.width, e = h.height) : (!h.isCustomX() && !h.isTimeSeries() || h.isCategorized() ? (f = h.getEventRectWidth(), g = function (a) { return h.x(a.x) - f / 2; }) : (h.updateXs(), f = function (a) { let b = h.getPrevX(a.index); let c = h.getNextX(a.index); return b === null && c === null ? i.axis_rotated ? h.height : h.width : (b === null && (b = h.x.domain()[0]), c === null && (c = h.x.domain()[1]), Math.max(0, (h.x(c) - h.x(b)) / 2)); }, g = function (a) { let b = h.getPrevX(a.index); const c = h.getNextX(a.index); const d = h.data.xs[a.id][a.index]; return b === null && c === null ? 0 : (b === null && (b = h.x.domain()[0]), (h.x(d) + h.x(b)) / 2); }), b = i.axis_rotated ? 0 : g, c = i.axis_rotated ? g : 0, d = i.axis_rotated ? h.width : f, e = i.axis_rotated ? f : h.height), a.attr('class', h.classEvent.bind(h)).attr('x', b).attr('y', c).attr('width', d)
      .attr('height', e);
  }, i.generateEventRectsForSingleX = function (a) {
    const b = this; const c = b.d3; const d = b.config; a.append('rect').attr('class', b.classEvent.bind(b)).style('cursor', d.data_selection_enabled && d.data_selection_grouped ? 'pointer' : null).on('mouseover', (a) => { const c = a.index; b.dragging || b.flowing || b.hasArcType() || (d.point_focus_expand_enabled && b.expandCircles(c, null, !0), b.expandBars(c, null, !0), b.main.selectAll(`.${l.shape}-${c}`).each((a) => { d.data_onmouseover.call(b.api, a); })); })
      .on('mouseout', (a) => { const c = a.index; b.config && (b.hasArcType() || (b.hideXGridFocus(), b.hideTooltip(), b.unexpandCircles(), b.unexpandBars(), b.main.selectAll(`.${l.shape}-${c}`).each((a) => { d.data_onmouseout.call(b.api, a); }))); })
      .on('mousemove', function (a) { let e; let f = a.index; const g = b.svg.select(`.${l.eventRect}-${f}`); b.dragging || b.flowing || b.hasArcType() || (b.isStepType(a) && b.config.line_step_type === 'step-after' && c.mouse(this)[0] < b.x(b.getXValue(a.id, f)) && (f -= 1), e = b.filterTargetsToShow(b.data.targets).map((a) => b.addName(b.getValueOnIndex(a.values, f))), d.tooltip_grouped && (b.showTooltip(e, this), b.showXGridFocus(e)), (!d.tooltip_grouped || d.data_selection_enabled && !d.data_selection_grouped) && b.main.selectAll(`.${l.shape}-${f}`).each(function () { c.select(this).classed(l.EXPANDED, !0), d.data_selection_enabled && g.style('cursor', d.data_selection_grouped ? 'pointer' : null), d.tooltip_grouped || (b.hideXGridFocus(), b.hideTooltip(), d.data_selection_grouped || (b.unexpandCircles(f), b.unexpandBars(f))); }).filter(function (a) { return b.isWithinShape(this, a); }).each(function (a) { d.data_selection_enabled && (d.data_selection_grouped || d.data_selection_isselectable(a)) && g.style('cursor', 'pointer'), d.tooltip_grouped || (b.showTooltip([a], this), b.showXGridFocus([a]), d.point_focus_expand_enabled && b.expandCircles(f, a.id, !0), b.expandBars(f, a.id, !0)); })); })
      .on('click', function (a) { let e = a.index; if (!b.hasArcType() && b.toggleShape) { if (b.cancelClick) return void (b.cancelClick = !1); b.isStepType(a) && d.line_step_type === 'step-after' && c.mouse(this)[0] < b.x(b.getXValue(a.id, e)) && (e -= 1), b.main.selectAll(`.${l.shape}-${e}`).each(function (a) { (d.data_selection_grouped || b.isWithinShape(this, a)) && (b.toggleShape(this, a, e), b.config.data_onclick.call(b.api, a, this)); }); } })
      .call(d.data_selection_draggable && b.drag ? c.behavior.drag().origin(Object).on('drag', function () { b.drag(c.mouse(this)); }).on('dragstart', function () { b.dragstart(c.mouse(this)); })
        .on('dragend', () => { b.dragend(); }) : () => {});
  }, i.generateEventRectsForMultipleXs = function (a) {
    function b() { c.svg.select(`.${l.eventRect}`).style('cursor', null), c.hideXGridFocus(), c.hideTooltip(), c.unexpandCircles(), c.unexpandBars(); } var c = this; const d = c.d3; const e = c.config; a.append('rect').attr('x', 0).attr('y', 0).attr('width', c.width)
      .attr('height', c.height)
      .attr('class', l.eventRect)
      .on('mouseout', () => { c.config && (c.hasArcType() || b()); })
      .on('mousemove', function () { let a; let f; let g; let h; const i = c.filterTargetsToShow(c.data.targets); if (!c.dragging && !c.hasArcType(i)) { if (a = d.mouse(this), f = c.findClosestFromTargets(i, a), !c.mouseover || f && f.id === c.mouseover.id || (e.data_onmouseout.call(c.api, c.mouseover), c.mouseover = void 0), !f) return void b(); g = c.isScatterType(f) || !e.tooltip_grouped ? [f] : c.filterByX(i, f.x), h = g.map((a) => c.addName(a)), c.showTooltip(h, this), e.point_focus_expand_enabled && c.expandCircles(f.index, f.id, !0), c.expandBars(f.index, f.id, !0), c.showXGridFocus(h), (c.isBarType(f.id) || c.dist(f, a) < e.point_sensitivity) && (c.svg.select(`.${l.eventRect}`).style('cursor', 'pointer'), c.mouseover || (e.data_onmouseover.call(c.api, f), c.mouseover = f)); } })
      .on('click', function () { let a; let b; const f = c.filterTargetsToShow(c.data.targets); c.hasArcType(f) || (a = d.mouse(this), b = c.findClosestFromTargets(f, a), b && (c.isBarType(b.id) || c.dist(b, a) < e.point_sensitivity) && c.main.selectAll(`.${l.shapes}${c.getTargetSelectorSuffix(b.id)}`).selectAll(`.${l.shape}-${b.index}`).each(function () { (e.data_selection_grouped || c.isWithinShape(this, b)) && (c.toggleShape(this, b, b.index), c.config.data_onclick.call(c.api, b, this)); })); })
      .call(e.data_selection_draggable && c.drag ? d.behavior.drag().origin(Object).on('drag', function () { c.drag(d.mouse(this)); }).on('dragstart', function () { c.dragstart(d.mouse(this)); })
        .on('dragend', () => { c.dragend(); }) : () => {});
  }, i.dispatchEvent = function (b, c, d) { const e = this; const f = `.${l.eventRect}${e.isMultipleX() ? '' : `-${c}`}`; const g = e.main.select(f).node(); const h = g.getBoundingClientRect(); const i = h.left + (d ? d[0] : 0); const j = h.top + (d ? d[1] : 0); const k = document.createEvent('MouseEvents'); k.initMouseEvent(b, !0, !0, a, 0, i, j, i, j, !1, !1, !1, !1, 0, null), g.dispatchEvent(k); }, i.getCurrentWidth = function () { const a = this; const b = a.config; return b.size_width ? b.size_width : a.getParentWidth(); }, i.getCurrentHeight = function () { const a = this; const b = a.config; const c = b.size_height ? b.size_height : a.getParentHeight(); return c > 0 ? c : 320 / (a.hasType('gauge') && !b.gauge_fullCircle ? 2 : 1); }, i.getCurrentPaddingTop = function () { const a = this; const b = a.config; let c = m(b.padding_top) ? b.padding_top : 0; return a.title && a.title.node() && (c += a.getTitlePadding()), c; }, i.getCurrentPaddingBottom = function () { const a = this.config; return m(a.padding_bottom) ? a.padding_bottom : 0; }, i.getCurrentPaddingLeft = function (a) { const b = this; const c = b.config; return m(c.padding_left) ? c.padding_left : c.axis_rotated ? c.axis_x_show ? Math.max(r(b.getAxisWidthByAxisId('x', a)), 40) : 1 : !c.axis_y_show || c.axis_y_inner ? b.axis.getYAxisLabelPosition().isOuter ? 30 : 1 : r(b.getAxisWidthByAxisId('y', a)); }, i.getCurrentPaddingRight = function () { const a = this; const b = a.config; const c = 10; const d = a.isLegendRight ? a.getLegendWidth() + 20 : 0; return m(b.padding_right) ? b.padding_right + 1 : b.axis_rotated ? c + d : !b.axis_y2_show || b.axis_y2_inner ? 2 + d + (a.axis.getY2AxisLabelPosition().isOuter ? 20 : 0) : r(a.getAxisWidthByAxisId('y2')) + d; }, i.getParentRectValue = function (a) { for (var b, c = this.selectChart.node(); c && c.tagName !== 'BODY';) { try { b = c.getBoundingClientRect()[a]; } catch (d) { a === 'width' && (b = c.offsetWidth); } if (b) break; c = c.parentNode; } return b; }, i.getParentWidth = function () { return this.getParentRectValue('width'); }, i.getParentHeight = function () { const a = this.selectChart.style('height'); return a.indexOf('px') > 0 ? +a.replace('px', '') : 0; }, i.getSvgLeft = function (a) { const b = this; const c = b.config; const d = c.axis_rotated || !c.axis_rotated && !c.axis_y_inner; const e = c.axis_rotated ? l.axisX : l.axisY; const f = b.main.select(`.${e}`).node(); const g = f && d ? f.getBoundingClientRect() : { right: 0 }; const h = b.selectChart.node().getBoundingClientRect(); const i = b.hasArcType(); const j = g.right - h.left - (i ? 0 : b.getCurrentPaddingLeft(a)); return j > 0 ? j : 0; }, i.getAxisWidthByAxisId = function (a, b) { const c = this; const d = c.axis.getLabelPositionById(a); return c.axis.getMaxTickWidth(a, b) + (d.isInner ? 20 : 40); }, i.getHorizontalAxisHeight = function (a) { const b = this; const c = b.config; let d = 30; return a !== 'x' || c.axis_x_show ? a === 'x' && c.axis_x_height ? c.axis_x_height : a !== 'y' || c.axis_y_show ? a !== 'y2' || c.axis_y2_show ? (a === 'x' && !c.axis_rotated && c.axis_x_tick_rotate && (d = 30 + b.axis.getMaxTickWidth(a) * Math.cos(Math.PI * (90 - c.axis_x_tick_rotate) / 180)), a === 'y' && c.axis_rotated && c.axis_y_tick_rotate && (d = 30 + b.axis.getMaxTickWidth(a) * Math.cos(Math.PI * (90 - c.axis_y_tick_rotate) / 180)), d + (b.axis.getLabelPositionById(a).isInner ? 0 : 10) + (a === 'y2' ? -10 : 0)) : b.rotated_padding_top : !c.legend_show || b.isLegendRight || b.isLegendInset ? 1 : 10 : 8; }, i.getEventRectWidth = function () { return Math.max(0, this.xAxis.tickInterval()); }, i.getShapeIndices = function (a) { let b; let c; const d = this; const e = d.config; const f = {}; let g = 0; return d.filterTargetsToShow(d.data.targets.filter(a, d)).forEach((a) => { for (b = 0; b < e.data_groups.length; b++) if (!(e.data_groups[b].indexOf(a.id) < 0)) for (c = 0; c < e.data_groups[b].length; c++) if (e.data_groups[b][c] in f) { f[a.id] = f[e.data_groups[b][c]]; break; }p(f[a.id]) && (f[a.id] = g++); }), f.__max__ = g - 1, f; }, i.getShapeX = function (a, b, c, d) { const e = this; const f = d ? e.subX : e.x; return function (d) { const e = d.id in c ? c[d.id] : 0; return d.x || d.x === 0 ? f(d.x) - a * (b / 2 - e) : 0; }; }, i.getShapeY = function (a) { const b = this; return function (c) { const d = a ? b.getSubYScale(c.id) : b.getYScale(c.id); return d(c.value); }; }, i.getShapeOffset = function (a, b, c) { const d = this; const e = d.orderTargets(d.filterTargetsToShow(d.data.targets.filter(a, d))); const f = e.map((a) => a.id); return function (a, g) { const h = c ? d.getSubYScale(a.id) : d.getYScale(a.id); const i = h(0); let j = i; return e.forEach((c) => { const e = d.isStepType(a) ? d.convertValuesToStep(c.values) : c.values; c.id !== a.id && b[c.id] === b[a.id] && f.indexOf(c.id) < f.indexOf(a.id) && (typeof e[g] !== 'undefined' && +e[g].x === +a.x || (g = -1, e.forEach((b, c) => { b.x === a.x && (g = c); })), g in e && e[g].value * a.value >= 0 && (j += h(e[g].value) - i)); }), j; }; }, i.isWithinShape = function (a, b) { let c; const d = this; const e = d.d3.select(a); return d.isTargetToShow(b.id) ? a.nodeName === 'circle' ? c = d.isStepType(b) ? d.isWithinStep(a, d.getYScale(b.id)(b.value)) : d.isWithinCircle(a, 1.5 * d.pointSelectR(b)) : a.nodeName === 'path' && (c = e.classed(l.bar) ? d.isWithinBar(a) : !0) : c = !1, c; }, i.getInterpolate = function (a) { const b = this; const c = b.isInterpolationType(b.config.spline_interpolation_type) ? b.config.spline_interpolation_type : 'cardinal'; return b.isSplineType(a) ? c : b.isStepType(a) ? b.config.line_step_type : 'linear'; }, i.initLine = function () { const a = this; a.main.select(`.${l.chart}`).append('g').attr('class', l.chartLines); }, i.updateTargetsForLine = function (a) {
    let b; let c; const d = this; const e = d.config; const f = d.classChartLine.bind(d); const g = d.classLines.bind(d); const h = d.classAreas.bind(d); const i = d.classCircles.bind(d); const j = d.classFocus.bind(d); b = d.main.select(`.${l.chartLines}`).selectAll(`.${l.chartLine}`).data(a).attr('class', (a) => f(a) + j(a)), c = b.enter().append('g').attr('class', f).style('opacity', 0)
      .style('pointer-events', 'none'), c.append('g').attr('class', g), c.append('g').attr('class', h), c.append('g').attr('class', (a) => d.generateClass(l.selectedCircles, a.id)), c.append('g').attr('class', i).style('cursor', (a) => (e.data_selection_isselectable(a) ? 'pointer' : null)), a.forEach((a) => { d.main.selectAll(`.${l.selectedCircles}${d.getTargetSelectorSuffix(a.id)}`).selectAll(`.${l.selectedCircle}`).each((b) => { b.value = a.values[b.index].value; }); });
  }, i.updateLine = function (a) {
    const b = this; b.mainLine = b.main.selectAll(`.${l.lines}`).selectAll(`.${l.line}`).data(b.lineData.bind(b)), b.mainLine.enter().append('path').attr('class', b.classLine.bind(b)).style('stroke', b.color), b.mainLine.style('opacity', b.initialOpacity.bind(b)).style('shape-rendering', (a) => (b.isStepType(a) ? 'crispEdges' : '')).attr('transform', null), b.mainLine.exit().transition().duration(a).style('opacity', 0)
      .remove();
  }, i.redrawLine = function (a, b) { return [(b ? this.mainLine.transition(Math.random().toString()) : this.mainLine).attr('d', a).style('stroke', this.color).style('opacity', 1)]; }, i.generateDrawLine = function (a, b) { const c = this; const d = c.config; let e = c.d3.svg.line(); const f = c.generateGetLinePoints(a, b); const g = b ? c.getSubYScale : c.getYScale; const h = function (a) { return (b ? c.subxx : c.xx).call(c, a); }; const i = function (a, b) { return d.data_groups.length > 0 ? f(a, b)[0][1] : g.call(c, a.id)(a.value); }; return e = d.axis_rotated ? e.x(i).y(h) : e.x(h).y(i), d.line_connectNull || (e = e.defined((a) => a.value != null)), function (a) { let f; let h = d.line_connectNull ? c.filterRemoveNull(a.values) : a.values; const i = b ? c.x : c.subX; const j = g.call(c, a.id); let k = 0; let l = 0; return c.isLineType(a) ? d.data_regions[a.id] ? f = c.lineWithRegions(h, i, j, d.data_regions[a.id]) : (c.isStepType(a) && (h = c.convertValuesToStep(h)), f = e.interpolate(c.getInterpolate(a))(h)) : (h[0] && (k = i(h[0].x), l = j(h[0].value)), f = d.axis_rotated ? `M ${l} ${k}` : `M ${k} ${l}`), f || 'M 0 0'; }; }, i.generateGetLinePoints = function (a, b) { const c = this; const d = c.config; const e = a.__max__ + 1; const f = c.getShapeX(0, e, a, !!b); const g = c.getShapeY(!!b); const h = c.getShapeOffset(c.isLineType, a, !!b); const i = b ? c.getSubYScale : c.getYScale; return function (a, b) { const e = i.call(c, a.id)(0); const j = h(a, b) || e; const k = f(a); let l = g(a); return d.axis_rotated && (a.value > 0 && e > l || a.value < 0 && l > e) && (l = e), [[k, l - (e - j)], [k, l - (e - j)], [k, l - (e - j)], [k, l - (e - j)]]; }; }, i.lineWithRegions = function (a, b, c, d) { function e(a, b) { let c; for (c = 0; c < b.length; c++) if (b[c].start < a && a <= b[c].end) return !0; return !1; } function f(a) { return `M${a[0][0]} ${a[0][1]} ${a[1][0]} ${a[1][1]}`; } let g; let h; let i; let j; let k; let l; let m; let n; let o; let r; let s; let t; const u = this; const v = u.config; let w = -1; let x = 'M'; const y = u.isCategorized() ? 0.5 : 0; const z = []; if (q(d)) for (g = 0; g < d.length; g++)z[g] = {}, p(d[g].start) ? z[g].start = a[0].x : z[g].start = u.isTimeSeries() ? u.parseDate(d[g].start) : d[g].start, p(d[g].end) ? z[g].end = a[a.length - 1].x : z[g].end = u.isTimeSeries() ? u.parseDate(d[g].end) : d[g].end; for (s = v.axis_rotated ? function (a) { return c(a.value); } : function (a) { return b(a.x); }, t = v.axis_rotated ? function (a) { return b(a.x); } : function (a) { return c(a.value); }, i = u.isTimeSeries() ? function (a, d, e, g) { let h; const i = a.x.getTime(); const j = d.x - a.x; const l = new Date(i + j * e); const m = new Date(i + j * (e + g)); return h = v.axis_rotated ? [[c(k(e)), b(l)], [c(k(e + g)), b(m)]] : [[b(l), c(k(e))], [b(m), c(k(e + g))]], f(h); } : function (a, d, e, g) { let h; return h = v.axis_rotated ? [[c(k(e), !0), b(j(e))], [c(k(e + g), !0), b(j(e + g))]] : [[b(j(e), !0), c(k(e))], [b(j(e + g), !0), c(k(e + g))]], f(h); }, g = 0; g < a.length; g++) { if (p(z) || !e(a[g].x, z))x += ` ${s(a[g])} ${t(a[g])}`; else for (j = u.getScale(a[g - 1].x + y, a[g].x + y, u.isTimeSeries()), k = u.getScale(a[g - 1].value, a[g].value), l = b(a[g].x) - b(a[g - 1].x), m = c(a[g].value) - c(a[g - 1].value), n = Math.sqrt(Math.pow(l, 2) + Math.pow(m, 2)), o = 2 / n, r = 2 * o, h = o; h <= 1; h += r)x += i(a[g - 1], a[g], h, o); w = a[g].x; } return x; }, i.updateArea = function (a) {
    const b = this; const c = b.d3; b.mainArea = b.main.selectAll(`.${l.areas}`).selectAll(`.${l.area}`).data(b.lineData.bind(b)), b.mainArea.enter().append('path').attr('class', b.classArea.bind(b)).style('fill', b.color)
      .style('opacity', function () { return b.orgAreaOpacity = +c.select(this).style('opacity'), 0; }), b.mainArea.style('opacity', b.orgAreaOpacity), b.mainArea.exit().transition().duration(a).style('opacity', 0)
      .remove();
  }, i.redrawArea = function (a, b) { return [(b ? this.mainArea.transition(Math.random().toString()) : this.mainArea).attr('d', a).style('fill', this.color).style('opacity', this.orgAreaOpacity)]; }, i.generateDrawArea = function (a, b) { const c = this; const d = c.config; let e = c.d3.svg.area(); const f = c.generateGetAreaPoints(a, b); const g = b ? c.getSubYScale : c.getYScale; const h = function (a) { return (b ? c.subxx : c.xx).call(c, a); }; const i = function (a, b) { return d.data_groups.length > 0 ? f(a, b)[0][1] : g.call(c, a.id)(c.getAreaBaseValue(a.id)); }; const j = function (a, b) { return d.data_groups.length > 0 ? f(a, b)[1][1] : g.call(c, a.id)(a.value); }; return e = d.axis_rotated ? e.x0(i).x1(j).y(h) : e.x(h).y0(d.area_above ? 0 : i).y1(j), d.line_connectNull || (e = e.defined((a) => a.value !== null)), function (a) { let b; let f = d.line_connectNull ? c.filterRemoveNull(a.values) : a.values; let g = 0; let h = 0; return c.isAreaType(a) ? (c.isStepType(a) && (f = c.convertValuesToStep(f)), b = e.interpolate(c.getInterpolate(a))(f)) : (f[0] && (g = c.x(f[0].x), h = c.getYScale(a.id)(f[0].value)), b = d.axis_rotated ? `M ${h} ${g}` : `M ${g} ${h}`), b || 'M 0 0'; }; }, i.getAreaBaseValue = function () { return 0; }, i.generateGetAreaPoints = function (a, b) { const c = this; const d = c.config; const e = a.__max__ + 1; const f = c.getShapeX(0, e, a, !!b); const g = c.getShapeY(!!b); const h = c.getShapeOffset(c.isAreaType, a, !!b); const i = b ? c.getSubYScale : c.getYScale; return function (a, b) { const e = i.call(c, a.id)(0); const j = h(a, b) || e; const k = f(a); let l = g(a); return d.axis_rotated && (a.value > 0 && e > l || a.value < 0 && l > e) && (l = e), [[k, j], [k, l - (e - j)], [k, l - (e - j)], [k, j]]; }; }, i.updateCircle = function () {
    const a = this; a.mainCircle = a.main.selectAll(`.${l.circles}`).selectAll(`.${l.circle}`).data(a.lineOrScatterData.bind(a)), a.mainCircle.enter().append('circle').attr('class', a.classCircle.bind(a)).attr('r', a.pointR.bind(a))
      .style('fill', a.color), a.mainCircle.style('opacity', a.initialOpacityForCircle.bind(a)), a.mainCircle.exit().remove();
  }, i.redrawCircle = function (a, b, c) { const d = this.main.selectAll(`.${l.selectedCircle}`); return [(c ? this.mainCircle.transition(Math.random().toString()) : this.mainCircle).style('opacity', this.opacityForCircle.bind(this)).style('fill', this.color).attr('cx', a).attr('cy', b), (c ? d.transition(Math.random().toString()) : d).attr('cx', a).attr('cy', b)]; }, i.circleX = function (a) { return a.x || a.x === 0 ? this.x(a.x) : null; }, i.updateCircleY = function () { let a; let b; const c = this; c.config.data_groups.length > 0 ? (a = c.getShapeIndices(c.isLineType), b = c.generateGetLinePoints(a), c.circleY = function (a, c) { return b(a, c)[0][1]; }) : c.circleY = function (a) { return c.getYScale(a.id)(a.value); }; }, i.getCircles = function (a, b) { const c = this; return (b ? c.main.selectAll(`.${l.circles}${c.getTargetSelectorSuffix(b)}`) : c.main).selectAll(`.${l.circle}${m(a) ? `-${a}` : ''}`); }, i.expandCircles = function (a, b, c) { const d = this; const e = d.pointExpandedR.bind(d); c && d.unexpandCircles(), d.getCircles(a, b).classed(l.EXPANDED, !0).attr('r', e); }, i.unexpandCircles = function (a) { const b = this; const c = b.pointR.bind(b); b.getCircles(a).filter(function () { return b.d3.select(this).classed(l.EXPANDED); }).classed(l.EXPANDED, !1).attr('r', c); }, i.pointR = function (a) {
    const b = this; const c = b.config; return b.isStepType(a) ? 0 : n(c.point_r) ? c.point_r(a) : c.point_r;
  }, i.pointExpandedR = function (a) { const b = this; const c = b.config; return c.point_focus_expand_enabled ? c.point_focus_expand_r ? c.point_focus_expand_r : 1.75 * b.pointR(a) : b.pointR(a); }, i.pointSelectR = function (a) { const b = this; const c = b.config; return n(c.point_select_r) ? c.point_select_r(a) : c.point_select_r ? c.point_select_r : 4 * b.pointR(a); }, i.isWithinCircle = function (a, b) { const c = this.d3; const d = c.mouse(a); const e = c.select(a); const f = +e.attr('cx'); const g = +e.attr('cy'); return Math.sqrt(Math.pow(f - d[0], 2) + Math.pow(g - d[1], 2)) < b; }, i.isWithinStep = function (a, b) { return Math.abs(b - this.d3.mouse(a)[1]) < 30; }, i.initBar = function () { const a = this; a.main.select(`.${l.chart}`).append('g').attr('class', l.chartBars); }, i.updateTargetsForBar = function (a) {
    let b; let c; const d = this; const e = d.config; const f = d.classChartBar.bind(d); const g = d.classBars.bind(d); const h = d.classFocus.bind(d); b = d.main.select(`.${l.chartBars}`).selectAll(`.${l.chartBar}`).data(a).attr('class', (a) => f(a) + h(a)), c = b.enter().append('g').attr('class', f).style('opacity', 0)
      .style('pointer-events', 'none'), c.append('g').attr('class', g).style('cursor', (a) => (e.data_selection_isselectable(a) ? 'pointer' : null));
  }, i.updateBar = function (a) {
    const b = this; const c = b.barData.bind(b); const d = b.classBar.bind(b); const e = b.initialOpacity.bind(b); const f = function (a) { return b.color(a.id); }; b.mainBar = b.main.selectAll(`.${l.bars}`).selectAll(`.${l.bar}`).data(c), b.mainBar.enter().append('path').attr('class', d).style('stroke', f)
      .style('fill', f), b.mainBar.style('opacity', e), b.mainBar.exit().transition().duration(a).style('opacity', 0)
      .remove();
  }, i.redrawBar = function (a, b) { return [(b ? this.mainBar.transition(Math.random().toString()) : this.mainBar).attr('d', a).style('fill', this.color).style('opacity', 1)]; }, i.getBarW = function (a, b) { const c = this; const d = c.config; const e = typeof d.bar_width === 'number' ? d.bar_width : b ? a.tickInterval() * d.bar_width_ratio / b : 0; return d.bar_width_max && e > d.bar_width_max ? d.bar_width_max : e; }, i.getBars = function (a, b) { const c = this; return (b ? c.main.selectAll(`.${l.bars}${c.getTargetSelectorSuffix(b)}`) : c.main).selectAll(`.${l.bar}${m(a) ? `-${a}` : ''}`); }, i.expandBars = function (a, b, c) { const d = this; c && d.unexpandBars(), d.getBars(a, b).classed(l.EXPANDED, !0); }, i.unexpandBars = function (a) { const b = this; b.getBars(a).classed(l.EXPANDED, !1); }, i.generateDrawBar = function (a, b) { const c = this; const d = c.config; const e = c.generateGetBarPoints(a, b); return function (a, b) { const c = e(a, b); const f = d.axis_rotated ? 1 : 0; const g = d.axis_rotated ? 0 : 1; const h = `M ${c[0][f]},${c[0][g]} L${c[1][f]},${c[1][g]} L${c[2][f]},${c[2][g]} L${c[3][f]},${c[3][g]} z`; return h; }; }, i.generateGetBarPoints = function (a, b) { const c = this; const d = b ? c.subXAxis : c.xAxis; const e = a.__max__ + 1; const f = c.getBarW(d, e); const g = c.getShapeX(f, e, a, !!b); const h = c.getShapeY(!!b); const i = c.getShapeOffset(c.isBarType, a, !!b); const j = b ? c.getSubYScale : c.getYScale; return function (a, b) { const d = j.call(c, a.id)(0); const e = i(a, b) || d; const k = g(a); let l = h(a); return c.config.axis_rotated && (a.value > 0 && d > l || a.value < 0 && l > d) && (l = d), [[k, e], [k, l - (d - e)], [k + f, l - (d - e)], [k + f, e]]; }; }, i.isWithinBar = function (a) { const b = this.d3.mouse(a); const c = a.getBoundingClientRect(); const d = a.pathSegList.getItem(0); const e = a.pathSegList.getItem(1); const f = Math.min(d.x, e.x); const g = Math.min(d.y, e.y); const h = c.width; const i = c.height; const j = 2; const k = f - j; const l = f + h + j; const m = g + i + j; const n = g - j; return k < b[0] && b[0] < l && n < b[1] && b[1] < m; }, i.initText = function () { const a = this; a.main.select(`.${l.chart}`).append('g').attr('class', l.chartTexts), a.mainText = a.d3.selectAll([]); }, i.updateTargetsForText = function (a) {
    let b; let c; const d = this; const e = d.classChartText.bind(d); const f = d.classTexts.bind(d); const g = d.classFocus.bind(d); b = d.main.select(`.${l.chartTexts}`).selectAll(`.${l.chartText}`).data(a).attr('class', (a) => e(a) + g(a)), c = b.enter().append('g').attr('class', e).style('opacity', 0)
      .style('pointer-events', 'none'), c.append('g').attr('class', f);
  }, i.updateText = function (a) {
    const b = this; const c = b.config; const d = b.barOrLineData.bind(b); const e = b.classText.bind(b); b.mainText = b.main.selectAll(`.${l.texts}`).selectAll(`.${l.text}`).data(d), b.mainText.enter().append('text').attr('class', e).attr('text-anchor', (a) => (c.axis_rotated ? a.value < 0 ? 'end' : 'start' : 'middle'))
      .style('stroke', 'none')
      .style('fill', (a) => b.color(a))
      .style('fill-opacity', 0), b.mainText.text((a, c, d) => b.dataLabelFormat(a.id)(a.value, a.id, c, d)), b.mainText.exit().transition().duration(a).style('fill-opacity', 0)
      .remove();
  }, i.redrawText = function (a, b, c, d) { return [(d ? this.mainText.transition() : this.mainText).attr('x', a).attr('y', b).style('fill', this.color).style('fill-opacity', c ? 0 : this.opacityForText.bind(this))]; }, i.getTextRect = function (a, b, c) {
    let d; const e = this.d3.select('body').append('div').classed('c3', !0); const f = e.append('svg').style('visibility', 'hidden').style('position', 'fixed').style('top', 0)
      .style('left', 0); const g = this.d3.select(c).style('font'); return f.selectAll('.dummy').data([a]).enter().append('text')
      .classed(b || '', !0)
      .style('font', g)
      .text(a)
      .each(function () { d = this.getBoundingClientRect(); }), e.remove(), d;
  }, i.generateXYForText = function (a, b, c, d) { const e = this; const f = e.generateGetAreaPoints(a, !1); const g = e.generateGetBarPoints(b, !1); const h = e.generateGetLinePoints(c, !1); const i = d ? e.getXForText : e.getYForText; return function (a, b) { const c = e.isAreaType(a) ? f : e.isBarType(a) ? g : h; return i.call(e, c(a, b), a, this); }; }, i.getXForText = function (a, b, c) { let d; let e; const f = this; const g = c.getBoundingClientRect(); return f.config.axis_rotated ? (e = f.isBarType(b) ? 4 : 6, d = a[2][1] + e * (b.value < 0 ? -1 : 1)) : d = f.hasType('bar') ? (a[2][0] + a[0][0]) / 2 : a[0][0], b.value === null && (d > f.width ? d = f.width - g.width : d < 0 && (d = 4)), d; }, i.getYForText = function (a, b, c) { let d; const e = this; const f = c.getBoundingClientRect(); return e.config.axis_rotated ? d = (a[0][0] + a[2][0] + 0.6 * f.height) / 2 : (d = a[2][1], b.value < 0 || b.value === 0 && !e.hasPositiveValue ? (d += f.height, e.isBarType(b) && e.isSafari() ? d -= 3 : !e.isBarType(b) && e.isChrome() && (d += 3)) : d += e.isBarType(b) ? -3 : -6), b.value !== null || e.config.axis_rotated || (d < f.height ? d = f.height : d > this.height && (d = this.height - 4)), d; }, i.setTargetType = function (a, b) { const c = this; const d = c.config; c.mapToTargetIds(a).forEach((a) => { c.withoutFadeIn[a] = b === d.data_types[a], d.data_types[a] = b; }), a || (d.data_type = b); }, i.hasType = function (a, b) { const c = this; const d = c.config.data_types; let e = !1; return b = b || c.data.targets, b && b.length ? b.forEach((b) => { const c = d[b.id]; (c && c.indexOf(a) >= 0 || !c && a === 'line') && (e = !0); }) : Object.keys(d).length ? Object.keys(d).forEach((b) => { d[b] === a && (e = !0); }) : e = c.config.data_type === a, e; }, i.hasArcType = function (a) { return this.hasType('pie', a) || this.hasType('donut', a) || this.hasType('gauge', a); }, i.isLineType = function (a) { const b = this.config; const c = o(a) ? a : a.id; return !b.data_types[c] || ['line', 'spline', 'area', 'area-spline', 'step', 'area-step'].indexOf(b.data_types[c]) >= 0; }, i.isStepType = function (a) { const b = o(a) ? a : a.id; return ['step', 'area-step'].indexOf(this.config.data_types[b]) >= 0; }, i.isSplineType = function (a) { const b = o(a) ? a : a.id; return ['spline', 'area-spline'].indexOf(this.config.data_types[b]) >= 0; }, i.isAreaType = function (a) { const b = o(a) ? a : a.id; return ['area', 'area-spline', 'area-step'].indexOf(this.config.data_types[b]) >= 0; }, i.isBarType = function (a) { const b = o(a) ? a : a.id; return this.config.data_types[b] === 'bar'; }, i.isScatterType = function (a) { const b = o(a) ? a : a.id; return this.config.data_types[b] === 'scatter'; }, i.isPieType = function (a) { const b = o(a) ? a : a.id; return this.config.data_types[b] === 'pie'; }, i.isGaugeType = function (a) { const b = o(a) ? a : a.id; return this.config.data_types[b] === 'gauge'; }, i.isDonutType = function (a) { const b = o(a) ? a : a.id; return this.config.data_types[b] === 'donut'; }, i.isArcType = function (a) { return this.isPieType(a) || this.isDonutType(a) || this.isGaugeType(a); }, i.lineData = function (a) { return this.isLineType(a) ? [a] : []; }, i.arcData = function (a) { return this.isArcType(a.data) ? [a] : []; }, i.barData = function (a) { return this.isBarType(a) ? a.values : []; }, i.lineOrScatterData = function (a) { return this.isLineType(a) || this.isScatterType(a) ? a.values : []; }, i.barOrLineData = function (a) { return this.isBarType(a) || this.isLineType(a) ? a.values : []; }, i.isInterpolationType = function (a) { return ['linear', 'linear-closed', 'basis', 'basis-open', 'basis-closed', 'bundle', 'cardinal', 'cardinal-open', 'cardinal-closed', 'monotone'].indexOf(a) >= 0; }, i.initGrid = function () { const a = this; const b = a.config; const c = a.d3; a.grid = a.main.append('g').attr('clip-path', a.clipPathForGrid).attr('class', l.grid), b.grid_x_show && a.grid.append('g').attr('class', l.xgrids), b.grid_y_show && a.grid.append('g').attr('class', l.ygrids), b.grid_focus_show && a.grid.append('g').attr('class', l.xgridFocus).append('line').attr('class', l.xgridFocus), a.xgrid = c.selectAll([]), b.grid_lines_front || a.initGridLines(); }, i.initGridLines = function () { const a = this; const b = a.d3; a.gridLines = a.main.append('g').attr('clip-path', a.clipPathForGrid).attr('class', `${l.grid} ${l.gridLines}`), a.gridLines.append('g').attr('class', l.xgridLines), a.gridLines.append('g').attr('class', l.ygridLines), a.xgridLines = b.selectAll([]); }, i.updateXGrid = function (a) {
    const b = this; const c = b.config; const d = b.d3; const e = b.generateGridData(c.grid_x_type, b.x); const f = b.isCategorized() ? b.xAxis.tickOffset() : 0; b.xgridAttr = c.axis_rotated ? {
      x1: 0, x2: b.width, y1(a) { return b.x(a) - f; }, y2(a) { return b.x(a) - f; },
    } : {
      x1(a) { return b.x(a) + f; }, x2(a) { return b.x(a) + f; }, y1: 0, y2: b.height,
    }, b.xgrid = b.main.select(`.${l.xgrids}`).selectAll(`.${l.xgrid}`).data(e), b.xgrid.enter().append('line').attr('class', l.xgrid), a || b.xgrid.attr(b.xgridAttr).style('opacity', function () { return +d.select(this).attr(c.axis_rotated ? 'y1' : 'x1') === (c.axis_rotated ? b.height : 0) ? 0 : 1; }), b.xgrid.exit().remove();
  }, i.updateYGrid = function () { const a = this; const b = a.config; const c = a.yAxis.tickValues() || a.y.ticks(b.grid_y_ticks); a.ygrid = a.main.select(`.${l.ygrids}`).selectAll(`.${l.ygrid}`).data(c), a.ygrid.enter().append('line').attr('class', l.ygrid), a.ygrid.attr('x1', b.axis_rotated ? a.y : 0).attr('x2', b.axis_rotated ? a.y : a.width).attr('y1', b.axis_rotated ? 0 : a.y).attr('y2', b.axis_rotated ? a.height : a.y), a.ygrid.exit().remove(), a.smoothLines(a.ygrid, 'grid'); }, i.gridTextAnchor = function (a) { return a.position ? a.position : 'end'; }, i.gridTextDx = function (a) { return a.position === 'start' ? 4 : a.position === 'middle' ? 0 : -4; }, i.xGridTextX = function (a) { return a.position === 'start' ? -this.height : a.position === 'middle' ? -this.height / 2 : 0; }, i.yGridTextX = function (a) { return a.position === 'start' ? 0 : a.position === 'middle' ? this.width / 2 : this.width; }, i.updateGrid = function (a) {
    let b; let c; let d; const e = this; const f = e.main; const g = e.config; e.grid.style('visibility', e.hasArcType() ? 'hidden' : 'visible'), f.select(`line.${l.xgridFocus}`).style('visibility', 'hidden'), g.grid_x_show && e.updateXGrid(), e.xgridLines = f.select(`.${l.xgridLines}`).selectAll(`.${l.xgridLine}`).data(g.grid_x_lines), b = e.xgridLines.enter().append('g').attr('class', (a) => l.xgridLine + (a.class ? ` ${a.class}` : '')), b.append('line').style('opacity', 0), b.append('text').attr('text-anchor', e.gridTextAnchor).attr('transform', g.axis_rotated ? '' : 'rotate(-90)').attr('dx', e.gridTextDx)
      .attr('dy', -5)
      .style('opacity', 0), e.xgridLines.exit().transition().duration(a).style('opacity', 0)
      .remove(), g.grid_y_show && e.updateYGrid(), e.ygridLines = f.select(`.${l.ygridLines}`).selectAll(`.${l.ygridLine}`).data(g.grid_y_lines), c = e.ygridLines.enter().append('g').attr('class', (a) => l.ygridLine + (a.class ? ` ${a.class}` : '')), c.append('line').style('opacity', 0), c.append('text').attr('text-anchor', e.gridTextAnchor).attr('transform', g.axis_rotated ? 'rotate(-90)' : '').attr('dx', e.gridTextDx)
      .attr('dy', -5)
      .style('opacity', 0), d = e.yv.bind(e), e.ygridLines.select('line').transition().duration(a).attr('x1', g.axis_rotated ? d : 0)
      .attr('x2', g.axis_rotated ? d : e.width)
      .attr('y1', g.axis_rotated ? 0 : d)
      .attr('y2', g.axis_rotated ? e.height : d)
      .style('opacity', 1), e.ygridLines.select('text').transition().duration(a).attr('x', g.axis_rotated ? e.xGridTextX.bind(e) : e.yGridTextX.bind(e))
      .attr('y', d)
      .text((a) => a.text)
      .style('opacity', 1), e.ygridLines.exit().transition().duration(a).style('opacity', 0)
      .remove();
  }, i.redrawGrid = function (a) {
    const b = this; const c = b.config; const d = b.xv.bind(b); const e = b.xgridLines.select('line'); const f = b.xgridLines.select('text'); return [(a ? e.transition() : e).attr('x1', c.axis_rotated ? 0 : d).attr('x2', c.axis_rotated ? b.width : d).attr('y1', c.axis_rotated ? d : 0).attr('y2', c.axis_rotated ? d : b.height)
      .style('opacity', 1), (a ? f.transition() : f).attr('x', c.axis_rotated ? b.yGridTextX.bind(b) : b.xGridTextX.bind(b)).attr('y', d).text((a) => a.text).style('opacity', 1)];
  }, i.showXGridFocus = function (a) { const b = this; const c = b.config; const d = a.filter((a) => a && m(a.value)); const e = b.main.selectAll(`line.${l.xgridFocus}`); const f = b.xx.bind(b); c.tooltip_show && (b.hasType('scatter') || b.hasArcType() || (e.style('visibility', 'visible').data([d[0]]).attr(c.axis_rotated ? 'y1' : 'x1', f).attr(c.axis_rotated ? 'y2' : 'x2', f), b.smoothLines(e, 'grid'))); }, i.hideXGridFocus = function () { this.main.select(`line.${l.xgridFocus}`).style('visibility', 'hidden'); }, i.updateXgridFocus = function () {
    const a = this; const b = a.config; a.main.select(`line.${l.xgridFocus}`).attr('x1', b.axis_rotated ? 0 : -10).attr('x2', b.axis_rotated ? a.width : -10).attr('y1', b.axis_rotated ? -10 : 0)
      .attr('y2', b.axis_rotated ? -10 : a.height);
  }, i.generateGridData = function (a, b) { let c; let d; let e; let f; const g = this; let h = []; const i = g.main.select(`.${l.axisX}`).selectAll('.tick').size(); if (a === 'year') for (c = g.getXDomain(), d = c[0].getFullYear(), e = c[1].getFullYear(), f = d; e >= f; f++)h.push(new Date(`${f}-01-01 00:00:00`)); else h = b.ticks(10), h.length > i && (h = h.filter((a) => (`${a}`).indexOf('.') < 0)); return h; }, i.getGridFilterToRemove = function (a) { return a ? function (b) { let c = !1; return [].concat(a).forEach((a) => { ('value' in a && b.value === a.value || 'class' in a && b.class === a.class) && (c = !0); }), c; } : function () { return !0; }; }, i.removeGridLines = function (a, b) {
    const c = this; const d = c.config; const e = c.getGridFilterToRemove(a); const f = function (a) { return !e(a); }; const g = b ? l.xgridLines : l.ygridLines; const h = b ? l.xgridLine : l.ygridLine; c.main.select(`.${g}`).selectAll(`.${h}`).filter(e).transition()
      .duration(d.transition_duration)
      .style('opacity', 0)
      .remove(), b ? d.grid_x_lines = d.grid_x_lines.filter(f) : d.grid_y_lines = d.grid_y_lines.filter(f);
  }, i.initTooltip = function () {
    let a; const b = this; const c = b.config; if (b.tooltip = b.selectChart.style('position', 'relative').append('div').attr('class', l.tooltipContainer).style('position', 'absolute')
      .style('pointer-events', 'none')
      .style('display', 'none'), c.tooltip_init_show) { if (b.isTimeSeries() && o(c.tooltip_init_x)) { for (c.tooltip_init_x = b.parseDate(c.tooltip_init_x), a = 0; a < b.data.targets[0].values.length && b.data.targets[0].values[a].x - c.tooltip_init_x !== 0; a++);c.tooltip_init_x = a; }b.tooltip.html(c.tooltip_contents.call(b, b.data.targets.map((a) => b.addName(a.values[c.tooltip_init_x])), b.axis.getXAxisTickFormat(), b.getYFormat(b.hasArcType()), b.color)), b.tooltip.style('top', c.tooltip_init_position.top).style('left', c.tooltip_init_position.left).style('display', 'block'); }
  }, i.getTooltipContent = function (a, b, c, d) { let e; let f; let g; let h; let i; let j; const k = this; const l = k.config; const m = l.tooltip_format_title || b; const n = l.tooltip_format_name || function (a) { return a; }; const o = l.tooltip_format_value || c; const p = k.isOrderAsc(); if (l.data_groups.length === 0)a.sort((a, b) => { const c = a ? a.value : null; const d = b ? b.value : null; return p ? c - d : d - c; }); else { const q = k.orderTargets(k.data.targets).map((a) => a.id); a.sort((a, b) => { let c = a ? a.value : null; let d = b ? b.value : null; return c > 0 && d > 0 && (c = a ? q.indexOf(a.id) : null, d = b ? q.indexOf(b.id) : null), p ? c - d : d - c; }); } for (f = 0; f < a.length; f++) if (a[f] && (a[f].value || a[f].value === 0) && (e || (g = y(m ? m(a[f].x) : a[f].x), e = `<table class='${k.CLASS.tooltip}'>${g || g === 0 ? `<tr><th colspan='2'>${g}</th></tr>` : ''}`), h = y(o(a[f].value, a[f].ratio, a[f].id, a[f].index, a)), void 0 !== h)) { if (a[f].name === null) continue; i = y(n(a[f].name, a[f].ratio, a[f].id, a[f].index)), j = k.levelColor ? k.levelColor(a[f].value) : d(a[f].id), e += `<tr class='${k.CLASS.tooltipName}-${k.getTargetSelectorSuffix(a[f].id)}'>`, e += `<td class='name'><span style='background-color:${j}'></span>${i}</td>`, e += `<td class='value'>${h}</td>`, e += '</tr>'; } return `${e}</table>`; }, i.tooltipPosition = function (a, b, c, d) { let e; let f; let g; let h; let i; const j = this; const k = j.config; const l = j.d3; const m = j.hasArcType(); const n = l.mouse(d); return m ? (f = (j.width - (j.isLegendRight ? j.getLegendWidth() : 0)) / 2 + n[0], h = j.height / 2 + n[1] + 20) : (e = j.getSvgLeft(!0), k.axis_rotated ? (f = e + n[0] + 100, g = f + b, i = j.currentWidth - j.getCurrentPaddingRight(), h = j.x(a[0].x) + 20) : (f = e + j.getCurrentPaddingLeft(!0) + j.x(a[0].x) + 20, g = f + b, i = e + j.currentWidth - j.getCurrentPaddingRight(), h = n[1] + 15), g > i && (f -= g - i + 20), h + c > j.currentHeight && (h -= c + 30)), h < 0 && (h = 0), { top: h, left: f }; }, i.showTooltip = function (a, b) { let c; let d; let e; const f = this; const g = f.config; const h = f.hasArcType(); const j = a.filter((a) => a && m(a.value)); const k = g.tooltip_position || i.tooltipPosition; j.length !== 0 && g.tooltip_show && (f.tooltip.html(g.tooltip_contents.call(f, a, f.axis.getXAxisTickFormat(), f.getYFormat(h), f.color)).style('display', 'block'), c = f.tooltip.property('offsetWidth'), d = f.tooltip.property('offsetHeight'), e = k.call(this, j, c, d, b), f.tooltip.style('top', `${e.top}px`).style('left', `${e.left}px`)); }, i.hideTooltip = function () { this.tooltip.style('display', 'none'); }, i.initLegend = function () { const a = this; return a.legendItemTextBox = {}, a.legendHasRendered = !1, a.legend = a.svg.append('g').attr('transform', a.getTranslate('legend')), a.config.legend_show ? void a.updateLegendWithDefaults() : (a.legend.style('visibility', 'hidden'), void (a.hiddenLegendIds = a.mapToIds(a.data.targets))); }, i.updateLegendWithDefaults = function () { const a = this; a.updateLegend(a.mapToIds(a.data.targets), { withTransform: !1, withTransitionForTransform: !1, withTransition: !1 }); }, i.updateSizeForLegend = function (a, b) {
    const c = this; const d = c.config; const e = { top: c.isLegendTop ? c.getCurrentPaddingTop() + d.legend_inset_y + 5.5 : c.currentHeight - a - c.getCurrentPaddingBottom() - d.legend_inset_y, left: c.isLegendLeft ? c.getCurrentPaddingLeft() + d.legend_inset_x + 0.5 : c.currentWidth - b - c.getCurrentPaddingRight() - d.legend_inset_x + 0.5 }; c.margin3 = {
      top: c.isLegendRight ? 0 : c.isLegendInset ? e.top : c.currentHeight - a, right: NaN, bottom: 0, left: c.isLegendRight ? c.currentWidth - b : c.isLegendInset ? e.left : 0,
    };
  }, i.transformLegend = function (a) { const b = this; (a ? b.legend.transition() : b.legend).attr('transform', b.getTranslate('legend')); }, i.updateLegendStep = function (a) { this.legendStep = a; }, i.updateLegendItemWidth = function (a) { this.legendItemWidth = a; }, i.updateLegendItemHeight = function (a) { this.legendItemHeight = a; }, i.getLegendWidth = function () { const a = this; return a.config.legend_show ? a.isLegendRight || a.isLegendInset ? a.legendItemWidth * (a.legendStep + 1) : a.currentWidth : 0; }, i.getLegendHeight = function () { const a = this; let b = 0; return a.config.legend_show && (b = a.isLegendRight ? a.currentHeight : Math.max(20, a.legendItemHeight) * (a.legendStep + 1)), b; }, i.opacityForLegend = function (a) { return a.classed(l.legendItemHidden) ? null : 1; }, i.opacityForUnfocusedLegend = function (a) { return a.classed(l.legendItemHidden) ? null : 0.3; }, i.toggleFocusLegend = function (a, b) {
    const c = this; a = c.mapToTargetIds(a), c.legend.selectAll(`.${l.legendItem}`).filter((b) => a.indexOf(b) >= 0).classed(l.legendItemFocused, b).transition()
      .duration(100)
      .style('opacity', function () { const a = b ? c.opacityForLegend : c.opacityForUnfocusedLegend; return a.call(c, c.d3.select(this)); });
  }, i.revertLegend = function () {
    const a = this; const b = a.d3; a.legend.selectAll(`.${l.legendItem}`).classed(l.legendItemFocused, !1).transition().duration(100)
      .style('opacity', function () { return a.opacityForLegend(b.select(this)); });
  }, i.showLegend = function (a) { const b = this; const c = b.config; c.legend_show || (c.legend_show = !0, b.legend.style('visibility', 'visible'), b.legendHasRendered || b.updateLegendWithDefaults()), b.removeHiddenLegendIds(a), b.legend.selectAll(b.selectorLegends(a)).style('visibility', 'visible').transition().style('opacity', function () { return b.opacityForLegend(b.d3.select(this)); }); }, i.hideLegend = function (a) { const b = this; const c = b.config; c.legend_show && u(a) && (c.legend_show = !1, b.legend.style('visibility', 'hidden')), b.addHiddenLegendIds(a), b.legend.selectAll(b.selectorLegends(a)).style('opacity', 0).style('visibility', 'hidden'); }, i.clearLegendItemTextBoxCache = function () { this.legendItemTextBox = {}; }, i.updateLegend = function (a, b, c) {
    function d(a, b) { return y.legendItemTextBox[b] || (y.legendItemTextBox[b] = y.getTextRect(a.textContent, l.legendItem, a)), y.legendItemTextBox[b]; } function e(b, c, e) { function f(a, b) { b || (g = (o - G - n) / 2, E > g && (g = (o - n) / 2, G = 0, M++)), L[a] = M, K[M] = y.isLegendInset ? 10 : g, H[a] = G, G += n; } let g; let h; const i = e === 0; const j = e === a.length - 1; const k = d(b, c); const l = k.width + F + (!j || y.isLegendRight || y.isLegendInset ? B : 0) + z.legend_padding; const m = k.height + A; var n = y.isLegendRight || y.isLegendInset ? m : l; var o = y.isLegendRight || y.isLegendInset ? y.getLegendHeight() : y.getLegendWidth(); return i && (G = 0, M = 0, C = 0, D = 0), z.legend_show && !y.isLegendToShow(c) ? void (I[c] = J[c] = L[c] = H[c] = 0) : (I[c] = l, J[c] = m, (!C || l >= C) && (C = l), (!D || m >= D) && (D = m), h = y.isLegendRight || y.isLegendInset ? D : C, void (z.legend_equally ? (Object.keys(I).forEach((a) => { I[a] = C; }), Object.keys(J).forEach((a) => { J[a] = D; }), g = (o - h * a.length) / 2, E > g ? (G = 0, M = 0, a.forEach((a) => { f(a); })) : f(c, !0)) : f(c))); } let f; let g; let h; let i; let j; let k; let m; let n; let o; let p; let r; let s; let t; let u; let v; let x; var y = this; var z = y.config; var A = 4; var B = 10; var C = 0; var D = 0; var E = 10; var F = z.legend_item_tile_width + 5; var G = 0; var H = {}; var I = {}; var J = {}; var K = [0]; var L = {}; var M = 0; a = a.filter((a) => !q(z.data_names[a]) || z.data_names[a] !== null), b = b || {}, r = w(b, 'withTransition', !0), s = w(b, 'withTransitionForTransform', !0), y.isLegendInset && (M = z.legend_inset_step ? z.legend_inset_step : a.length, y.updateLegendStep(M)), y.isLegendRight ? (f = function (a) { return C * L[a]; }, i = function (a) { return K[L[a]] + H[a]; }) : y.isLegendInset ? (f = function (a) { return C * L[a] + 10; }, i = function (a) { return K[L[a]] + H[a]; }) : (f = function (a) { return K[L[a]] + H[a]; }, i = function (a) { return D * L[a]; }), g = function (a, b) { return f(a, b) + 4 + z.legend_item_tile_width; }, j = function (a, b) { return i(a, b) + 9; }, h = function (a, b) { return f(a, b); }, k = function (a, b) { return i(a, b) - 5; }, m = function (a, b) { return f(a, b) - 2; }, n = function (a, b) { return f(a, b) - 2 + z.legend_item_tile_width; }, o = function (a, b) { return i(a, b) + 4; }, p = y.legend.selectAll(`.${l.legendItem}`).data(a).enter().append('g')
      .attr('class', (a) => y.generateClass(l.legendItem, a))
      .style('visibility', (a) => (y.isLegendToShow(a) ? 'visible' : 'hidden'))
      .style('cursor', 'pointer')
      .on('click', (a) => { z.legend_item_onclick ? z.legend_item_onclick.call(y, a) : y.d3.event.altKey ? (y.api.hide(), y.api.show(a)) : (y.api.toggle(a), y.isTargetToShow(a) ? y.api.focus(a) : y.api.revert()); })
      .on('mouseover', function (a) { z.legend_item_onmouseover ? z.legend_item_onmouseover.call(y, a) : (y.d3.select(this).classed(l.legendItemFocused, !0), !y.transiting && y.isTargetToShow(a) && y.api.focus(a)); })
      .on('mouseout', function (a) { z.legend_item_onmouseout ? z.legend_item_onmouseout.call(y, a) : (y.d3.select(this).classed(l.legendItemFocused, !1), y.api.revert()); }), p.append('text').text((a) => (q(z.data_names[a]) ? z.data_names[a] : a)).each(function (a, b) { e(this, a, b); }).style('pointer-events', 'none')
      .attr('x', y.isLegendRight || y.isLegendInset ? g : -200)
      .attr('y', y.isLegendRight || y.isLegendInset ? -200 : j), p.append('rect').attr('class', l.legendItemEvent).style('fill-opacity', 0).attr('x', y.isLegendRight || y.isLegendInset ? h : -200)
      .attr('y', y.isLegendRight || y.isLegendInset ? -200 : k), p.append('line').attr('class', l.legendItemTile).style('stroke', y.color).style('pointer-events', 'none')
      .attr('x1', y.isLegendRight || y.isLegendInset ? m : -200)
      .attr('y1', y.isLegendRight || y.isLegendInset ? -200 : o)
      .attr('x2', y.isLegendRight || y.isLegendInset ? n : -200)
      .attr('y2', y.isLegendRight || y.isLegendInset ? -200 : o)
      .attr('stroke-width', z.legend_item_tile_height), x = y.legend.select(`.${l.legendBackground} rect`), y.isLegendInset && C > 0 && x.size() === 0 && (x = y.legend.insert('g', `.${l.legendItem}`).attr('class', l.legendBackground).append('rect')), t = y.legend.selectAll('text').data(a).text((a) => (q(z.data_names[a]) ? z.data_names[a] : a)).each(function (a, b) { e(this, a, b); }), (r ? t.transition() : t).attr('x', g).attr('y', j), u = y.legend.selectAll(`rect.${l.legendItemEvent}`).data(a), (r ? u.transition() : u).attr('width', (a) => I[a]).attr('height', (a) => J[a]).attr('x', h).attr('y', k), v = y.legend.selectAll(`line.${l.legendItemTile}`).data(a), (r ? v.transition() : v).style('stroke', y.color).attr('x1', m).attr('y1', o).attr('x2', n)
      .attr('y2', o), x && (r ? x.transition() : x).attr('height', y.getLegendHeight() - 12).attr('width', C * (M + 1) + 10), y.legend.selectAll(`.${l.legendItem}`).classed(l.legendItemHidden, (a) => !y.isTargetToShow(a)), y.updateLegendItemWidth(C), y.updateLegendItemHeight(D), y.updateLegendStep(M), y.updateSizes(), y.updateScales(), y.updateSvgSize(), y.transformAll(s, c), y.legendHasRendered = !0;
  }, i.initTitle = function () { const a = this; a.title = a.svg.append('text').text(a.config.title_text).attr('class', a.CLASS.title); }, i.redrawTitle = function () { const a = this; a.title.attr('x', a.xForTitle.bind(a)).attr('y', a.yForTitle.bind(a)); }, i.xForTitle = function () { let a; const b = this; const c = b.config; const d = c.title_position || 'left'; return a = d.indexOf('right') >= 0 ? b.currentWidth - b.getTextRect(b.title.node().textContent, b.CLASS.title, b.title.node()).width - c.title_padding.right : d.indexOf('center') >= 0 ? (b.currentWidth - b.getTextRect(b.title.node().textContent, b.CLASS.title, b.title.node()).width) / 2 : c.title_padding.left; }, i.yForTitle = function () { const a = this; return a.config.title_padding.top + a.getTextRect(a.title.node().textContent, a.CLASS.title, a.title.node()).height; }, i.getTitlePadding = function () { const a = this; return a.yForTitle() + a.config.title_padding.bottom; }, c(b, f), f.prototype.init = function () {
    const a = this.owner; const b = a.config; const c = a.main; a.axes.x = c.append('g').attr('class', `${l.axis} ${l.axisX}`).attr('clip-path', a.clipPathForXAxis).attr('transform', a.getTranslate('x'))
      .style('visibility', b.axis_x_show ? 'visible' : 'hidden'), a.axes.x.append('text').attr('class', l.axisXLabel).attr('transform', b.axis_rotated ? 'rotate(-90)' : '').style('text-anchor', this.textAnchorForXAxisLabel.bind(this)), a.axes.y = c.append('g').attr('class', `${l.axis} ${l.axisY}`).attr('clip-path', b.axis_y_inner ? '' : a.clipPathForYAxis).attr('transform', a.getTranslate('y'))
      .style('visibility', b.axis_y_show ? 'visible' : 'hidden'), a.axes.y.append('text').attr('class', l.axisYLabel).attr('transform', b.axis_rotated ? '' : 'rotate(-90)').style('text-anchor', this.textAnchorForYAxisLabel.bind(this)), a.axes.y2 = c.append('g').attr('class', `${l.axis} ${l.axisY2}`).attr('transform', a.getTranslate('y2')).style('visibility', b.axis_y2_show ? 'visible' : 'hidden'), a.axes.y2.append('text').attr('class', l.axisY2Label).attr('transform', b.axis_rotated ? '' : 'rotate(-90)').style('text-anchor', this.textAnchorForY2AxisLabel.bind(this));
  }, f.prototype.getXAxis = function (a, b, c, d, e, f, h) {
    const i = this.owner; const j = i.config; const k = {
      isCategory: i.isCategorized(), withOuterTick: e, tickMultiline: j.axis_x_tick_multiline, tickWidth: j.axis_x_tick_width, tickTextRotate: h ? 0 : j.axis_x_tick_rotate, withoutTransition: f,
    }; const l = g(i.d3, k).scale(a).orient(b); return i.isTimeSeries() && d && typeof d !== 'function' && (d = d.map((a) => i.parseDate(a))), l.tickFormat(c).tickValues(d), i.isCategorized() && (l.tickCentered(j.axis_x_tick_centered), u(j.axis_x_tick_culling) && (j.axis_x_tick_culling = !1)), l;
  }, f.prototype.updateXAxisTickValues = function (a, b) { let c; const d = this.owner; const e = d.config; return (e.axis_x_tick_fit || e.axis_x_tick_count) && (c = this.generateTickValues(d.mapTargetsToUniqueXs(a), e.axis_x_tick_count, d.isTimeSeries())), b ? b.tickValues(c) : (d.xAxis.tickValues(c), d.subXAxis.tickValues(c)), c; }, f.prototype.getYAxis = function (a, b, c, d, e, f, h) { const i = this.owner; const j = i.config; const k = { withOuterTick: e, withoutTransition: f, tickTextRotate: h ? 0 : j.axis_y_tick_rotate }; const l = g(i.d3, k).scale(a).orient(b).tickFormat(c); return i.isTimeSeriesY() ? l.ticks(i.d3.time[j.axis_y_tick_time_value], j.axis_y_tick_time_interval) : l.tickValues(d), l; }, f.prototype.getId = function (a) { const b = this.owner.config; return a in b.data_axes ? b.data_axes[a] : 'y'; }, f.prototype.getXAxisTickFormat = function () { const a = this.owner; const b = a.config; let c = a.isTimeSeries() ? a.defaultAxisTimeFormat : a.isCategorized() ? a.categoryName : function (a) { return a < 0 ? a.toFixed(0) : a; }; return b.axis_x_tick_format && (n(b.axis_x_tick_format) ? c = b.axis_x_tick_format : a.isTimeSeries() && (c = function (c) { return c ? a.axisTimeFormat(b.axis_x_tick_format)(c) : ''; })), n(c) ? function (b) { return c.call(a, b); } : c; }, f.prototype.getTickValues = function (a, b) { return a || (b ? b.tickValues() : void 0); }, f.prototype.getXAxisTickValues = function () { return this.getTickValues(this.owner.config.axis_x_tick_values, this.owner.xAxis); }, f.prototype.getYAxisTickValues = function () { return this.getTickValues(this.owner.config.axis_y_tick_values, this.owner.yAxis); }, f.prototype.getY2AxisTickValues = function () { return this.getTickValues(this.owner.config.axis_y2_tick_values, this.owner.y2Axis); }, f.prototype.getLabelOptionByAxisId = function (a) { let b; const c = this.owner; const d = c.config; return a === 'y' ? b = d.axis_y_label : a === 'y2' ? b = d.axis_y2_label : a === 'x' && (b = d.axis_x_label), b; }, f.prototype.getLabelText = function (a) { const b = this.getLabelOptionByAxisId(a); return o(b) ? b : b ? b.text : null; }, f.prototype.setLabelText = function (a, b) { const c = this.owner; const d = c.config; const e = this.getLabelOptionByAxisId(a); o(e) ? a === 'y' ? d.axis_y_label = b : a === 'y2' ? d.axis_y2_label = b : a === 'x' && (d.axis_x_label = b) : e && (e.text = b); }, f.prototype.getLabelPosition = function (a, b) {
    const c = this.getLabelOptionByAxisId(a); const d = c && typeof c === 'object' && c.position ? c.position : b; return {
      isInner: d.indexOf('inner') >= 0, isOuter: d.indexOf('outer') >= 0, isLeft: d.indexOf('left') >= 0, isCenter: d.indexOf('center') >= 0, isRight: d.indexOf('right') >= 0, isTop: d.indexOf('top') >= 0, isMiddle: d.indexOf('middle') >= 0, isBottom: d.indexOf('bottom') >= 0,
    };
  }, f.prototype.getXAxisLabelPosition = function () { return this.getLabelPosition('x', this.owner.config.axis_rotated ? 'inner-top' : 'inner-right'); }, f.prototype.getYAxisLabelPosition = function () { return this.getLabelPosition('y', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top'); }, f.prototype.getY2AxisLabelPosition = function () { return this.getLabelPosition('y2', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top'); }, f.prototype.getLabelPositionById = function (a) { return a === 'y2' ? this.getY2AxisLabelPosition() : a === 'y' ? this.getYAxisLabelPosition() : this.getXAxisLabelPosition(); }, f.prototype.textForXAxisLabel = function () { return this.getLabelText('x'); }, f.prototype.textForYAxisLabel = function () { return this.getLabelText('y'); }, f.prototype.textForY2AxisLabel = function () { return this.getLabelText('y2'); }, f.prototype.xForAxisLabel = function (a, b) { const c = this.owner; return a ? b.isLeft ? 0 : b.isCenter ? c.width / 2 : c.width : b.isBottom ? -c.height : b.isMiddle ? -c.height / 2 : 0; }, f.prototype.dxForAxisLabel = function (a, b) { return a ? b.isLeft ? '0.5em' : b.isRight ? '-0.5em' : '0' : b.isTop ? '-0.5em' : b.isBottom ? '0.5em' : '0'; }, f.prototype.textAnchorForAxisLabel = function (a, b) { return a ? b.isLeft ? 'start' : b.isCenter ? 'middle' : 'end' : b.isBottom ? 'start' : b.isMiddle ? 'middle' : 'end'; }, f.prototype.xForXAxisLabel = function () { return this.xForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition()); }, f.prototype.xForYAxisLabel = function () { return this.xForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition()); }, f.prototype.xForY2AxisLabel = function () { return this.xForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition()); }, f.prototype.dxForXAxisLabel = function () { return this.dxForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition()); }, f.prototype.dxForYAxisLabel = function () { return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition()); }, f.prototype.dxForY2AxisLabel = function () { return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition()); }, f.prototype.dyForXAxisLabel = function () { const a = this.owner; const b = a.config; const c = this.getXAxisLabelPosition(); return b.axis_rotated ? c.isInner ? '1.2em' : -25 - this.getMaxTickWidth('x') : c.isInner ? '-0.5em' : b.axis_x_height ? b.axis_x_height - 10 : '3em'; }, f.prototype.dyForYAxisLabel = function () { const a = this.owner; const b = this.getYAxisLabelPosition(); return a.config.axis_rotated ? b.isInner ? '-0.5em' : '3em' : b.isInner ? '1.2em' : -10 - (a.config.axis_y_inner ? 0 : this.getMaxTickWidth('y') + 10); }, f.prototype.dyForY2AxisLabel = function () { const a = this.owner; const b = this.getY2AxisLabelPosition(); return a.config.axis_rotated ? b.isInner ? '1.2em' : '-2.2em' : b.isInner ? '-0.5em' : 15 + (a.config.axis_y2_inner ? 0 : this.getMaxTickWidth('y2') + 15); }, f.prototype.textAnchorForXAxisLabel = function () { const a = this.owner; return this.textAnchorForAxisLabel(!a.config.axis_rotated, this.getXAxisLabelPosition()); }, f.prototype.textAnchorForYAxisLabel = function () { const a = this.owner; return this.textAnchorForAxisLabel(a.config.axis_rotated, this.getYAxisLabelPosition()); }, f.prototype.textAnchorForY2AxisLabel = function () { const a = this.owner; return this.textAnchorForAxisLabel(a.config.axis_rotated, this.getY2AxisLabelPosition()); }, f.prototype.getMaxTickWidth = function (a, b) {
    let c; let d; let e; let f; let g; const h = this.owner; const i = h.config; let j = 0; return b && h.currentMaxTickWidths[a] ? h.currentMaxTickWidths[a] : (h.svg && (c = h.filterTargetsToShow(h.data.targets), a === 'y' ? (d = h.y.copy().domain(h.getYDomain(c, 'y')), e = this.getYAxis(d, h.yOrient, i.axis_y_tick_format, h.yAxisTickValues, !1, !0, !0)) : a === 'y2' ? (d = h.y2.copy().domain(h.getYDomain(c, 'y2')),
    e = this.getYAxis(d, h.y2Orient, i.axis_y2_tick_format, h.y2AxisTickValues, !1, !0, !0)) : (d = h.x.copy().domain(h.getXDomain(c)), e = this.getXAxis(d, h.xOrient, h.xAxisTickFormat, h.xAxisTickValues, !1, !0, !0), this.updateXAxisTickValues(c, e)), f = h.d3.select('body').append('div').classed('c3', !0), g = f.append('svg').style('visibility', 'hidden').style('position', 'fixed').style('top', 0)
      .style('left', 0), g.append('g').call(e).each(function () { h.d3.select(this).selectAll('text').each(function () { const a = this.getBoundingClientRect(); j < a.width && (j = a.width); }), f.remove(); })), h.currentMaxTickWidths[a] = j <= 0 ? h.currentMaxTickWidths[a] : j, h.currentMaxTickWidths[a]);
  }, f.prototype.updateLabels = function (a) { const b = this.owner; const c = b.main.select(`.${l.axisX} .${l.axisXLabel}`); const d = b.main.select(`.${l.axisY} .${l.axisYLabel}`); const e = b.main.select(`.${l.axisY2} .${l.axisY2Label}`); (a ? c.transition() : c).attr('x', this.xForXAxisLabel.bind(this)).attr('dx', this.dxForXAxisLabel.bind(this)).attr('dy', this.dyForXAxisLabel.bind(this)).text(this.textForXAxisLabel.bind(this)), (a ? d.transition() : d).attr('x', this.xForYAxisLabel.bind(this)).attr('dx', this.dxForYAxisLabel.bind(this)).attr('dy', this.dyForYAxisLabel.bind(this)).text(this.textForYAxisLabel.bind(this)), (a ? e.transition() : e).attr('x', this.xForY2AxisLabel.bind(this)).attr('dx', this.dxForY2AxisLabel.bind(this)).attr('dy', this.dyForY2AxisLabel.bind(this)).text(this.textForY2AxisLabel.bind(this)); }, f.prototype.getPadding = function (a, b, c, d) { const e = typeof a === 'number' ? a : a[b]; return m(e) ? a.unit === 'ratio' ? a[b] * d : this.convertPixelsToAxisPadding(e, d) : c; }, f.prototype.convertPixelsToAxisPadding = function (a, b) { const c = this.owner; const d = c.config.axis_rotated ? c.width : c.height; return b * (a / d); }, f.prototype.generateTickValues = function (a, b, c) { let d; let e; let f; let g; let h; let i; let j; let k = a; if (b) if (d = n(b) ? b() : b, d === 1)k = [a[0]]; else if (d === 2)k = [a[0], a[a.length - 1]]; else if (d > 2) { for (g = d - 2, e = a[0], f = a[a.length - 1], h = (f - e) / (g + 1), k = [e], i = 0; g > i; i++)j = +e + h * (i + 1), k.push(c ? new Date(j) : j); k.push(f); } return c || (k = k.sort((a, b) => a - b)), k; }, f.prototype.generateTransitions = function (a) {
    const b = this.owner; const c = b.axes; return {
      axisX: a ? c.x.transition().duration(a) : c.x, axisY: a ? c.y.transition().duration(a) : c.y, axisY2: a ? c.y2.transition().duration(a) : c.y2, axisSubX: a ? c.subx.transition().duration(a) : c.subx,
    };
  }, f.prototype.redraw = function (a, b) { const c = this.owner; c.axes.x.style('opacity', b ? 0 : 1), c.axes.y.style('opacity', b ? 0 : 1), c.axes.y2.style('opacity', b ? 0 : 1), c.axes.subx.style('opacity', b ? 0 : 1), a.axisX.call(c.xAxis), a.axisY.call(c.yAxis), a.axisY2.call(c.y2Axis), a.axisSubX.call(c.subXAxis); }, i.getClipPath = function (b) { const c = a.navigator.appVersion.toLowerCase().indexOf('msie 9.') >= 0; return `url(${c ? '' : document.URL.split('#')[0]}#${b})`; }, i.appendClip = function (a, b) { return a.append('clipPath').attr('id', b).append('rect'); }, i.getAxisClipX = function (a) { const b = Math.max(30, this.margin.left); return a ? -(1 + b) : -(b - 1); }, i.getAxisClipY = function (a) { return a ? -20 : -this.margin.top; }, i.getXAxisClipX = function () { const a = this; return a.getAxisClipX(!a.config.axis_rotated); }, i.getXAxisClipY = function () { const a = this; return a.getAxisClipY(!a.config.axis_rotated); }, i.getYAxisClipX = function () { const a = this; return a.config.axis_y_inner ? -1 : a.getAxisClipX(a.config.axis_rotated); }, i.getYAxisClipY = function () { const a = this; return a.getAxisClipY(a.config.axis_rotated); }, i.getAxisClipWidth = function (a) { const b = this; const c = Math.max(30, b.margin.left); const d = Math.max(30, b.margin.right); return a ? b.width + 2 + c + d : b.margin.left + 20; }, i.getAxisClipHeight = function (a) { return (a ? this.margin.bottom : this.margin.top + this.height) + 20; }, i.getXAxisClipWidth = function () { const a = this; return a.getAxisClipWidth(!a.config.axis_rotated); }, i.getXAxisClipHeight = function () { const a = this; return a.getAxisClipHeight(!a.config.axis_rotated); }, i.getYAxisClipWidth = function () { const a = this; return a.getAxisClipWidth(a.config.axis_rotated) + (a.config.axis_y_inner ? 20 : 0); }, i.getYAxisClipHeight = function () { const a = this; return a.getAxisClipHeight(a.config.axis_rotated); }, i.initPie = function () { const a = this; const b = a.d3; const c = a.config; a.pie = b.layout.pie().value((a) => a.values.reduce((a, b) => a + b.value, 0)), c.data_order || a.pie.sort(null); }, i.updateRadius = function () { const a = this; const b = a.config; const c = b.gauge_width || b.donut_width; a.radiusExpanded = Math.min(a.arcWidth, a.arcHeight) / 2, a.radius = 0.95 * a.radiusExpanded, a.innerRadiusRatio = c ? (a.radius - c) / a.radius : 0.6, a.innerRadius = a.hasType('donut') || a.hasType('gauge') ? a.radius * a.innerRadiusRatio : 0; }, i.updateArc = function () { const a = this; a.svgArc = a.getSvgArc(), a.svgArcExpanded = a.getSvgArcExpanded(), a.svgArcExpandedSub = a.getSvgArcExpanded(0.98); }, i.updateAngle = function (a) { let b; let c; let d; let e; const f = this; const g = f.config; let h = !1; let i = 0; return g ? (f.pie(f.filterTargetsToShow(f.data.targets)).forEach((b) => { h || b.data.id !== a.data.id || (h = !0, a = b, a.index = i), i++; }), isNaN(a.startAngle) && (a.startAngle = 0), isNaN(a.endAngle) && (a.endAngle = a.startAngle), f.isGaugeType(a.data) && (b = g.gauge_min, c = g.gauge_max, d = Math.PI * (g.gauge_fullCircle ? 2 : 1) / (c - b), e = a.value < b ? 0 : a.value < c ? a.value - b : c - b, a.startAngle = g.gauge_startingAngle, a.endAngle = a.startAngle + d * e), h ? a : null) : null; }, i.getSvgArc = function () { const a = this; const b = a.d3.svg.arc().outerRadius(a.radius).innerRadius(a.innerRadius); const c = function (c, d) { let e; return d ? b(c) : (e = a.updateAngle(c), e ? b(e) : 'M 0 0'); }; return c.centroid = b.centroid, c; }, i.getSvgArcExpanded = function (a) { const b = this; const c = b.d3.svg.arc().outerRadius(b.radiusExpanded * (a || 1)).innerRadius(b.innerRadius); return function (a) { const d = b.updateAngle(a); return d ? c(d) : 'M 0 0'; }; }, i.getArc = function (a, b, c) { return c || this.isArcType(a.data) ? this.svgArc(a, b) : 'M 0 0'; }, i.transformForArcLabel = function (a) { let b; let c; let d; let e; let f; const g = this; const h = g.config; const i = g.updateAngle(a); let j = ''; return i && !g.hasType('gauge') && (b = this.svgArc.centroid(i), c = isNaN(b[0]) ? 0 : b[0], d = isNaN(b[1]) ? 0 : b[1], e = Math.sqrt(c * c + d * d), f = g.hasType('donut') && h.donut_label_ratio ? n(h.donut_label_ratio) ? h.donut_label_ratio(a, g.radius, e) : h.donut_label_ratio : g.hasType('pie') && h.pie_label_ratio ? n(h.pie_label_ratio) ? h.pie_label_ratio(a, g.radius, e) : h.pie_label_ratio : g.radius && e ? (36 / g.radius > 0.375 ? 1.175 - 36 / g.radius : 0.8) * g.radius / e : 0, j = `translate(${c * f},${d * f})`), j; }, i.getArcRatio = function (a) { const b = this; const c = b.config; const d = Math.PI * (b.hasType('gauge') && !c.gauge_fullCircle ? 1 : 2); return a ? (a.endAngle - a.startAngle) / d : null; }, i.convertToArcData = function (a) {
    return this.addName({
      id: a.data.id, value: a.value, ratio: this.getArcRatio(a), index: a.index,
    });
  }, i.textForArcLabel = function (a) { let b; let c; let d; let e; let f; const g = this; return g.shouldShowArcLabel() ? (b = g.updateAngle(a), c = b ? b.value : null, d = g.getArcRatio(b), e = a.data.id, g.hasType('gauge') || g.meetsArcLabelThreshold(d) ? (f = g.getArcLabelFormat(), f ? f(c, d, e) : g.defaultArcValueFormat(c, d)) : '') : ''; }, i.expandArc = function (b) {
    let c; const d = this; return d.transiting ? void (c = a.setInterval(() => { d.transiting || (a.clearInterval(c), d.legend.selectAll('.c3-legend-item-focused').size() > 0 && d.expandArc(b)); }, 10)) : (b = d.mapToTargetIds(b), void d.svg.selectAll(d.selectorTargets(b, `.${l.chartArc}`)).each(function (a) {
      d.shouldExpand(a.data.id) && d.d3.select(this).selectAll('path').transition().duration(d.expandDuration(a.data.id))
        .attr('d', d.svgArcExpanded)
        .transition()
        .duration(2 * d.expandDuration(a.data.id))
        .attr('d', d.svgArcExpandedSub)
        .each((a) => { d.isDonutType(a.data); });
    }));
  }, i.unexpandArc = function (a) {
    const b = this; b.transiting || (a = b.mapToTargetIds(a), b.svg.selectAll(b.selectorTargets(a, `.${l.chartArc}`)).selectAll('path').transition().duration((a) => b.expandDuration(a.data.id))
      .attr('d', b.svgArc), b.svg.selectAll(`.${l.arc}`).style('opacity', 1));
  }, i.expandDuration = function (a) { const b = this; const c = b.config; return b.isDonutType(a) ? c.donut_expand_duration : b.isGaugeType(a) ? c.gauge_expand_duration : b.isPieType(a) ? c.pie_expand_duration : 50; }, i.shouldExpand = function (a) { const b = this; const c = b.config; return b.isDonutType(a) && c.donut_expand || b.isGaugeType(a) && c.gauge_expand || b.isPieType(a) && c.pie_expand; }, i.shouldShowArcLabel = function () { const a = this; const b = a.config; let c = !0; return a.hasType('donut') ? c = b.donut_label_show : a.hasType('pie') && (c = b.pie_label_show), c; }, i.meetsArcLabelThreshold = function (a) { const b = this; const c = b.config; const d = b.hasType('donut') ? c.donut_label_threshold : c.pie_label_threshold; return a >= d; }, i.getArcLabelFormat = function () { const a = this; const b = a.config; let c = b.pie_label_format; return a.hasType('gauge') ? c = b.gauge_label_format : a.hasType('donut') && (c = b.donut_label_format), c; }, i.getArcTitle = function () { const a = this; return a.hasType('donut') ? a.config.donut_title : ''; }, i.updateTargetsForArc = function (a) {
    let b; let c; const d = this; const e = d.main; const f = d.classChartArc.bind(d); const g = d.classArcs.bind(d); const h = d.classFocus.bind(d); b = e.select(`.${l.chartArcs}`).selectAll(`.${l.chartArc}`).data(d.pie(a)).attr('class', (a) => f(a) + h(a.data)), c = b.enter().append('g').attr('class', f), c.append('g').attr('class', g), c.append('text').attr('dy', d.hasType('gauge') ? '-.1em' : '.35em').style('opacity', 0).style('text-anchor', 'middle')
      .style('pointer-events', 'none');
  }, i.initArc = function () { const a = this; a.arcs = a.main.select(`.${l.chart}`).append('g').attr('class', l.chartArcs).attr('transform', a.getTranslate('arc')), a.arcs.append('text').attr('class', l.chartArcsTitle).style('text-anchor', 'middle').text(a.getArcTitle()); }, i.redrawArc = function (a, b, c) {
    let d; const e = this; const f = e.d3; const g = e.config; const h = e.main; d = h.selectAll(`.${l.arcs}`).selectAll(`.${l.arc}`).data(e.arcData.bind(e)), d.enter().append('path').attr('class', e.classArc.bind(e)).style('fill', (a) => e.color(a.data))
      .style('cursor', (a) => (g.interaction_enabled && g.data_selection_isselectable(a) ? 'pointer' : null))
      .style('opacity', 0)
      .each(function (a) { e.isGaugeType(a.data) && (a.startAngle = a.endAngle = g.gauge_startingAngle), this._current = a; }), d.attr('transform', (a) => (!e.isGaugeType(a.data) && c ? 'scale(0)' : '')).style('opacity', function (a) { return a === this._current ? 0 : 1; }).on('mouseover', g.interaction_enabled ? function (a) { let b; let c; e.transiting || (b = e.updateAngle(a), b && (c = e.convertToArcData(b), e.expandArc(b.data.id), e.api.focus(b.data.id), e.toggleFocusLegend(b.data.id, !0), e.config.data_onmouseover(c, this))); } : null).on('mousemove', g.interaction_enabled ? function (a) { let b; let c; const d = e.updateAngle(a); d && (b = e.convertToArcData(d), c = [b], e.showTooltip(c, this)); } : null)
      .on('mouseout', g.interaction_enabled ? function (a) { let b; let c; e.transiting || (b = e.updateAngle(a), b && (c = e.convertToArcData(b), e.unexpandArc(b.data.id), e.api.revert(), e.revertLegend(), e.hideTooltip(), e.config.data_onmouseout(c, this))); } : null)
      .on('click', g.interaction_enabled ? function (a, b) { let c; const d = e.updateAngle(a); d && (c = e.convertToArcData(d), e.toggleShape && e.toggleShape(this, c, b), e.config.data_onclick.call(e.api, c, this)); } : null)
      .each(() => { e.transiting = !0; })
      .transition()
      .duration(a)
      .attrTween('d', function (a) { let b; const c = e.updateAngle(a); return c ? (isNaN(this._current.startAngle) && (this._current.startAngle = 0), isNaN(this._current.endAngle) && (this._current.endAngle = this._current.startAngle), b = f.interpolate(this._current, c), this._current = b(0), function (c) { const d = b(c); return d.data = a.data, e.getArc(d, !0); }) : function () { return 'M 0 0'; }; })
      .attr('transform', c ? 'scale(1)' : '')
      .style('fill', (a) => (e.levelColor ? e.levelColor(a.data.values[0].value) : e.color(a.data.id)))
      .style('opacity', 1)
      .call(e.endall, () => { e.transiting = !1; }), d.exit().transition().duration(b).style('opacity', 0)
      .remove(), h.selectAll(`.${l.chartArc}`).select('text').style('opacity', 0).attr('class', (a) => (e.isGaugeType(a.data) ? l.gaugeValue : ''))
      .text(e.textForArcLabel.bind(e))
      .attr('transform', e.transformForArcLabel.bind(e))
      .style('font-size', (a) => (e.isGaugeType(a.data) ? `${Math.round(e.radius / 5)}px` : ''))
      .transition()
      .duration(a)
      .style('opacity', (a) => (e.isTargetToShow(a.data.id) && e.isArcType(a.data) ? 1 : 0)), h.select(`.${l.chartArcsTitle}`).style('opacity', e.hasType('donut') || e.hasType('gauge') ? 1 : 0), e.hasType('gauge') && (e.arcs.select(`.${l.chartArcsBackground}`).attr('d', () => { const a = { data: [{ value: g.gauge_max }], startAngle: g.gauge_startingAngle, endAngle: -1 * g.gauge_startingAngle }; return e.getArc(a, !0, !0); }), e.arcs.select(`.${l.chartArcsGaugeUnit}`).attr('dy', '.75em').text(g.gauge_label_show ? g.gauge_units : ''), e.arcs.select(`.${l.chartArcsGaugeMin}`).attr('dx', `${-1 * (e.innerRadius + (e.radius - e.innerRadius) / (g.gauge_fullCircle ? 1 : 2))}px`).attr('dy', '1.2em').text(g.gauge_label_show ? g.gauge_min : ''), e.arcs.select(`.${l.chartArcsGaugeMax}`).attr('dx', `${e.innerRadius + (e.radius - e.innerRadius) / (g.gauge_fullCircle ? 1 : 2)}px`).attr('dy', '1.2em').text(g.gauge_label_show ? g.gauge_max : ''));
  }, i.initGauge = function () { const a = this.arcs; this.hasType('gauge') && (a.append('path').attr('class', l.chartArcsBackground), a.append('text').attr('class', l.chartArcsGaugeUnit).style('text-anchor', 'middle').style('pointer-events', 'none'), a.append('text').attr('class', l.chartArcsGaugeMin).style('text-anchor', 'middle').style('pointer-events', 'none'), a.append('text').attr('class', l.chartArcsGaugeMax).style('text-anchor', 'middle').style('pointer-events', 'none')); }, i.getGaugeLabelHeight = function () { return this.config.gauge_label_show ? 20 : 0; }, i.initRegion = function () { const a = this; a.region = a.main.append('g').attr('clip-path', a.clipPath).attr('class', l.regions); }, i.updateRegion = function (a) {
    const b = this; const c = b.config; b.region.style('visibility', b.hasArcType() ? 'hidden' : 'visible'), b.mainRegion = b.main.select(`.${l.regions}`).selectAll(`.${l.region}`).data(c.regions), b.mainRegion.enter().append('g').append('rect').style('fill-opacity', 0), b.mainRegion.attr('class', b.classRegion.bind(b)), b.mainRegion.exit().transition().duration(a).style('opacity', 0)
      .remove();
  }, i.redrawRegion = function (a) {
    const b = this; const c = b.mainRegion.selectAll('rect').each(function () { const a = b.d3.select(this.parentNode).datum(); b.d3.select(this).datum(a); }); const d = b.regionX.bind(b); const e = b.regionY.bind(b); const f = b.regionWidth.bind(b); const g = b.regionHeight.bind(b); return [(a ? c.transition() : c).attr('x', d).attr('y', e).attr('width', f).attr('height', g)
      .style('fill-opacity', (a) => (m(a.opacity) ? a.opacity : 0.1))];
  }, i.regionX = function (a) { let b; const c = this; const d = c.config; const e = a.axis === 'y' ? c.y : c.y2; return b = a.axis === 'y' || a.axis === 'y2' ? d.axis_rotated && 'start' in a ? e(a.start) : 0 : d.axis_rotated ? 0 : 'start' in a ? c.x(c.isTimeSeries() ? c.parseDate(a.start) : a.start) : 0; }, i.regionY = function (a) { let b; const c = this; const d = c.config; const e = a.axis === 'y' ? c.y : c.y2; return b = a.axis === 'y' || a.axis === 'y2' ? d.axis_rotated ? 0 : 'end' in a ? e(a.end) : 0 : d.axis_rotated && 'start' in a ? c.x(c.isTimeSeries() ? c.parseDate(a.start) : a.start) : 0; }, i.regionWidth = function (a) { let b; const c = this; const d = c.config; const e = c.regionX(a); const f = a.axis === 'y' ? c.y : c.y2; return b = a.axis === 'y' || a.axis === 'y2' ? d.axis_rotated && 'end' in a ? f(a.end) : c.width : d.axis_rotated ? c.width : 'end' in a ? c.x(c.isTimeSeries() ? c.parseDate(a.end) : a.end) : c.width, e > b ? 0 : b - e; }, i.regionHeight = function (a) { let b; const c = this; const d = c.config; const e = this.regionY(a); const f = a.axis === 'y' ? c.y : c.y2; return b = a.axis === 'y' || a.axis === 'y2' ? d.axis_rotated ? c.height : 'start' in a ? f(a.start) : c.height : d.axis_rotated && 'end' in a ? c.x(c.isTimeSeries() ? c.parseDate(a.end) : a.end) : c.height, e > b ? 0 : b - e; }, i.isRegionOnX = function (a) { return !a.axis || a.axis === 'x'; }, i.drag = function (a) {
    let b; let c; let d; let e; let f; let g; let h; let i; const j = this; const k = j.config; const m = j.main; const n = j.d3; j.hasArcType() || k.data_selection_enabled && (k.zoom_enabled && !j.zoom.altDomain || k.data_selection_multiple && (b = j.dragStart[0], c = j.dragStart[1], d = a[0], e = a[1], f = Math.min(b, d), g = Math.max(b, d), h = k.data_selection_grouped ? j.margin.top : Math.min(c, e), i = k.data_selection_grouped ? j.height : Math.max(c, e), m.select(`.${l.dragarea}`).attr('x', f).attr('y', h).attr('width', g - f)
      .attr('height', i - h), m.selectAll(`.${l.shapes}`).selectAll(`.${l.shape}`).filter((a) => k.data_selection_isselectable(a)).each(function (a, b) { let c; let d; let e; let k; let m; let o; const p = n.select(this); const q = p.classed(l.SELECTED); const r = p.classed(l.INCLUDED); let s = !1; if (p.classed(l.circle))c = 1 * p.attr('cx'), d = 1 * p.attr('cy'), m = j.togglePoint, s = c > f && g > c && d > h && i > d; else { if (!p.classed(l.bar)) return; o = z(this), c = o.x, d = o.y, e = o.width, k = o.height, m = j.togglePath, s = !(c > g || f > c + e || d > i || h > d + k); }s ^ r && (p.classed(l.INCLUDED, !r), p.classed(l.SELECTED, !q), m.call(j, !q, p, a, b)); })));
  }, i.dragstart = function (a) { const b = this; const c = b.config; b.hasArcType() || c.data_selection_enabled && (b.dragStart = a, b.main.select(`.${l.chart}`).append('rect').attr('class', l.dragarea).style('opacity', 0.1), b.dragging = !0); }, i.dragend = function () {
    const a = this; const b = a.config; a.hasArcType() || b.data_selection_enabled && (a.main.select(`.${l.dragarea}`).transition().duration(100).style('opacity', 0)
      .remove(), a.main.selectAll(`.${l.shape}`).classed(l.INCLUDED, !1), a.dragging = !1);
  }, i.selectPoint = function (a, b, c) {
    const d = this; const e = d.config; const f = (e.axis_rotated ? d.circleY : d.circleX).bind(d); const g = (e.axis_rotated ? d.circleX : d.circleY).bind(d); const h = d.pointSelectR.bind(d); e.data_onselected.call(d.api, b, a.node()), d.main.select(`.${l.selectedCircles}${d.getTargetSelectorSuffix(b.id)}`).selectAll(`.${l.selectedCircle}-${c}`).data([b]).enter()
      .append('circle')
      .attr('class', () => d.generateClass(l.selectedCircle, c))
      .attr('cx', f)
      .attr('cy', g)
      .attr('stroke', () => d.color(b))
      .attr('r', (a) => 1.4 * d.pointSelectR(a))
      .transition()
      .duration(100)
      .attr('r', h);
  }, i.unselectPoint = function (a, b, c) {
    const d = this; d.config.data_onunselected.call(d.api, b, a.node()), d.main.select(`.${l.selectedCircles}${d.getTargetSelectorSuffix(b.id)}`).selectAll(`.${l.selectedCircle}-${c}`).transition().duration(100)
      .attr('r', 0)
      .remove();
  }, i.togglePoint = function (a, b, c, d) { a ? this.selectPoint(b, c, d) : this.unselectPoint(b, c, d); }, i.selectPath = function (a, b) { const c = this; c.config.data_onselected.call(c, b, a.node()), c.config.interaction_brighten && a.transition().duration(100).style('fill', () => c.d3.rgb(c.color(b)).brighter(0.75)); }, i.unselectPath = function (a, b) { const c = this; c.config.data_onunselected.call(c, b, a.node()), c.config.interaction_brighten && a.transition().duration(100).style('fill', () => c.color(b)); }, i.togglePath = function (a, b, c, d) { a ? this.selectPath(b, c, d) : this.unselectPath(b, c, d); }, i.getToggle = function (a, b) { let c; const d = this; return a.nodeName === 'circle' ? c = d.isStepType(b) ? function () {} : d.togglePoint : a.nodeName === 'path' && (c = d.togglePath), c; }, i.toggleShape = function (a, b, c) { const d = this; const e = d.d3; const f = d.config; const g = e.select(a); const h = g.classed(l.SELECTED); const i = d.getToggle(a, b).bind(d); f.data_selection_enabled && f.data_selection_isselectable(b) && (f.data_selection_multiple || d.main.selectAll(`.${l.shapes}${f.data_selection_grouped ? d.getTargetSelectorSuffix(b.id) : ''}`).selectAll(`.${l.shape}`).each(function (a, b) { const c = e.select(this); c.classed(l.SELECTED) && i(!1, c.classed(l.SELECTED, !1), a, b); }), g.classed(l.SELECTED, !h), i(!h, g, b, c)); }, i.initBrush = function () { const a = this; const b = a.d3; a.brush = b.svg.brush().on('brush', () => { a.redrawForBrush(); }), a.brush.update = function () { return a.context && a.context.select(`.${l.brush}`).call(this), this; }, a.brush.scale = function (b) { return a.config.axis_rotated ? this.y(b) : this.x(b); }; }, i.initSubchart = function () {
    const a = this; const b = a.config; const c = a.context = a.svg.append('g').attr('transform', a.getTranslate('context')); const d = b.subchart_show ? 'visible' : 'hidden'; c.style('visibility', d), c.append('g').attr('clip-path', a.clipPathForSubchart).attr('class', l.chart), c.select(`.${l.chart}`).append('g').attr('class', l.chartBars), c.select(`.${l.chart}`).append('g').attr('class', l.chartLines), c.append('g').attr('clip-path', a.clipPath).attr('class', l.brush).call(a.brush), a.axes.subx = c.append('g').attr('class', l.axisX).attr('transform', a.getTranslate('subx')).attr('clip-path', b.axis_rotated ? '' : a.clipPathForXAxis)
      .style('visibility', b.subchart_axis_x_show ? d : 'hidden');
  }, i.updateTargetsForSubchart = function (a) { let b; let c; let d; let e; const f = this; const g = f.context; const h = f.config; const i = f.classChartBar.bind(f); const j = f.classBars.bind(f); const k = f.classChartLine.bind(f); const m = f.classLines.bind(f); const n = f.classAreas.bind(f); h.subchart_show && (e = g.select(`.${l.chartBars}`).selectAll(`.${l.chartBar}`).data(a).attr('class', i), d = e.enter().append('g').style('opacity', 0).attr('class', i), d.append('g').attr('class', j), c = g.select(`.${l.chartLines}`).selectAll(`.${l.chartLine}`).data(a).attr('class', k), b = c.enter().append('g').style('opacity', 0).attr('class', k), b.append('g').attr('class', m), b.append('g').attr('class', n), g.selectAll(`.${l.brush} rect`).attr(h.axis_rotated ? 'width' : 'height', h.axis_rotated ? f.width2 : f.height2)); }, i.updateBarForSubchart = function (a) {
    const b = this; b.contextBar = b.context.selectAll(`.${l.bars}`).selectAll(`.${l.bar}`).data(b.barData.bind(b)), b.contextBar.enter().append('path').attr('class', b.classBar.bind(b)).style('stroke', 'none')
      .style('fill', b.color), b.contextBar.style('opacity', b.initialOpacity.bind(b)), b.contextBar.exit().transition().duration(a).style('opacity', 0)
      .remove();
  }, i.redrawBarForSubchart = function (a, b, c) { (b ? this.contextBar.transition(Math.random().toString()).duration(c) : this.contextBar).attr('d', a).style('opacity', 1); }, i.updateLineForSubchart = function (a) {
    const b = this; b.contextLine = b.context.selectAll(`.${l.lines}`).selectAll(`.${l.line}`).data(b.lineData.bind(b)), b.contextLine.enter().append('path').attr('class', b.classLine.bind(b)).style('stroke', b.color), b.contextLine.style('opacity', b.initialOpacity.bind(b)), b.contextLine.exit().transition().duration(a).style('opacity', 0)
      .remove();
  }, i.redrawLineForSubchart = function (a, b, c) { (b ? this.contextLine.transition(Math.random().toString()).duration(c) : this.contextLine).attr('d', a).style('opacity', 1); }, i.updateAreaForSubchart = function (a) {
    const b = this; const c = b.d3; b.contextArea = b.context.selectAll(`.${l.areas}`).selectAll(`.${l.area}`).data(b.lineData.bind(b)), b.contextArea.enter().append('path').attr('class', b.classArea.bind(b)).style('fill', b.color)
      .style('opacity', function () { return b.orgAreaOpacity = +c.select(this).style('opacity'), 0; }), b.contextArea.style('opacity', 0), b.contextArea.exit().transition().duration(a).style('opacity', 0)
      .remove();
  }, i.redrawAreaForSubchart = function (a, b, c) { (b ? this.contextArea.transition(Math.random().toString()).duration(c) : this.contextArea).attr('d', a).style('fill', this.color).style('opacity', this.orgAreaOpacity); }, i.redrawSubchart = function (a, b, c, d, e, f, g) { let h; let i; let j; const k = this; const l = k.d3; const m = k.config; k.context.style('visibility', m.subchart_show ? 'visible' : 'hidden'), m.subchart_show && (l.event && l.event.type === 'zoom' && k.brush.extent(k.x.orgDomain()).update(), a && (k.brush.empty() || k.brush.extent(k.x.orgDomain()).update(), h = k.generateDrawArea(e, !0), i = k.generateDrawBar(f, !0), j = k.generateDrawLine(g, !0), k.updateBarForSubchart(c), k.updateLineForSubchart(c), k.updateAreaForSubchart(c), k.redrawBarForSubchart(i, c, c), k.redrawLineForSubchart(j, c, c), k.redrawAreaForSubchart(h, c, c))); }, i.redrawForBrush = function () {
    const a = this; const b = a.x; a.redraw({
      withTransition: !1, withY: a.config.zoom_rescale, withSubchart: !1, withUpdateXDomain: !0, withDimension: !1,
    }), a.config.subchart_onbrush.call(a.api, b.orgDomain());
  }, i.transformContext = function (a, b) { let c; const d = this; b && b.axisSubX ? c = b.axisSubX : (c = d.context.select(`.${l.axisX}`), a && (c = c.transition())), d.context.attr('transform', d.getTranslate('context')), c.attr('transform', d.getTranslate('subx')); }, i.getDefaultExtent = function () { const a = this; const b = a.config; let c = n(b.axis_x_extent) ? b.axis_x_extent(a.getXDomain(a.data.targets)) : b.axis_x_extent; return a.isTimeSeries() && (c = [a.parseDate(c[0]), a.parseDate(c[1])]), c; }, i.initZoom = function () { let a; const b = this; const c = b.d3; const d = b.config; b.zoom = c.behavior.zoom().on('zoomstart', () => { a = c.event.sourceEvent, b.zoom.altDomain = c.event.sourceEvent.altKey ? b.x.orgDomain() : null, d.zoom_onzoomstart.call(b.api, c.event.sourceEvent); }).on('zoom', () => { b.redrawForZoom.call(b); }).on('zoomend', () => { const e = c.event.sourceEvent; e && a.clientX === e.clientX && a.clientY === e.clientY || (b.redrawEventRect(), b.updateZoom(), d.zoom_onzoomend.call(b.api, b.x.orgDomain())); }), b.zoom.scale = function (a) { return d.axis_rotated ? this.y(a) : this.x(a); }, b.zoom.orgScaleExtent = function () { const a = d.zoom_extent ? d.zoom_extent : [1, 10]; return [a[0], Math.max(b.getMaxDataCount() / a[1], a[1])]; }, b.zoom.updateScaleExtent = function () { const a = t(b.x.orgDomain()) / t(b.getZoomDomain()); const c = this.orgScaleExtent(); return this.scaleExtent([c[0] * a, c[1] * a]), this; }; }, i.getZoomDomain = function () { const a = this; const b = a.config; const c = a.d3; const d = c.min([a.orgXDomain[0], b.zoom_x_min]); const e = c.max([a.orgXDomain[1], b.zoom_x_max]); return [d, e]; }, i.updateZoom = function () { const a = this; const b = a.config.zoom_enabled ? a.zoom : function () {}; a.main.select(`.${l.zoomRect}`).call(b).on('dblclick.zoom', null), a.main.selectAll(`.${l.eventRect}`).call(b).on('dblclick.zoom', null); }, i.redrawForZoom = function () {
    const a = this; const b = a.d3; const c = a.config; const d = a.zoom; const e = a.x; if (c.zoom_enabled && a.filterTargetsToShow(a.data.targets).length !== 0) {
      if (b.event.sourceEvent.type === 'mousemove' && d.altDomain) return e.domain(d.altDomain), void d.scale(e).updateScaleExtent(); a.isCategorized() && e.orgDomain()[0] === a.orgXDomain[0] && e.domain([a.orgXDomain[0] - 1e-10, e.orgDomain()[1]]), a.redraw({
        withTransition: !1, withY: c.zoom_rescale, withSubchart: !1, withEventRect: !1, withDimension: !1,
      }), b.event.sourceEvent.type === 'mousemove' && (a.cancelClick = !0), c.zoom_onzoom.call(a.api, e.orgDomain());
    }
  }, i.generateColor = function () { const a = this; const b = a.config; const c = a.d3; const d = b.data_colors; const e = v(b.color_pattern) ? b.color_pattern : c.scale.category10().range(); const f = b.data_color; const g = []; return function (a) { let b; const c = a.id || a.data && a.data.id || a; return d[c] instanceof Function ? b = d[c](a) : d[c] ? b = d[c] : (g.indexOf(c) < 0 && g.push(c), b = e[g.indexOf(c) % e.length], d[c] = b), f instanceof Function ? f(b, a) : b; }; }, i.generateLevelColor = function () { const a = this; const b = a.config; const c = b.color_pattern; const d = b.color_threshold; const e = d.unit === 'value'; const f = d.values && d.values.length ? d.values : []; const g = d.max || 100; return v(b.color_threshold) ? function (a) { let b; let d; let h = c[c.length - 1]; for (b = 0; b < f.length; b++) if (d = e ? a : 100 * a / g, d < f[b]) { h = c[b]; break; } return h; } : null; }, i.getYFormat = function (a) { const b = this; const c = a && !b.hasType('gauge') ? b.defaultArcValueFormat : b.yFormat; const d = a && !b.hasType('gauge') ? b.defaultArcValueFormat : b.y2Format; return function (a, e, f) { const g = b.axis.getId(f) === 'y2' ? d : c; return g.call(b, a, e); }; }, i.yFormat = function (a) { const b = this; const c = b.config; const d = c.axis_y_tick_format ? c.axis_y_tick_format : b.defaultValueFormat; return d(a); }, i.y2Format = function (a) { const b = this; const c = b.config; const d = c.axis_y2_tick_format ? c.axis_y2_tick_format : b.defaultValueFormat; return d(a); }, i.defaultValueFormat = function (a) { return m(a) ? +a : ''; }, i.defaultArcValueFormat = function (a, b) { return `${(100 * b).toFixed(1)}%`; }, i.dataLabelFormat = function (a) { let b; const c = this; const d = c.config.data_labels; const e = function (a) { return m(a) ? +a : ''; }; return b = typeof d.format === 'function' ? d.format : typeof d.format === 'object' ? d.format[a] ? d.format[a] === !0 ? e : d.format[a] : function () { return ''; } : e; }, i.hasCaches = function (a) { for (let b = 0; b < a.length; b++) if (!(a[b] in this.cache)) return !1; return !0; }, i.addCache = function (a, b) { this.cache[a] = this.cloneTarget(b); }, i.getCaches = function (a) { let b; const c = []; for (b = 0; b < a.length; b++)a[b] in this.cache && c.push(this.cloneTarget(this.cache[a[b]])); return c; }; var l = i.CLASS = {
    target: 'c3-target', chart: 'c3-chart', chartLine: 'c3-chart-line', chartLines: 'c3-chart-lines', chartBar: 'c3-chart-bar', chartBars: 'c3-chart-bars', chartText: 'c3-chart-text', chartTexts: 'c3-chart-texts', chartArc: 'c3-chart-arc', chartArcs: 'c3-chart-arcs', chartArcsTitle: 'c3-chart-arcs-title', chartArcsBackground: 'c3-chart-arcs-background', chartArcsGaugeUnit: 'c3-chart-arcs-gauge-unit', chartArcsGaugeMax: 'c3-chart-arcs-gauge-max', chartArcsGaugeMin: 'c3-chart-arcs-gauge-min', selectedCircle: 'c3-selected-circle', selectedCircles: 'c3-selected-circles', eventRect: 'c3-event-rect', eventRects: 'c3-event-rects', eventRectsSingle: 'c3-event-rects-single', eventRectsMultiple: 'c3-event-rects-multiple', zoomRect: 'c3-zoom-rect', brush: 'c3-brush', focused: 'c3-focused', defocused: 'c3-defocused', region: 'c3-region', regions: 'c3-regions', title: 'c3-title', tooltipContainer: 'c3-tooltip-container', tooltip: 'c3-tooltip', tooltipName: 'c3-tooltip-name', shape: 'c3-shape', shapes: 'c3-shapes', line: 'c3-line', lines: 'c3-lines', bar: 'c3-bar', bars: 'c3-bars', circle: 'c3-circle', circles: 'c3-circles', arc: 'c3-arc', arcs: 'c3-arcs', area: 'c3-area', areas: 'c3-areas', empty: 'c3-empty', text: 'c3-text', texts: 'c3-texts', gaugeValue: 'c3-gauge-value', grid: 'c3-grid', gridLines: 'c3-grid-lines', xgrid: 'c3-xgrid', xgrids: 'c3-xgrids', xgridLine: 'c3-xgrid-line', xgridLines: 'c3-xgrid-lines', xgridFocus: 'c3-xgrid-focus', ygrid: 'c3-ygrid', ygrids: 'c3-ygrids', ygridLine: 'c3-ygrid-line', ygridLines: 'c3-ygrid-lines', axis: 'c3-axis', axisX: 'c3-axis-x', axisXLabel: 'c3-axis-x-label', axisY: 'c3-axis-y', axisYLabel: 'c3-axis-y-label', axisY2: 'c3-axis-y2', axisY2Label: 'c3-axis-y2-label', legendBackground: 'c3-legend-background', legendItem: 'c3-legend-item', legendItemEvent: 'c3-legend-item-event', legendItemTile: 'c3-legend-item-tile', legendItemHidden: 'c3-legend-item-hidden', legendItemFocused: 'c3-legend-item-focused', dragarea: 'c3-dragarea', EXPANDED: '_expanded_', SELECTED: '_selected_', INCLUDED: '_included_',
  }; i.generateClass = function (a, b) { return ` ${a} ${a}${this.getTargetSelectorSuffix(b)}`; }, i.classText = function (a) { return this.generateClass(l.text, a.index); }, i.classTexts = function (a) { return this.generateClass(l.texts, a.id); }, i.classShape = function (a) { return this.generateClass(l.shape, a.index); }, i.classShapes = function (a) { return this.generateClass(l.shapes, a.id); }, i.classLine = function (a) { return this.classShape(a) + this.generateClass(l.line, a.id); }, i.classLines = function (a) { return this.classShapes(a) + this.generateClass(l.lines, a.id); }, i.classCircle = function (a) { return this.classShape(a) + this.generateClass(l.circle, a.index); }, i.classCircles = function (a) { return this.classShapes(a) + this.generateClass(l.circles, a.id); }, i.classBar = function (a) { return this.classShape(a) + this.generateClass(l.bar, a.index); }, i.classBars = function (a) { return this.classShapes(a) + this.generateClass(l.bars, a.id); }, i.classArc = function (a) { return this.classShape(a.data) + this.generateClass(l.arc, a.data.id); }, i.classArcs = function (a) { return this.classShapes(a.data) + this.generateClass(l.arcs, a.data.id); }, i.classArea = function (a) { return this.classShape(a) + this.generateClass(l.area, a.id); }, i.classAreas = function (a) { return this.classShapes(a) + this.generateClass(l.areas, a.id); }, i.classRegion = function (a, b) { return `${this.generateClass(l.region, b)} ${'class' in a ? a.class : ''}`; }, i.classEvent = function (a) { return this.generateClass(l.eventRect, a.index); }, i.classTarget = function (a) { const b = this; const c = b.config.data_classes[a]; let d = ''; return c && (d = ` ${l.target}-${c}`), b.generateClass(l.target, a) + d; }, i.classFocus = function (a) { return this.classFocused(a) + this.classDefocused(a); }, i.classFocused = function (a) { return ` ${this.focusedTargetIds.indexOf(a.id) >= 0 ? l.focused : ''}`; }, i.classDefocused = function (a) { return ` ${this.defocusedTargetIds.indexOf(a.id) >= 0 ? l.defocused : ''}`; }, i.classChartText = function (a) { return l.chartText + this.classTarget(a.id); }, i.classChartLine = function (a) { return l.chartLine + this.classTarget(a.id); }, i.classChartBar = function (a) { return l.chartBar + this.classTarget(a.id); }, i.classChartArc = function (a) { return l.chartArc + this.classTarget(a.data.id); }, i.getTargetSelectorSuffix = function (a) { return a || a === 0 ? (`-${a}`).replace(/[\s?!@#$%^&*()_=+,.<>'":;\[\]\/|~`{}\\]/g, '-') : ''; }, i.selectorTarget = function (a, b) { return `${b || ''}.${l.target}${this.getTargetSelectorSuffix(a)}`; }, i.selectorTargets = function (a, b) { const c = this; return a = a || [], a.length ? a.map((a) => c.selectorTarget(a, b)) : null; }, i.selectorLegend = function (a) { return `.${l.legendItem}${this.getTargetSelectorSuffix(a)}`; }, i.selectorLegends = function (a) { const b = this; return a && a.length ? a.map((a) => b.selectorLegend(a)) : null; }; var m = i.isValue = function (a) { return a || a === 0; }; var n = i.isFunction = function (a) { return typeof a === 'function'; }; var o = i.isString = function (a) { return typeof a === 'string'; }; var p = i.isUndefined = function (a) { return typeof a === 'undefined'; }; var q = i.isDefined = function (a) { return typeof a !== 'undefined'; }; var r = i.ceil10 = function (a) { return 10 * Math.ceil(a / 10); }; var s = i.asHalfPixel = function (a) { return Math.ceil(a) + 0.5; }; var t = i.diffDomain = function (a) { return a[1] - a[0]; }; var u = i.isEmpty = function (a) { return typeof a === 'undefined' || a === null || o(a) && a.length === 0 || typeof a === 'object' && Object.keys(a).length === 0; }; var v = i.notEmpty = function (a) { return !i.isEmpty(a); }; var w = i.getOption = function (a, b, c) { return q(a[b]) ? a[b] : c; }; var x = i.hasValue = function (a, b) { let c = !1; return Object.keys(a).forEach((d) => { a[d] === b && (c = !0); }), c; }; var y = i.sanitise = function (a) { return typeof a === 'string' ? a.replace(/</g, '&lt;').replace(/>/g, '&gt;') : a; }; var z = i.getPathBox = function (a) {
    const b = a.getBoundingClientRect(); const c = [a.pathSegList.getItem(0), a.pathSegList.getItem(1)]; const d = c[0].x; const e = Math.min(c[0].y, c[1].y); return {
      x: d, y: e, width: b.width, height: b.height,
    };
  }; h.focus = function (a) {
    let b; const c = this.internal; a = c.mapToTargetIds(a), b = c.svg.selectAll(c.selectorTargets(a.filter(c.isTargetToShow, c))), this.revert(), this.defocus(), b.classed(l.focused, !0).classed(l.defocused, !1),
    c.hasArcType() && c.expandArc(a), c.toggleFocusLegend(a, !0), c.focusedTargetIds = a, c.defocusedTargetIds = c.defocusedTargetIds.filter((b) => a.indexOf(b) < 0);
  }, h.defocus = function (a) { let b; const c = this.internal; a = c.mapToTargetIds(a), b = c.svg.selectAll(c.selectorTargets(a.filter(c.isTargetToShow, c))), b.classed(l.focused, !1).classed(l.defocused, !0), c.hasArcType() && c.unexpandArc(a), c.toggleFocusLegend(a, !1), c.focusedTargetIds = c.focusedTargetIds.filter((b) => a.indexOf(b) < 0), c.defocusedTargetIds = a; }, h.revert = function (a) { let b; const c = this.internal; a = c.mapToTargetIds(a), b = c.svg.selectAll(c.selectorTargets(a)), b.classed(l.focused, !1).classed(l.defocused, !1), c.hasArcType() && c.unexpandArc(a), c.config.legend_show && (c.showLegend(a.filter(c.isLegendToShow.bind(c))), c.legend.selectAll(c.selectorLegends(a)).filter(function () { return c.d3.select(this).classed(l.legendItemFocused); }).classed(l.legendItemFocused, !1)), c.focusedTargetIds = [], c.defocusedTargetIds = []; }, h.show = function (a, b) { let c; const d = this.internal; a = d.mapToTargetIds(a), b = b || {}, d.removeHiddenTargetIds(a), c = d.svg.selectAll(d.selectorTargets(a)), c.transition().style('opacity', 1, 'important').call(d.endall, () => { c.style('opacity', null).style('opacity', 1); }), b.withLegend && d.showLegend(a), d.redraw({ withUpdateOrgXDomain: !0, withUpdateXDomain: !0, withLegend: !0 }); }, h.hide = function (a, b) { let c; const d = this.internal; a = d.mapToTargetIds(a), b = b || {}, d.addHiddenTargetIds(a), c = d.svg.selectAll(d.selectorTargets(a)), c.transition().style('opacity', 0, 'important').call(d.endall, () => { c.style('opacity', null).style('opacity', 0); }), b.withLegend && d.hideLegend(a), d.redraw({ withUpdateOrgXDomain: !0, withUpdateXDomain: !0, withLegend: !0 }); }, h.toggle = function (a, b) { const c = this; const d = this.internal; d.mapToTargetIds(a).forEach((a) => { d.isTargetToShow(a) ? c.hide(a, b) : c.show(a, b); }); }, h.zoom = function (a) { const b = this.internal; return a && (b.isTimeSeries() && (a = a.map((a) => b.parseDate(a))), b.brush.extent(a), b.redraw({ withUpdateXDomain: !0, withY: b.config.zoom_rescale }), b.config.zoom_onzoom.call(this, b.x.orgDomain())), b.brush.extent(); }, h.zoom.enable = function (a) { const b = this.internal; b.config.zoom_enabled = a, b.updateAndRedraw(); }, h.unzoom = function () { const a = this.internal; a.brush.clear().update(), a.redraw({ withUpdateXDomain: !0 }); }, h.zoom.max = function (a) { const b = this.internal; const c = b.config; const d = b.d3; return a === 0 || a ? void (c.zoom_x_max = d.max([b.orgXDomain[1], a])) : c.zoom_x_max; }, h.zoom.min = function (a) { const b = this.internal; const c = b.config; const d = b.d3; return a === 0 || a ? void (c.zoom_x_min = d.min([b.orgXDomain[0], a])) : c.zoom_x_min; }, h.zoom.range = function (a) { return arguments.length ? (q(a.max) && this.domain.max(a.max), void (q(a.min) && this.domain.min(a.min))) : { max: this.domain.max(), min: this.domain.min() }; }, h.load = function (a) { const b = this.internal; const c = b.config; return a.xs && b.addXs(a.xs), 'names' in a && h.data.names.bind(this)(a.names), 'classes' in a && Object.keys(a.classes).forEach((b) => { c.data_classes[b] = a.classes[b]; }), 'categories' in a && b.isCategorized() && (c.axis_x_categories = a.categories), 'axes' in a && Object.keys(a.axes).forEach((b) => { c.data_axes[b] = a.axes[b]; }), 'colors' in a && Object.keys(a.colors).forEach((b) => { c.data_colors[b] = a.colors[b]; }), 'cacheIds' in a && b.hasCaches(a.cacheIds) ? void b.load(b.getCaches(a.cacheIds), a.done) : void ('unload' in a ? b.unload(b.mapToTargetIds(typeof a.unload === 'boolean' && a.unload ? null : a.unload), () => { b.loadFromArgs(a); }) : b.loadFromArgs(a)); }, h.unload = function (a) { const b = this.internal; a = a || {}, a instanceof Array ? a = { ids: a } : typeof a === 'string' && (a = { ids: [a] }), b.unload(b.mapToTargetIds(a.ids), () => { b.redraw({ withUpdateOrgXDomain: !0, withUpdateXDomain: !0, withLegend: !0 }), a.done && a.done(); }); }, h.flow = function (a) {
    let b; let c; let d; let e; let f; let g; let h; let i; const j = this.internal; const k = []; const l = j.getMaxDataCount(); let n = 0; let o = 0; if (a.json)c = j.convertJsonToData(a.json, a.keys); else if (a.rows)c = j.convertRowsToData(a.rows); else { if (!a.columns) return; c = j.convertColumnsToData(a.columns); }b = j.convertDataToTargets(c, !0), j.data.targets.forEach((a) => { let c; let d; let e = !1; for (c = 0; c < b.length; c++) if (a.id === b[c].id) { for (e = !0, a.values[a.values.length - 1] && (o = a.values[a.values.length - 1].index + 1), n = b[c].values.length, d = 0; n > d; d++)b[c].values[d].index = o + d, j.isTimeSeries() || (b[c].values[d].x = o + d); a.values = a.values.concat(b[c].values), b.splice(c, 1); break; }e || k.push(a.id); }), j.data.targets.forEach((a) => {
      let b; let c; for (b = 0; b < k.length; b++) {
        if (a.id === k[b]) {
          for (o = a.values[a.values.length - 1].index + 1, c = 0; n > c; c++) {
            a.values.push({
              id: a.id, index: o + c, x: j.isTimeSeries() ? j.getOtherTargetX(o + c) : o + c, value: null,
            });
          }
        }
      }
    }), j.data.targets.length && b.forEach((a) => {
      let b; const c = []; for (b = j.data.targets[0].values[0].index; o > b; b++) {
        c.push({
          id: a.id, index: b, x: j.isTimeSeries() ? j.getOtherTargetX(b) : b, value: null,
        });
      } a.values.forEach((a) => { a.index += o, j.isTimeSeries() || (a.x += o); }), a.values = c.concat(a.values);
    }), j.data.targets = j.data.targets.concat(b), d = j.getMaxDataCount(), f = j.data.targets[0], g = f.values[0], q(a.to) ? (n = 0, i = j.isTimeSeries() ? j.parseDate(a.to) : a.to, f.values.forEach((a) => { a.x < i && n++; })) : q(a.length) && (n = a.length), l ? l === 1 && j.isTimeSeries() && (h = (f.values[f.values.length - 1].x - g.x) / 2, e = [new Date(+g.x - h), new Date(+g.x + h)], j.updateXDomain(null, !0, !0, !1, e)) : (h = j.isTimeSeries() ? f.values.length > 1 ? f.values[f.values.length - 1].x - g.x : g.x - j.getXDomain(j.data.targets)[0] : 1, e = [g.x - h, g.x], j.updateXDomain(null, !0, !0, !1, e)), j.updateTargets(j.data.targets), j.redraw({
      flow: {
        index: g.index, length: n, duration: m(a.duration) ? a.duration : j.config.transition_duration, done: a.done, orgDataCount: l,
      },
      withLegend: !0,
      withTransition: l > 1,
      withTrimXDomain: !1,
      withUpdateXAxis: !0,
    });
  }, i.generateFlow = function (a) {
    const b = this; const c = b.config; const d = b.d3; return function () {
      let e; let f; let g; const h = a.targets; const i = a.flow; const j = a.drawBar; const k = a.drawLine; const m = a.drawArea; const n = a.cx; const o = a.cy; const p = a.xv; const q = a.xForText; const r = a.yForText; const s = a.duration; let u = 1; const v = i.index; const w = i.length; let x = b.getValueOnIndex(b.data.targets[0].values, v); let y = b.getValueOnIndex(b.data.targets[0].values, v + w); const z = b.x.domain(); const A = i.duration || s; const B = i.done || function () {}; const C = b.generateWait(); const D = b.xgrid || d.selectAll([]); const E = b.xgridLines || d.selectAll([]); const F = b.mainRegion || d.selectAll([]); const G = b.mainText || d.selectAll([]); const H = b.mainBar || d.selectAll([]); const I = b.mainLine || d.selectAll([]); const J = b.mainArea || d.selectAll([]); const K = b.mainCircle || d.selectAll([]); b.flowing = !0, b.data.targets.forEach((a) => { a.values.splice(0, w); }), g = b.updateXDomain(h, !0, !0), b.updateXGrid && b.updateXGrid(!0), i.orgDataCount ? e = i.orgDataCount === 1 || (x && x.x) === (y && y.x) ? b.x(z[0]) - b.x(g[0]) : b.isTimeSeries() ? b.x(z[0]) - b.x(g[0]) : b.x(x.x) - b.x(y.x) : b.data.targets[0].values.length !== 1 ? e = b.x(z[0]) - b.x(g[0]) : b.isTimeSeries() ? (x = b.getValueOnIndex(b.data.targets[0].values, 0), y = b.getValueOnIndex(b.data.targets[0].values, b.data.targets[0].values.length - 1), e = b.x(x.x) - b.x(y.x)) : e = t(g) / 2, u = t(z) / t(g), f = `translate(${e},0) scale(${u},1)`, b.hideXGridFocus(), d.transition().ease('linear').duration(A).each(() => { C.add(b.axes.x.transition().call(b.xAxis)), C.add(H.transition().attr('transform', f)), C.add(I.transition().attr('transform', f)), C.add(J.transition().attr('transform', f)), C.add(K.transition().attr('transform', f)), C.add(G.transition().attr('transform', f)), C.add(F.filter(b.isRegionOnX).transition().attr('transform', f)), C.add(D.transition().attr('transform', f)), C.add(E.transition().attr('transform', f)); })
        .call(C, () => { let a; const d = []; const e = []; const f = []; if (w) { for (a = 0; w > a; a++)d.push(`.${l.shape}-${v + a}`), e.push(`.${l.text}-${v + a}`), f.push(`.${l.eventRect}-${v + a}`); b.svg.selectAll(`.${l.shapes}`).selectAll(d).remove(), b.svg.selectAll(`.${l.texts}`).selectAll(e).remove(), b.svg.selectAll(`.${l.eventRects}`).selectAll(f).remove(), b.svg.select(`.${l.xgrid}`).remove(); }D.attr('transform', null).attr(b.xgridAttr), E.attr('transform', null), E.select('line').attr('x1', c.axis_rotated ? 0 : p).attr('x2', c.axis_rotated ? b.width : p), E.select('text').attr('x', c.axis_rotated ? b.width : 0).attr('y', p), H.attr('transform', null).attr('d', j), I.attr('transform', null).attr('d', k), J.attr('transform', null).attr('d', m), K.attr('transform', null).attr('cx', n).attr('cy', o), G.attr('transform', null).attr('x', q).attr('y', r).style('fill-opacity', b.opacityForText.bind(b)), F.attr('transform', null), F.select('rect').filter(b.isRegionOnX).attr('x', b.regionX.bind(b)).attr('width', b.regionWidth.bind(b)), c.interaction_enabled && b.redrawEventRect(), B(), b.flowing = !1; });
    };
  }, h.selected = function (a) { const b = this.internal; const c = b.d3; return c.merge(b.main.selectAll(`.${l.shapes}${b.getTargetSelectorSuffix(a)}`).selectAll(`.${l.shape}`).filter(function () { return c.select(this).classed(l.SELECTED); }).map((a) => a.map((a) => { const b = a.__data__; return b.data ? b.data : b; }))); }, h.select = function (a, b, c) { const d = this.internal; const e = d.d3; const f = d.config; f.data_selection_enabled && d.main.selectAll(`.${l.shapes}`).selectAll(`.${l.shape}`).each(function (g, h) { const i = e.select(this); const j = g.data ? g.data.id : g.id; const k = d.getToggle(this, g).bind(d); const m = f.data_selection_grouped || !a || a.indexOf(j) >= 0; const n = !b || b.indexOf(h) >= 0; const o = i.classed(l.SELECTED); i.classed(l.line) || i.classed(l.area) || (m && n ? f.data_selection_isselectable(g) && !o && k(!0, i.classed(l.SELECTED, !0), g, h) : q(c) && c && o && k(!1, i.classed(l.SELECTED, !1), g, h)); }); }, h.unselect = function (a, b) { const c = this.internal; const d = c.d3; const e = c.config; e.data_selection_enabled && c.main.selectAll(`.${l.shapes}`).selectAll(`.${l.shape}`).each(function (f, g) { const h = d.select(this); const i = f.data ? f.data.id : f.id; const j = c.getToggle(this, f).bind(c); const k = e.data_selection_grouped || !a || a.indexOf(i) >= 0; const m = !b || b.indexOf(g) >= 0; const n = h.classed(l.SELECTED); h.classed(l.line) || h.classed(l.area) || k && m && e.data_selection_isselectable(f) && n && j(!1, h.classed(l.SELECTED, !1), f, g); }); }, h.transform = function (a, b) { const c = this.internal; const d = ['pie', 'donut'].indexOf(a) >= 0 ? { withTransform: !0 } : null; c.transformTo(b, a, d); }, i.transformTo = function (a, b, c) { const d = this; const e = !d.hasArcType(); const f = c || { withTransitionForAxis: e }; f.withTransitionForTransform = !1, d.transiting = !1, d.setTargetType(a, b), d.updateTargets(d.data.targets), d.updateAndRedraw(f); }, h.groups = function (a) { const b = this.internal; const c = b.config; return p(a) ? c.data_groups : (c.data_groups = a, b.redraw(), c.data_groups); }, h.xgrids = function (a) { const b = this.internal; const c = b.config; return a ? (c.grid_x_lines = a, b.redrawWithoutRescale(), c.grid_x_lines) : c.grid_x_lines; }, h.xgrids.add = function (a) { const b = this.internal; return this.xgrids(b.config.grid_x_lines.concat(a || [])); }, h.xgrids.remove = function (a) { const b = this.internal; b.removeGridLines(a, !0); }, h.ygrids = function (a) { const b = this.internal; const c = b.config; return a ? (c.grid_y_lines = a, b.redrawWithoutRescale(), c.grid_y_lines) : c.grid_y_lines; }, h.ygrids.add = function (a) { const b = this.internal; return this.ygrids(b.config.grid_y_lines.concat(a || [])); }, h.ygrids.remove = function (a) { const b = this.internal; b.removeGridLines(a, !1); }, h.regions = function (a) { const b = this.internal; const c = b.config; return a ? (c.regions = a, b.redrawWithoutRescale(), c.regions) : c.regions; }, h.regions.add = function (a) { const b = this.internal; const c = b.config; return a ? (c.regions = c.regions.concat(a), b.redrawWithoutRescale(), c.regions) : c.regions; }, h.regions.remove = function (a) { let b; let c; let d; const e = this.internal; const f = e.config; return a = a || {}, b = e.getOption(a, 'duration', f.transition_duration), c = e.getOption(a, 'classes', [l.region]), d = e.main.select(`.${l.regions}`).selectAll(c.map((a) => `.${a}`)), (b ? d.transition().duration(b) : d).style('opacity', 0).remove(), f.regions = f.regions.filter((a) => { let b = !1; return a.class ? (a.class.split(' ').forEach((a) => { c.indexOf(a) >= 0 && (b = !0); }), !b) : !0; }), f.regions; }, h.data = function (a) { const b = this.internal.data.targets; return typeof a === 'undefined' ? b : b.filter((b) => [].concat(a).indexOf(b.id) >= 0); }, h.data.shown = function (a) { return this.internal.filterTargetsToShow(this.data(a)); }, h.data.values = function (a) { let b; let c = null; return a && (b = this.data(a), c = b[0] ? b[0].values.map((a) => a.value) : null), c; }, h.data.names = function (a) { return this.internal.clearLegendItemTextBoxCache(), this.internal.updateDataAttributes('names', a); }, h.data.colors = function (a) { return this.internal.updateDataAttributes('colors', a); }, h.data.axes = function (a) { return this.internal.updateDataAttributes('axes', a); }, h.category = function (a, b) { const c = this.internal; const d = c.config; return arguments.length > 1 && (d.axis_x_categories[a] = b, c.redraw()), d.axis_x_categories[a]; }, h.categories = function (a) { const b = this.internal; const c = b.config; return arguments.length ? (c.axis_x_categories = a, b.redraw(), c.axis_x_categories) : c.axis_x_categories; }, h.color = function (a) { const b = this.internal; return b.color(a); }, h.x = function (a) { const b = this.internal; return arguments.length && (b.updateTargetX(b.data.targets, a), b.redraw({ withUpdateOrgXDomain: !0, withUpdateXDomain: !0 })), b.data.xs; }, h.xs = function (a) { const b = this.internal; return arguments.length && (b.updateTargetXs(b.data.targets, a), b.redraw({ withUpdateOrgXDomain: !0, withUpdateXDomain: !0 })), b.data.xs; }, h.axis = function () {}, h.axis.labels = function (a) { const b = this.internal; arguments.length && (Object.keys(a).forEach((c) => { b.axis.setLabelText(c, a[c]); }), b.axis.updateLabels()); }, h.axis.max = function (a) { const b = this.internal; const c = b.config; return arguments.length ? (typeof a === 'object' ? (m(a.x) && (c.axis_x_max = a.x), m(a.y) && (c.axis_y_max = a.y), m(a.y2) && (c.axis_y2_max = a.y2)) : c.axis_y_max = c.axis_y2_max = a, void b.redraw({ withUpdateOrgXDomain: !0, withUpdateXDomain: !0 })) : { x: c.axis_x_max, y: c.axis_y_max, y2: c.axis_y2_max }; }, h.axis.min = function (a) { const b = this.internal; const c = b.config; return arguments.length ? (typeof a === 'object' ? (m(a.x) && (c.axis_x_min = a.x), m(a.y) && (c.axis_y_min = a.y), m(a.y2) && (c.axis_y2_min = a.y2)) : c.axis_y_min = c.axis_y2_min = a, void b.redraw({ withUpdateOrgXDomain: !0, withUpdateXDomain: !0 })) : { x: c.axis_x_min, y: c.axis_y_min, y2: c.axis_y2_min }; }, h.axis.range = function (a) { return arguments.length ? (q(a.max) && this.axis.max(a.max), void (q(a.min) && this.axis.min(a.min))) : { max: this.axis.max(), min: this.axis.min() }; }, h.legend = function () {}, h.legend.show = function (a) { const b = this.internal; b.showLegend(b.mapToTargetIds(a)), b.updateAndRedraw({ withLegend: !0 }); }, h.legend.hide = function (a) { const b = this.internal; b.hideLegend(b.mapToTargetIds(a)), b.updateAndRedraw({ withLegend: !0 }); }, h.resize = function (a) { const b = this.internal; const c = b.config; c.size_width = a ? a.width : null, c.size_height = a ? a.height : null, this.flush(); }, h.flush = function () { const a = this.internal; a.updateAndRedraw({ withLegend: !0, withTransition: !1, withTransitionForTransform: !1 }); }, h.destroy = function () { const b = this.internal; if (a.clearInterval(b.intervalForObserveInserted), void 0 !== b.resizeTimeout && a.clearTimeout(b.resizeTimeout), a.detachEvent)a.detachEvent('onresize', b.resizeFunction); else if (a.removeEventListener)a.removeEventListener('resize', b.resizeFunction); else { const c = a.onresize; c && c.add && c.remove && c.remove(b.resizeFunction); } return b.selectChart.classed('c3', !1).html(''), Object.keys(b).forEach((a) => { b[a] = null; }), null; }, h.tooltip = function () {}, h.tooltip.show = function (a) { let b; let c; const d = this.internal; a.mouse && (c = a.mouse), a.data ? d.isMultipleX() ? (c = [d.x(a.data.x), d.getYScale(a.data.id)(a.data.value)], b = null) : b = m(a.data.index) ? a.data.index : d.getIndexByX(a.data.x) : typeof a.x !== 'undefined' ? b = d.getIndexByX(a.x) : typeof a.index !== 'undefined' && (b = a.index), d.dispatchEvent('mouseover', b, c), d.dispatchEvent('mousemove', b, c), d.config.tooltip_onshow.call(d, a.data); }, h.tooltip.hide = function () { this.internal.dispatchEvent('mouseout', 0), this.internal.config.tooltip_onhide.call(this); }; let A; i.isSafari = function () { const b = a.navigator.userAgent; return b.indexOf('Safari') >= 0 && b.indexOf('Chrome') < 0; }, i.isChrome = function () { const b = a.navigator.userAgent; return b.indexOf('Chrome') >= 0; }, Function.prototype.bind || (Function.prototype.bind = function (a) { if (typeof this !== 'function') throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); const b = Array.prototype.slice.call(arguments, 1); const c = this; const d = function () {}; const e = function () { return c.apply(this instanceof d ? this : a, b.concat(Array.prototype.slice.call(arguments))); }; return d.prototype = this.prototype, e.prototype = new d(), e; }), (function () {
    'SVGPathSeg' in a || (a.SVGPathSeg = function (a, b, c) { this.pathSegType = a, this.pathSegTypeAsLetter = b, this._owningPathSegList = c; }, SVGPathSeg.PATHSEG_UNKNOWN = 0, SVGPathSeg.PATHSEG_CLOSEPATH = 1, SVGPathSeg.PATHSEG_MOVETO_ABS = 2, SVGPathSeg.PATHSEG_MOVETO_REL = 3, SVGPathSeg.PATHSEG_LINETO_ABS = 4, SVGPathSeg.PATHSEG_LINETO_REL = 5, SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS = 6, SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL = 7, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS = 8, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL = 9, SVGPathSeg.PATHSEG_ARC_ABS = 10, SVGPathSeg.PATHSEG_ARC_REL = 11, SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS = 12, SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL = 13, SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS = 14, SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL = 15, SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16, SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19, SVGPathSeg.prototype._segmentChanged = function () { this._owningPathSegList && this._owningPathSegList.segmentChanged(this); }, a.SVGPathSegClosePath = function (a) { SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CLOSEPATH, 'z', a); }, SVGPathSegClosePath.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegClosePath.prototype.toString = function () { return '[object SVGPathSegClosePath]'; }, SVGPathSegClosePath.prototype._asPathString = function () { return this.pathSegTypeAsLetter; }, SVGPathSegClosePath.prototype.clone = function () { return new SVGPathSegClosePath(void 0); }, a.SVGPathSegMovetoAbs = function (a, b, c) { SVGPathSeg.call(this, SVGPathSeg.PATHSEG_MOVETO_ABS, 'M', a), this._x = b, this._y = c; }, SVGPathSegMovetoAbs.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegMovetoAbs.prototype.toString = function () { return '[object SVGPathSegMovetoAbs]'; }, SVGPathSegMovetoAbs.prototype._asPathString = function () { return `${this.pathSegTypeAsLetter} ${this._x} ${this._y}`; }, SVGPathSegMovetoAbs.prototype.clone = function () { return new SVGPathSegMovetoAbs(void 0, this._x, this._y); }, Object.defineProperty(SVGPathSegMovetoAbs.prototype, 'x', { get() { return this._x; }, set(a) { this._x = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegMovetoAbs.prototype, 'y', { get() { return this._y; }, set(a) { this._y = a, this._segmentChanged(); }, enumerable: !0 }), a.SVGPathSegMovetoRel = function (a, b, c) { SVGPathSeg.call(this, SVGPathSeg.PATHSEG_MOVETO_REL, 'm', a), this._x = b, this._y = c; }, SVGPathSegMovetoRel.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegMovetoRel.prototype.toString = function () { return '[object SVGPathSegMovetoRel]'; }, SVGPathSegMovetoRel.prototype._asPathString = function () { return `${this.pathSegTypeAsLetter} ${this._x} ${this._y}`; }, SVGPathSegMovetoRel.prototype.clone = function () { return new SVGPathSegMovetoRel(void 0, this._x, this._y); }, Object.defineProperty(SVGPathSegMovetoRel.prototype, 'x', { get() { return this._x; }, set(a) { this._x = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegMovetoRel.prototype, 'y', { get() { return this._y; }, set(a) { this._y = a, this._segmentChanged(); }, enumerable: !0 }), a.SVGPathSegLinetoAbs = function (a, b, c) { SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_ABS, 'L', a), this._x = b, this._y = c; }, SVGPathSegLinetoAbs.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegLinetoAbs.prototype.toString = function () { return '[object SVGPathSegLinetoAbs]'; }, SVGPathSegLinetoAbs.prototype._asPathString = function () { return `${this.pathSegTypeAsLetter} ${this._x} ${this._y}`; }, SVGPathSegLinetoAbs.prototype.clone = function () { return new SVGPathSegLinetoAbs(void 0, this._x, this._y); }, Object.defineProperty(SVGPathSegLinetoAbs.prototype, 'x', { get() { return this._x; }, set(a) { this._x = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegLinetoAbs.prototype, 'y', { get() { return this._y; }, set(a) { this._y = a, this._segmentChanged(); }, enumerable: !0 }), a.SVGPathSegLinetoRel = function (a, b, c) { SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_REL, 'l', a), this._x = b, this._y = c; }, SVGPathSegLinetoRel.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegLinetoRel.prototype.toString = function () { return '[object SVGPathSegLinetoRel]'; }, SVGPathSegLinetoRel.prototype._asPathString = function () { return `${this.pathSegTypeAsLetter} ${this._x} ${this._y}`; }, SVGPathSegLinetoRel.prototype.clone = function () { return new SVGPathSegLinetoRel(void 0, this._x, this._y); }, Object.defineProperty(SVGPathSegLinetoRel.prototype, 'x', { get() { return this._x; }, set(a) { this._x = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegLinetoRel.prototype, 'y', { get() { return this._y; }, set(a) { this._y = a, this._segmentChanged(); }, enumerable: !0 }), a.SVGPathSegCurvetoCubicAbs = function (a, b, c, d, e, f, g) { SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS, 'C', a), this._x = b, this._y = c, this._x1 = d, this._y1 = e, this._x2 = f, this._y2 = g; }, SVGPathSegCurvetoCubicAbs.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegCurvetoCubicAbs.prototype.toString = function () { return '[object SVGPathSegCurvetoCubicAbs]'; }, SVGPathSegCurvetoCubicAbs.prototype._asPathString = function () { return `${this.pathSegTypeAsLetter} ${this._x1} ${this._y1} ${this._x2} ${this._y2} ${this._x} ${this._y}`; }, SVGPathSegCurvetoCubicAbs.prototype.clone = function () { return new SVGPathSegCurvetoCubicAbs(void 0, this._x, this._y, this._x1, this._y1, this._x2, this._y2); }, Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, 'x', { get() { return this._x; }, set(a) { this._x = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, 'y', { get() { return this._y; }, set(a) { this._y = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, 'x1', { get() { return this._x1; }, set(a) { this._x1 = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, 'y1', { get() { return this._y1; }, set(a) { this._y1 = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, 'x2', { get() { return this._x2; }, set(a) { this._x2 = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, 'y2', { get() { return this._y2; }, set(a) { this._y2 = a, this._segmentChanged(); }, enumerable: !0 }), a.SVGPathSegCurvetoCubicRel = function (a, b, c, d, e, f, g) { SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL, 'c', a), this._x = b, this._y = c, this._x1 = d, this._y1 = e, this._x2 = f, this._y2 = g; }, SVGPathSegCurvetoCubicRel.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegCurvetoCubicRel.prototype.toString = function () { return '[object SVGPathSegCurvetoCubicRel]'; }, SVGPathSegCurvetoCubicRel.prototype._asPathString = function () { return `${this.pathSegTypeAsLetter} ${this._x1} ${this._y1} ${this._x2} ${this._y2} ${this._x} ${this._y}`; }, SVGPathSegCurvetoCubicRel.prototype.clone = function () { return new SVGPathSegCurvetoCubicRel(void 0, this._x, this._y, this._x1, this._y1, this._x2, this._y2); }, Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, 'x', { get() { return this._x; }, set(a) { this._x = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, 'y', { get() { return this._y; }, set(a) { this._y = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, 'x1', { get() { return this._x1; }, set(a) { this._x1 = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, 'y1', { get() { return this._y1; }, set(a) { this._y1 = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, 'x2', { get() { return this._x2; }, set(a) { this._x2 = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, 'y2', { get() { return this._y2; }, set(a) { this._y2 = a, this._segmentChanged(); }, enumerable: !0 }), a.SVGPathSegCurvetoQuadraticAbs = function (a, b, c, d, e) { SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS, 'Q', a), this._x = b, this._y = c, this._x1 = d, this._y1 = e; }, SVGPathSegCurvetoQuadraticAbs.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegCurvetoQuadraticAbs.prototype.toString = function () { return '[object SVGPathSegCurvetoQuadraticAbs]'; }, SVGPathSegCurvetoQuadraticAbs.prototype._asPathString = function () { return `${this.pathSegTypeAsLetter} ${this._x1} ${this._y1} ${this._x} ${this._y}`; }, SVGPathSegCurvetoQuadraticAbs.prototype.clone = function () { return new SVGPathSegCurvetoQuadraticAbs(void 0, this._x, this._y, this._x1, this._y1); }, Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, 'x', { get() { return this._x; }, set(a) { this._x = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, 'y', { get() { return this._y; }, set(a) { this._y = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, 'x1', { get() { return this._x1; }, set(a) { this._x1 = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, 'y1', { get() { return this._y1; }, set(a) { this._y1 = a, this._segmentChanged(); }, enumerable: !0 }), a.SVGPathSegCurvetoQuadraticRel = function (a, b, c, d, e) { SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL, 'q', a), this._x = b, this._y = c, this._x1 = d, this._y1 = e; }, SVGPathSegCurvetoQuadraticRel.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegCurvetoQuadraticRel.prototype.toString = function () { return '[object SVGPathSegCurvetoQuadraticRel]'; }, SVGPathSegCurvetoQuadraticRel.prototype._asPathString = function () { return `${this.pathSegTypeAsLetter} ${this._x1} ${this._y1} ${this._x} ${this._y}`; }, SVGPathSegCurvetoQuadraticRel.prototype.clone = function () { return new SVGPathSegCurvetoQuadraticRel(void 0, this._x, this._y, this._x1, this._y1); }, Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, 'x', { get() { return this._x; }, set(a) { this._x = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, 'y', { get() { return this._y; }, set(a) { this._y = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, 'x1', { get() { return this._x1; }, set(a) { this._x1 = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, 'y1', { get() { return this._y1; }, set(a) { this._y1 = a, this._segmentChanged(); }, enumerable: !0 }), a.SVGPathSegArcAbs = function (a, b, c, d, e, f, g, h) { SVGPathSeg.call(this, SVGPathSeg.PATHSEG_ARC_ABS, 'A', a), this._x = b, this._y = c, this._r1 = d, this._r2 = e, this._angle = f, this._largeArcFlag = g, this._sweepFlag = h; }, SVGPathSegArcAbs.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegArcAbs.prototype.toString = function () { return '[object SVGPathSegArcAbs]'; }, SVGPathSegArcAbs.prototype._asPathString = function () { return `${this.pathSegTypeAsLetter} ${this._r1} ${this._r2} ${this._angle} ${this._largeArcFlag ? '1' : '0'} ${this._sweepFlag ? '1' : '0'} ${this._x} ${this._y}`; }, SVGPathSegArcAbs.prototype.clone = function () { return new SVGPathSegArcAbs(void 0, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag); }, Object.defineProperty(SVGPathSegArcAbs.prototype, 'x', { get() { return this._x; }, set(a) { this._x = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegArcAbs.prototype, 'y', { get() { return this._y; }, set(a) { this._y = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegArcAbs.prototype, 'r1', { get() { return this._r1; }, set(a) { this._r1 = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegArcAbs.prototype, 'r2', { get() { return this._r2; }, set(a) { this._r2 = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegArcAbs.prototype, 'angle', { get() { return this._angle; }, set(a) { this._angle = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegArcAbs.prototype, 'largeArcFlag', { get() { return this._largeArcFlag; }, set(a) { this._largeArcFlag = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegArcAbs.prototype, 'sweepFlag', { get() { return this._sweepFlag; }, set(a) { this._sweepFlag = a, this._segmentChanged(); }, enumerable: !0 }), a.SVGPathSegArcRel = function (a, b, c, d, e, f, g, h) { SVGPathSeg.call(this, SVGPathSeg.PATHSEG_ARC_REL, 'a', a), this._x = b, this._y = c, this._r1 = d, this._r2 = e, this._angle = f, this._largeArcFlag = g, this._sweepFlag = h; }, SVGPathSegArcRel.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegArcRel.prototype.toString = function () { return '[object SVGPathSegArcRel]'; }, SVGPathSegArcRel.prototype._asPathString = function () { return `${this.pathSegTypeAsLetter} ${this._r1} ${this._r2} ${this._angle} ${this._largeArcFlag ? '1' : '0'} ${this._sweepFlag ? '1' : '0'} ${this._x} ${this._y}`; }, SVGPathSegArcRel.prototype.clone = function () { return new SVGPathSegArcRel(void 0, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag); }, Object.defineProperty(SVGPathSegArcRel.prototype, 'x', { get() { return this._x; }, set(a) { this._x = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegArcRel.prototype, 'y', { get() { return this._y; }, set(a) { this._y = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegArcRel.prototype, 'r1', { get() { return this._r1; }, set(a) { this._r1 = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegArcRel.prototype, 'r2', { get() { return this._r2; }, set(a) { this._r2 = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegArcRel.prototype, 'angle', { get() { return this._angle; }, set(a) { this._angle = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegArcRel.prototype, 'largeArcFlag', { get() { return this._largeArcFlag; }, set(a) { this._largeArcFlag = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegArcRel.prototype, 'sweepFlag', { get() { return this._sweepFlag; }, set(a) { this._sweepFlag = a, this._segmentChanged(); }, enumerable: !0 }), a.SVGPathSegLinetoHorizontalAbs = function (a, b) { SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS, 'H', a), this._x = b; }, SVGPathSegLinetoHorizontalAbs.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegLinetoHorizontalAbs.prototype.toString = function () { return '[object SVGPathSegLinetoHorizontalAbs]'; }, SVGPathSegLinetoHorizontalAbs.prototype._asPathString = function () { return `${this.pathSegTypeAsLetter} ${this._x}`; }, SVGPathSegLinetoHorizontalAbs.prototype.clone = function () { return new SVGPathSegLinetoHorizontalAbs(void 0, this._x); }, Object.defineProperty(SVGPathSegLinetoHorizontalAbs.prototype, 'x', { get() { return this._x; }, set(a) { this._x = a, this._segmentChanged(); }, enumerable: !0 }), a.SVGPathSegLinetoHorizontalRel = function (a, b) { SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL, 'h', a), this._x = b; }, SVGPathSegLinetoHorizontalRel.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegLinetoHorizontalRel.prototype.toString = function () { return '[object SVGPathSegLinetoHorizontalRel]'; }, SVGPathSegLinetoHorizontalRel.prototype._asPathString = function () { return `${this.pathSegTypeAsLetter} ${this._x}`; }, SVGPathSegLinetoHorizontalRel.prototype.clone = function () { return new SVGPathSegLinetoHorizontalRel(void 0, this._x); }, Object.defineProperty(SVGPathSegLinetoHorizontalRel.prototype, 'x', { get() { return this._x; }, set(a) { this._x = a, this._segmentChanged(); }, enumerable: !0 }), a.SVGPathSegLinetoVerticalAbs = function (a, b) { SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS, 'V', a), this._y = b; }, SVGPathSegLinetoVerticalAbs.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegLinetoVerticalAbs.prototype.toString = function () { return '[object SVGPathSegLinetoVerticalAbs]'; }, SVGPathSegLinetoVerticalAbs.prototype._asPathString = function () { return `${this.pathSegTypeAsLetter} ${this._y}`; }, SVGPathSegLinetoVerticalAbs.prototype.clone = function () { return new SVGPathSegLinetoVerticalAbs(void 0, this._y); }, Object.defineProperty(SVGPathSegLinetoVerticalAbs.prototype, 'y', { get() { return this._y; }, set(a) { this._y = a, this._segmentChanged(); }, enumerable: !0 }), a.SVGPathSegLinetoVerticalRel = function (a, b) {
      SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL, 'v', a), this._y = b;
    }, SVGPathSegLinetoVerticalRel.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegLinetoVerticalRel.prototype.toString = function () { return '[object SVGPathSegLinetoVerticalRel]'; }, SVGPathSegLinetoVerticalRel.prototype._asPathString = function () { return `${this.pathSegTypeAsLetter} ${this._y}`; }, SVGPathSegLinetoVerticalRel.prototype.clone = function () { return new SVGPathSegLinetoVerticalRel(void 0, this._y); }, Object.defineProperty(SVGPathSegLinetoVerticalRel.prototype, 'y', { get() { return this._y; }, set(a) { this._y = a, this._segmentChanged(); }, enumerable: !0 }), a.SVGPathSegCurvetoCubicSmoothAbs = function (a, b, c, d, e) { SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS, 'S', a), this._x = b, this._y = c, this._x2 = d, this._y2 = e; }, SVGPathSegCurvetoCubicSmoothAbs.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegCurvetoCubicSmoothAbs.prototype.toString = function () { return '[object SVGPathSegCurvetoCubicSmoothAbs]'; }, SVGPathSegCurvetoCubicSmoothAbs.prototype._asPathString = function () { return `${this.pathSegTypeAsLetter} ${this._x2} ${this._y2} ${this._x} ${this._y}`; }, SVGPathSegCurvetoCubicSmoothAbs.prototype.clone = function () { return new SVGPathSegCurvetoCubicSmoothAbs(void 0, this._x, this._y, this._x2, this._y2); }, Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, 'x', { get() { return this._x; }, set(a) { this._x = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, 'y', { get() { return this._y; }, set(a) { this._y = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, 'x2', { get() { return this._x2; }, set(a) { this._x2 = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, 'y2', { get() { return this._y2; }, set(a) { this._y2 = a, this._segmentChanged(); }, enumerable: !0 }), a.SVGPathSegCurvetoCubicSmoothRel = function (a, b, c, d, e) { SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL, 's', a), this._x = b, this._y = c, this._x2 = d, this._y2 = e; }, SVGPathSegCurvetoCubicSmoothRel.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegCurvetoCubicSmoothRel.prototype.toString = function () { return '[object SVGPathSegCurvetoCubicSmoothRel]'; }, SVGPathSegCurvetoCubicSmoothRel.prototype._asPathString = function () { return `${this.pathSegTypeAsLetter} ${this._x2} ${this._y2} ${this._x} ${this._y}`; }, SVGPathSegCurvetoCubicSmoothRel.prototype.clone = function () { return new SVGPathSegCurvetoCubicSmoothRel(void 0, this._x, this._y, this._x2, this._y2); }, Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, 'x', { get() { return this._x; }, set(a) { this._x = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, 'y', { get() { return this._y; }, set(a) { this._y = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, 'x2', { get() { return this._x2; }, set(a) { this._x2 = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, 'y2', { get() { return this._y2; }, set(a) { this._y2 = a, this._segmentChanged(); }, enumerable: !0 }), a.SVGPathSegCurvetoQuadraticSmoothAbs = function (a, b, c) { SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS, 'T', a), this._x = b, this._y = c; }, SVGPathSegCurvetoQuadraticSmoothAbs.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegCurvetoQuadraticSmoothAbs.prototype.toString = function () { return '[object SVGPathSegCurvetoQuadraticSmoothAbs]'; }, SVGPathSegCurvetoQuadraticSmoothAbs.prototype._asPathString = function () { return `${this.pathSegTypeAsLetter} ${this._x} ${this._y}`; }, SVGPathSegCurvetoQuadraticSmoothAbs.prototype.clone = function () { return new SVGPathSegCurvetoQuadraticSmoothAbs(void 0, this._x, this._y); }, Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothAbs.prototype, 'x', { get() { return this._x; }, set(a) { this._x = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothAbs.prototype, 'y', { get() { return this._y; }, set(a) { this._y = a, this._segmentChanged(); }, enumerable: !0 }), a.SVGPathSegCurvetoQuadraticSmoothRel = function (a, b, c) { SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL, 't', a), this._x = b, this._y = c; }, SVGPathSegCurvetoQuadraticSmoothRel.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegCurvetoQuadraticSmoothRel.prototype.toString = function () { return '[object SVGPathSegCurvetoQuadraticSmoothRel]'; }, SVGPathSegCurvetoQuadraticSmoothRel.prototype._asPathString = function () { return `${this.pathSegTypeAsLetter} ${this._x} ${this._y}`; }, SVGPathSegCurvetoQuadraticSmoothRel.prototype.clone = function () { return new SVGPathSegCurvetoQuadraticSmoothRel(void 0, this._x, this._y); }, Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothRel.prototype, 'x', { get() { return this._x; }, set(a) { this._x = a, this._segmentChanged(); }, enumerable: !0 }), Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothRel.prototype, 'y', { get() { return this._y; }, set(a) { this._y = a, this._segmentChanged(); }, enumerable: !0 }), SVGPathElement.prototype.createSVGPathSegClosePath = function () { return new SVGPathSegClosePath(void 0); }, SVGPathElement.prototype.createSVGPathSegMovetoAbs = function (a, b) { return new SVGPathSegMovetoAbs(void 0, a, b); }, SVGPathElement.prototype.createSVGPathSegMovetoRel = function (a, b) { return new SVGPathSegMovetoRel(void 0, a, b); }, SVGPathElement.prototype.createSVGPathSegLinetoAbs = function (a, b) { return new SVGPathSegLinetoAbs(void 0, a, b); }, SVGPathElement.prototype.createSVGPathSegLinetoRel = function (a, b) { return new SVGPathSegLinetoRel(void 0, a, b); }, SVGPathElement.prototype.createSVGPathSegCurvetoCubicAbs = function (a, b, c, d, e, f) { return new SVGPathSegCurvetoCubicAbs(void 0, a, b, c, d, e, f); }, SVGPathElement.prototype.createSVGPathSegCurvetoCubicRel = function (a, b, c, d, e, f) { return new SVGPathSegCurvetoCubicRel(void 0, a, b, c, d, e, f); }, SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticAbs = function (a, b, c, d) { return new SVGPathSegCurvetoQuadraticAbs(void 0, a, b, c, d); }, SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticRel = function (a, b, c, d) { return new SVGPathSegCurvetoQuadraticRel(void 0, a, b, c, d); }, SVGPathElement.prototype.createSVGPathSegArcAbs = function (a, b, c, d, e, f, g) { return new SVGPathSegArcAbs(void 0, a, b, c, d, e, f, g); }, SVGPathElement.prototype.createSVGPathSegArcRel = function (a, b, c, d, e, f, g) { return new SVGPathSegArcRel(void 0, a, b, c, d, e, f, g); }, SVGPathElement.prototype.createSVGPathSegLinetoHorizontalAbs = function (a) { return new SVGPathSegLinetoHorizontalAbs(void 0, a); }, SVGPathElement.prototype.createSVGPathSegLinetoHorizontalRel = function (a) { return new SVGPathSegLinetoHorizontalRel(void 0, a); }, SVGPathElement.prototype.createSVGPathSegLinetoVerticalAbs = function (a) { return new SVGPathSegLinetoVerticalAbs(void 0, a); }, SVGPathElement.prototype.createSVGPathSegLinetoVerticalRel = function (a) { return new SVGPathSegLinetoVerticalRel(void 0, a); }, SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothAbs = function (a, b, c, d) { return new SVGPathSegCurvetoCubicSmoothAbs(void 0, a, b, c, d); }, SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothRel = function (a, b, c, d) { return new SVGPathSegCurvetoCubicSmoothRel(void 0, a, b, c, d); }, SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothAbs = function (a, b) { return new SVGPathSegCurvetoQuadraticSmoothAbs(void 0, a, b); }, SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothRel = function (a, b) { return new SVGPathSegCurvetoQuadraticSmoothRel(void 0, a, b); }), 'SVGPathSegList' in a || (a.SVGPathSegList = function (a) { this._pathElement = a, this._list = this._parsePath(this._pathElement.getAttribute('d')), this._mutationObserverConfig = { attributes: !0, attributeFilter: ['d'] }, this._pathElementMutationObserver = new MutationObserver(this._updateListFromPathMutations.bind(this)), this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig); }, Object.defineProperty(SVGPathSegList.prototype, 'numberOfItems', { get() { return this._checkPathSynchronizedToList(), this._list.length; }, enumerable: !0 }), Object.defineProperty(SVGPathElement.prototype, 'pathSegList', { get() { return this._pathSegList || (this._pathSegList = new SVGPathSegList(this)), this._pathSegList; }, enumerable: !0 }), Object.defineProperty(SVGPathElement.prototype, 'normalizedPathSegList', { get() { return this.pathSegList; }, enumerable: !0 }), Object.defineProperty(SVGPathElement.prototype, 'animatedPathSegList', { get() { return this.pathSegList; }, enumerable: !0 }), Object.defineProperty(SVGPathElement.prototype, 'animatedNormalizedPathSegList', { get() { return this.pathSegList; }, enumerable: !0 }), SVGPathSegList.prototype._checkPathSynchronizedToList = function () { this._updateListFromPathMutations(this._pathElementMutationObserver.takeRecords()); }, SVGPathSegList.prototype._updateListFromPathMutations = function (a) { if (this._pathElement) { let b = !1; a.forEach((a) => { a.attributeName == 'd' && (b = !0); }), b && (this._list = this._parsePath(this._pathElement.getAttribute('d'))); } }, SVGPathSegList.prototype._writeListToPath = function () { this._pathElementMutationObserver.disconnect(), this._pathElement.setAttribute('d', SVGPathSegList._pathSegArrayAsString(this._list)), this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig); }, SVGPathSegList.prototype.segmentChanged = function (a) { this._writeListToPath(); }, SVGPathSegList.prototype.clear = function () { this._checkPathSynchronizedToList(), this._list.forEach((a) => { a._owningPathSegList = null; }), this._list = [], this._writeListToPath(); }, SVGPathSegList.prototype.initialize = function (a) { return this._checkPathSynchronizedToList(), this._list = [a], a._owningPathSegList = this, this._writeListToPath(), a; }, SVGPathSegList.prototype._checkValidIndex = function (a) { if (isNaN(a) || a < 0 || a >= this.numberOfItems) throw 'INDEX_SIZE_ERR'; }, SVGPathSegList.prototype.getItem = function (a) { return this._checkPathSynchronizedToList(), this._checkValidIndex(a), this._list[a]; }, SVGPathSegList.prototype.insertItemBefore = function (a, b) { return this._checkPathSynchronizedToList(), b > this.numberOfItems && (b = this.numberOfItems), a._owningPathSegList && (a = a.clone()), this._list.splice(b, 0, a), a._owningPathSegList = this, this._writeListToPath(), a; }, SVGPathSegList.prototype.replaceItem = function (a, b) { return this._checkPathSynchronizedToList(), a._owningPathSegList && (a = a.clone()), this._checkValidIndex(b), this._list[b] = a, a._owningPathSegList = this, this._writeListToPath(), a; }, SVGPathSegList.prototype.removeItem = function (a) { this._checkPathSynchronizedToList(), this._checkValidIndex(a); const b = this._list[a]; return this._list.splice(a, 1), this._writeListToPath(), b; }, SVGPathSegList.prototype.appendItem = function (a) { return this._checkPathSynchronizedToList(), a._owningPathSegList && (a = a.clone()), this._list.push(a), a._owningPathSegList = this, this._writeListToPath(), a; }, SVGPathSegList._pathSegArrayAsString = function (a) { let b = ''; let c = !0; return a.forEach((a) => { c ? (c = !1, b += a._asPathString()) : b += ` ${a._asPathString()}`; }), b; }, SVGPathSegList.prototype._parsePath = function (a) {
      if (!a || a.length == 0) return []; const b = this; const c = function () { this.pathSegList = []; }; c.prototype.appendSegment = function (a) { this.pathSegList.push(a); }; const d = function (a) { this._string = a, this._currentIndex = 0, this._endIndex = this._string.length, this._previousCommand = SVGPathSeg.PATHSEG_UNKNOWN, this._skipOptionalSpaces(); }; d.prototype._isCurrentSpace = function () { const a = this._string[this._currentIndex]; return a <= ' ' && (a == ' ' || a == '\n' || a == '	' || a == '\r' || a == '\f'); }, d.prototype._skipOptionalSpaces = function () { for (;this._currentIndex < this._endIndex && this._isCurrentSpace();) this._currentIndex++; return this._currentIndex < this._endIndex; }, d.prototype._skipOptionalSpacesOrDelimiter = function () { return this._currentIndex < this._endIndex && !this._isCurrentSpace() && this._string.charAt(this._currentIndex) != ',' ? !1 : (this._skipOptionalSpaces() && this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == ',' && (this._currentIndex++, this._skipOptionalSpaces()), this._currentIndex < this._endIndex); }, d.prototype.hasMoreData = function () { return this._currentIndex < this._endIndex; }, d.prototype.peekSegmentType = function () { const a = this._string[this._currentIndex]; return this._pathSegTypeFromChar(a); }, d.prototype._pathSegTypeFromChar = function (a) { switch (a) { case 'Z': case 'z': return SVGPathSeg.PATHSEG_CLOSEPATH; case 'M': return SVGPathSeg.PATHSEG_MOVETO_ABS; case 'm': return SVGPathSeg.PATHSEG_MOVETO_REL; case 'L': return SVGPathSeg.PATHSEG_LINETO_ABS; case 'l': return SVGPathSeg.PATHSEG_LINETO_REL; case 'C': return SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS; case 'c': return SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL; case 'Q': return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS; case 'q': return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL; case 'A': return SVGPathSeg.PATHSEG_ARC_ABS; case 'a': return SVGPathSeg.PATHSEG_ARC_REL; case 'H': return SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS; case 'h': return SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL; case 'V': return SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS; case 'v': return SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL; case 'S': return SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS; case 's': return SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL; case 'T': return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS; case 't': return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL; default: return SVGPathSeg.PATHSEG_UNKNOWN; } }, d.prototype._nextCommandHelper = function (a, b) { return (a == '+' || a == '-' || a == '.' || a >= '0' && a <= '9') && b != SVGPathSeg.PATHSEG_CLOSEPATH ? b == SVGPathSeg.PATHSEG_MOVETO_ABS ? SVGPathSeg.PATHSEG_LINETO_ABS : b == SVGPathSeg.PATHSEG_MOVETO_REL ? SVGPathSeg.PATHSEG_LINETO_REL : b : SVGPathSeg.PATHSEG_UNKNOWN; }, d.prototype.initialCommandIsMoveTo = function () { if (!this.hasMoreData()) return !0; const a = this.peekSegmentType(); return a == SVGPathSeg.PATHSEG_MOVETO_ABS || a == SVGPathSeg.PATHSEG_MOVETO_REL; }, d.prototype._parseNumber = function () { let a = 0; let b = 0; let c = 1; let d = 0; let e = 1; let f = 1; const g = this._currentIndex; if (this._skipOptionalSpaces(), this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == '+' ? this._currentIndex++ : this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == '-' && (this._currentIndex++, e = -1), !(this._currentIndex == this._endIndex || (this._string.charAt(this._currentIndex) < '0' || this._string.charAt(this._currentIndex) > '9') && this._string.charAt(this._currentIndex) != '.')) { for (var h = this._currentIndex; this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= '0' && this._string.charAt(this._currentIndex) <= '9';) this._currentIndex++; if (this._currentIndex != h) for (let i = this._currentIndex - 1, j = 1; i >= h;)b += j * (this._string.charAt(i--) - '0'), j *= 10; if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == '.') { if (this._currentIndex++, this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < '0' || this._string.charAt(this._currentIndex) > '9') return; for (;this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= '0' && this._string.charAt(this._currentIndex) <= '9';)d += (this._string.charAt(this._currentIndex++) - '0') * (c *= 0.1); } if (this._currentIndex != g && this._currentIndex + 1 < this._endIndex && (this._string.charAt(this._currentIndex) == 'e' || this._string.charAt(this._currentIndex) == 'E') && this._string.charAt(this._currentIndex + 1) != 'x' && this._string.charAt(this._currentIndex + 1) != 'm') { if (this._currentIndex++, this._string.charAt(this._currentIndex) == '+' ? this._currentIndex++ : this._string.charAt(this._currentIndex) == '-' && (this._currentIndex++, f = -1), this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < '0' || this._string.charAt(this._currentIndex) > '9') return; for (;this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= '0' && this._string.charAt(this._currentIndex) <= '9';)a *= 10, a += this._string.charAt(this._currentIndex) - '0', this._currentIndex++; } let k = b + d; if (k *= e, a && (k *= Math.pow(10, f * a)), g != this._currentIndex) return this._skipOptionalSpacesOrDelimiter(), k; } }, d.prototype._parseArcFlag = function () { if (!(this._currentIndex >= this._endIndex)) { let a = !1; const b = this._string.charAt(this._currentIndex++); if (b == '0')a = !1; else { if (b != '1') return; a = !0; } return this._skipOptionalSpacesOrDelimiter(), a; } }, d.prototype.parseSegment = function () {
        const a = this._string[this._currentIndex]; let c = this._pathSegTypeFromChar(a); if (c == SVGPathSeg.PATHSEG_UNKNOWN) { if (this._previousCommand == SVGPathSeg.PATHSEG_UNKNOWN) return null; if (c = this._nextCommandHelper(a, this._previousCommand), c == SVGPathSeg.PATHSEG_UNKNOWN) return null; } else this._currentIndex++; switch (this._previousCommand = c, c) {
          case SVGPathSeg.PATHSEG_MOVETO_REL: return new SVGPathSegMovetoRel(b, this._parseNumber(), this._parseNumber()); case SVGPathSeg.PATHSEG_MOVETO_ABS: return new SVGPathSegMovetoAbs(b, this._parseNumber(), this._parseNumber()); case SVGPathSeg.PATHSEG_LINETO_REL: return new SVGPathSegLinetoRel(b, this._parseNumber(), this._parseNumber()); case SVGPathSeg.PATHSEG_LINETO_ABS: return new SVGPathSegLinetoAbs(b, this._parseNumber(), this._parseNumber()); case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL: return new SVGPathSegLinetoHorizontalRel(b, this._parseNumber()); case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS: return new SVGPathSegLinetoHorizontalAbs(b, this._parseNumber()); case SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL: return new SVGPathSegLinetoVerticalRel(b, this._parseNumber()); case SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS: return new SVGPathSegLinetoVerticalAbs(b, this._parseNumber()); case SVGPathSeg.PATHSEG_CLOSEPATH: return this._skipOptionalSpaces(), new SVGPathSegClosePath(b); case SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL: var d = {
            x1: this._parseNumber(), y1: this._parseNumber(), x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber(),
          }; return new SVGPathSegCurvetoCubicRel(b, d.x, d.y, d.x1, d.y1, d.x2, d.y2); case SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS: var d = {
            x1: this._parseNumber(), y1: this._parseNumber(), x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber(),
          }; return new SVGPathSegCurvetoCubicAbs(b, d.x, d.y, d.x1, d.y1, d.x2, d.y2); case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL: var d = {
            x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber(),
          }; return new SVGPathSegCurvetoCubicSmoothRel(b, d.x, d.y, d.x2, d.y2); case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS: var d = {
            x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber(),
          }; return new SVGPathSegCurvetoCubicSmoothAbs(b, d.x, d.y, d.x2, d.y2); case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL: var d = {
            x1: this._parseNumber(), y1: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber(),
          }; return new SVGPathSegCurvetoQuadraticRel(b, d.x, d.y, d.x1, d.y1); case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS: var d = {
            x1: this._parseNumber(), y1: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber(),
          }; return new SVGPathSegCurvetoQuadraticAbs(b, d.x, d.y, d.x1, d.y1); case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: return new SVGPathSegCurvetoQuadraticSmoothRel(b, this._parseNumber(), this._parseNumber()); case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: return new SVGPathSegCurvetoQuadraticSmoothAbs(b, this._parseNumber(), this._parseNumber()); case SVGPathSeg.PATHSEG_ARC_REL: var d = {
            x1: this._parseNumber(), y1: this._parseNumber(), arcAngle: this._parseNumber(), arcLarge: this._parseArcFlag(), arcSweep: this._parseArcFlag(), x: this._parseNumber(), y: this._parseNumber(),
          }; return new SVGPathSegArcRel(b, d.x, d.y, d.x1, d.y1, d.arcAngle, d.arcLarge, d.arcSweep); case SVGPathSeg.PATHSEG_ARC_ABS: var d = {
            x1: this._parseNumber(), y1: this._parseNumber(), arcAngle: this._parseNumber(), arcLarge: this._parseArcFlag(), arcSweep: this._parseArcFlag(), x: this._parseNumber(), y: this._parseNumber(),
          }; return new SVGPathSegArcAbs(b, d.x, d.y, d.x1, d.y1, d.arcAngle, d.arcLarge, d.arcSweep); default: throw 'Unknown path seg type.';
        }
      }; const e = new c(); const
        f = new d(a); if (!f.initialCommandIsMoveTo()) return []; for (;f.hasMoreData();) { const g = f.parseSegment(); if (!g) return []; e.appendSegment(g); } return e.pathSegList;
    });
  }()), typeof define === 'function' && define.amd ? define('c3', ['d3'], () => k) : typeof exports !== 'undefined' && typeof module !== 'undefined' ? module.exports = k : a.c3 = k;
}(window));
