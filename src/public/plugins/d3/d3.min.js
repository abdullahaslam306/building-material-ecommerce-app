!(function () {
  function n(n, t) { return t > n ? -1 : n > t ? 1 : n >= t ? 0 : 0 / 0; } function t(n) { return n === null ? 0 / 0 : +n; } function e(n) { return !isNaN(n); } function r(n) { return { left(t, e, r, u) { for (arguments.length < 3 && (r = 0), arguments.length < 4 && (u = t.length); u > r;) { const i = r + u >>> 1; n(t[i], e) < 0 ? r = i + 1 : u = i; } return r; }, right(t, e, r, u) { for (arguments.length < 3 && (r = 0), arguments.length < 4 && (u = t.length); u > r;) { const i = r + u >>> 1; n(t[i], e) > 0 ? u = i : r = i + 1; } return r; } }; } function u(n) { return n.length; } function i(n) { for (var t = 1; n * t % 1;)t *= 10; return t; } function o(n, t) { for (const e in t)Object.defineProperty(n.prototype, e, { value: t[e], enumerable: !1 }); } function a() { this._ = Object.create(null); } function c(n) { return (n += '') === da || n[0] === ma ? ma + n : n; } function l(n) { return (n += '')[0] === ma ? n.slice(1) : n; } function s(n) { return c(n) in this._; } function f(n) { return (n = c(n)) in this._ && delete this._[n]; } function h() { const n = []; for (const t in this._)n.push(l(t)); return n; } function g() { let n = 0; for (const t in this._)++n; return n; } function p() { for (const n in this._) return !1; return !0; } function v() { this._ = Object.create(null); } function d(n, t, e) { return function () { const r = e.apply(t, arguments); return r === t ? n : r; }; } function m(n, t) { if (t in n) return t; t = t.charAt(0).toUpperCase() + t.slice(1); for (let e = 0, r = ya.length; r > e; ++e) { const u = ya[e] + t; if (u in n) return u; } } function y() {} function M() {} function x(n) { function t() { for (var t, r = e, u = -1, i = r.length; ++u < i;)(t = r[u].on) && t.apply(this, arguments); return n; } var e = []; const r = new a(); return t.on = function (t, u) { let i; const o = r.get(t); return arguments.length < 2 ? o && o.on : (o && (o.on = null, e = e.slice(0, i = e.indexOf(o)).concat(e.slice(i + 1)), r.remove(t)), u && e.push(r.set(t, { on: u })), n); }, t; } function b() { ta.event.preventDefault(); } function _() { for (var n, t = ta.event; n = t.sourceEvent;)t = n; return t; } function w(n) { for (var t = new M(), e = 0, r = arguments.length; ++e < r;)t[arguments[e]] = x(t); return t.of = function (e, r) { return function (u) { try { var i = u.sourceEvent = ta.event; u.target = n, ta.event = u, t[u.type].apply(e, r); } finally { ta.event = i; } }; }, t; } function S(n) { return xa(n, ka), n; } function k(n) { return typeof n === 'function' ? n : function () { return ba(n, this); }; } function E(n) { return typeof n === 'function' ? n : function () { return _a(n, this); }; } function A(n, t) { function e() { this.removeAttribute(n); } function r() { this.removeAttributeNS(n.space, n.local); } function u() { this.setAttribute(n, t); } function i() { this.setAttributeNS(n.space, n.local, t); } function o() { const e = t.apply(this, arguments); e == null ? this.removeAttribute(n) : this.setAttribute(n, e); } function a() { const e = t.apply(this, arguments); e == null ? this.removeAttributeNS(n.space, n.local) : this.setAttributeNS(n.space, n.local, e); } return n = ta.ns.qualify(n), t == null ? n.local ? r : e : typeof t === 'function' ? n.local ? a : o : n.local ? i : u; } function N(n) { return n.trim().replace(/\s+/g, ' '); } function C(n) { return new RegExp(`(?:^|\\s+)${ta.requote(n)}(?:\\s+|$)`, 'g'); } function z(n) { return (`${n}`).trim().split(/^|\s+/); } function q(n, t) { function e() { for (let e = -1; ++e < u;)n[e](this, t); } function r() { for (let e = -1, r = t.apply(this, arguments); ++e < u;)n[e](this, r); }n = z(n).map(L); var u = n.length; return typeof t === 'function' ? r : e; } function L(n) { const t = C(n); return function (e, r) { if (u = e.classList) return r ? u.add(n) : u.remove(n); var u = e.getAttribute('class') || ''; r ? (t.lastIndex = 0, t.test(u) || e.setAttribute('class', N(`${u} ${n}`))) : e.setAttribute('class', N(u.replace(t, ' '))); }; } function T(n, t, e) { function r() { this.style.removeProperty(n); } function u() { this.style.setProperty(n, t, e); } function i() { const r = t.apply(this, arguments); r == null ? this.style.removeProperty(n) : this.style.setProperty(n, r, e); } return t == null ? r : typeof t === 'function' ? i : u; } function R(n, t) { function e() { delete this[n]; } function r() { this[n] = t; } function u() { const e = t.apply(this, arguments); e == null ? delete this[n] : this[n] = e; } return t == null ? e : typeof t === 'function' ? u : r; } function D(n) { return typeof n === 'function' ? n : (n = ta.ns.qualify(n)).local ? function () { return this.ownerDocument.createElementNS(n.space, n.local); } : function () { return this.ownerDocument.createElementNS(this.namespaceURI, n); }; } function P() { const n = this.parentNode; n && n.removeChild(this); } function U(n) { return { __data__: n }; } function j(n) { return function () { return Sa(this, n); }; } function F(t) { return arguments.length || (t = n), function (n, e) { return n && e ? t(n.__data__, e.__data__) : !n - !e; }; } function H(n, t) { for (let e = 0, r = n.length; r > e; e++) for (var u, i = n[e], o = 0, a = i.length; a > o; o++)(u = i[o]) && t(u, o, e); return n; } function O(n) { return xa(n, Aa), n; } function Y(n) { let t; let e; return function (r, u, i) { let o; const a = n[i].update; const c = a.length; for (i != e && (e = i, t = 0), u >= t && (t = u + 1); !(o = a[t]) && ++t < c;);return o; }; } function I(n) { const t = n.__transition__; t && ++t.active; } function Z(n, t, e) { function r() { const t = this[o]; t && (this.removeEventListener(n, t, t.$), delete this[o]); } function u() { const u = c(t, ra(arguments)); r.call(this), this.addEventListener(n, this[o] = u, u.$ = e), u._ = t; } function i() { let t; const e = new RegExp(`^__on([^.]+)${ta.requote(n)}$`); for (const r in this) if (t = r.match(e)) { const u = this[r]; this.removeEventListener(t[1], u, u.$), delete this[r]; } } var o = `__on${n}`; const a = n.indexOf('.'); var c = V; a > 0 && (n = n.slice(0, a)); const l = Ca.get(n); return l && (n = l, c = X), a ? t ? u : r : t ? y : i; } function V(n, t) { return function (e) { const r = ta.event; ta.event = e, t[0] = this.__data__; try { n.apply(this, t); } finally { ta.event = r; } }; } function X(n, t) { const e = V(n, t); return function (n) { const t = this; const r = n.relatedTarget; r && (r === t || 8 & r.compareDocumentPosition(t)) || e.call(t, n); }; } function $() { const n = `.dragsuppress-${++qa}`; const t = `click${n}`; const e = ta.select(oa).on(`touchmove${n}`, b).on(`dragstart${n}`, b).on(`selectstart${n}`, b); if (za) { var r = ia.style; var u = r[za]; r[za] = 'none'; } return function (i) { if (e.on(n, null), za && (r[za] = u), i) { const o = function () { e.on(t, null); }; e.on(t, () => { b(), o(); }, !0), setTimeout(o, 0); } }; } function B(n, t) {
    t.changedTouches && (t = t.changedTouches[0]); let e = n.ownerSVGElement || n; if (e.createSVGPoint) {
      let r = e.createSVGPoint(); if (La < 0 && (oa.scrollX || oa.scrollY)) {
        e = ta.select('body').append('svg').style({
          position: 'absolute', top: 0, left: 0, margin: 0, padding: 0, border: 'none',
        }, 'important'); const u = e[0][0].getScreenCTM(); La = !(u.f || u.e), e.remove();
      } return La ? (r.x = t.pageX, r.y = t.pageY) : (r.x = t.clientX, r.y = t.clientY), r = r.matrixTransform(n.getScreenCTM().inverse()), [r.x, r.y];
    } const i = n.getBoundingClientRect(); return [t.clientX - i.left - n.clientLeft, t.clientY - i.top - n.clientTop];
  } function W() { return ta.event.changedTouches[0].identifier; } function J() { return ta.event.target; } function G() { return oa; } function K(n) { return n > 0 ? 1 : n < 0 ? -1 : 0; } function Q(n, t, e) { return (t[0] - n[0]) * (e[1] - n[1]) - (t[1] - n[1]) * (e[0] - n[0]); } function nt(n) { return n > 1 ? 0 : n < -1 ? Da : Math.acos(n); } function tt(n) { return n > 1 ? ja : n < -1 ? -ja : Math.asin(n); } function et(n) { return ((n = Math.exp(n)) - 1 / n) / 2; } function rt(n) { return ((n = Math.exp(n)) + 1 / n) / 2; } function ut(n) { return ((n = Math.exp(2 * n)) - 1) / (n + 1); } function it(n) { return (n = Math.sin(n / 2)) * n; } function ot() {} function at(n, t, e) { return this instanceof at ? (this.h = +n, this.s = +t, void (this.l = +e)) : arguments.length < 2 ? n instanceof at ? new at(n.h, n.s, n.l) : bt(`${n}`, _t, at) : new at(n, t, e); } function ct(n, t, e) { function r(n) { return n > 360 ? n -= 360 : n < 0 && (n += 360), n < 60 ? i + (o - i) * n / 60 : n < 180 ? o : n < 240 ? i + (o - i) * (240 - n) / 60 : i; } function u(n) { return Math.round(255 * r(n)); } let i; let o; return n = isNaN(n) ? 0 : (n %= 360) < 0 ? n + 360 : n, t = isNaN(t) ? 0 : t < 0 ? 0 : t > 1 ? 1 : t, e = e < 0 ? 0 : e > 1 ? 1 : e, o = e <= 0.5 ? e * (1 + t) : e + t - e * t, i = 2 * e - o, new mt(u(n + 120), u(n), u(n - 120)); } function lt(n, t, e) { return this instanceof lt ? (this.h = +n, this.c = +t, void (this.l = +e)) : arguments.length < 2 ? n instanceof lt ? new lt(n.h, n.c, n.l) : n instanceof ft ? gt(n.l, n.a, n.b) : gt((n = wt((n = ta.rgb(n)).r, n.g, n.b)).l, n.a, n.b) : new lt(n, t, e); } function st(n, t, e) { return isNaN(n) && (n = 0), isNaN(t) && (t = 0), new ft(e, Math.cos(n *= Fa) * t, Math.sin(n) * t); } function ft(n, t, e) { return this instanceof ft ? (this.l = +n, this.a = +t, void (this.b = +e)) : arguments.length < 2 ? n instanceof ft ? new ft(n.l, n.a, n.b) : n instanceof lt ? st(n.h, n.c, n.l) : wt((n = mt(n)).r, n.g, n.b) : new ft(n, t, e); } function ht(n, t, e) { let r = (n + 16) / 116; let u = r + t / 500; let i = r - e / 200; return u = pt(u) * Ja, r = pt(r) * Ga, i = pt(i) * Ka, new mt(dt(3.2404542 * u - 1.5371385 * r - 0.4985314 * i), dt(-0.969266 * u + 1.8760108 * r + 0.041556 * i), dt(0.0556434 * u - 0.2040259 * r + 1.0572252 * i)); } function gt(n, t, e) { return n > 0 ? new lt(Math.atan2(e, t) * Ha, Math.sqrt(t * t + e * e), n) : new lt(0 / 0, 0 / 0, n); } function pt(n) { return n > 0.206893034 ? n * n * n : (n - 4 / 29) / 7.787037; } function vt(n) { return n > 0.008856 ? Math.pow(n, 1 / 3) : 7.787037 * n + 4 / 29; } function dt(n) { return Math.round(255 * (n <= 0.00304 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - 0.055)); } function mt(n, t, e) { return this instanceof mt ? (this.r = ~~n, this.g = ~~t, void (this.b = ~~e)) : arguments.length < 2 ? n instanceof mt ? new mt(n.r, n.g, n.b) : bt(`${n}`, mt, ct) : new mt(n, t, e); } function yt(n) { return new mt(n >> 16, 255 & n >> 8, 255 & n); } function Mt(n) { return `${yt(n)}`; } function xt(n) { return n < 16 ? `0${Math.max(0, n).toString(16)}` : Math.min(255, n).toString(16); } function bt(n, t, e) { let r; let u; let i; let o = 0; let a = 0; let c = 0; if (r = /([a-z]+)\((.*)\)/i.exec(n)) switch (u = r[2].split(','), r[1]) { case 'hsl': return e(parseFloat(u[0]), parseFloat(u[1]) / 100, parseFloat(u[2]) / 100); case 'rgb': return t(kt(u[0]), kt(u[1]), kt(u[2])); } return (i = tc.get(n)) ? t(i.r, i.g, i.b) : (n == null || n.charAt(0) !== '#' || isNaN(i = parseInt(n.slice(1), 16)) || (n.length === 4 ? (o = (3840 & i) >> 4, o = o >> 4 | o, a = 240 & i, a = a >> 4 | a, c = 15 & i, c = c << 4 | c) : n.length === 7 && (o = (16711680 & i) >> 16, a = (65280 & i) >> 8, c = 255 & i)), t(o, a, c)); } function _t(n, t, e) { let r; let u; const i = Math.min(n /= 255, t /= 255, e /= 255); const o = Math.max(n, t, e); const a = o - i; const c = (o + i) / 2; return a ? (u = c < 0.5 ? a / (o + i) : a / (2 - o - i), r = n == o ? (t - e) / a + (e > t ? 6 : 0) : t == o ? (e - n) / a + 2 : (n - t) / a + 4, r *= 60) : (r = 0 / 0, u = c > 0 && c < 1 ? 0 : r), new at(r, u, c); } function wt(n, t, e) { n = St(n), t = St(t), e = St(e); const r = vt((0.4124564 * n + 0.3575761 * t + 0.1804375 * e) / Ja); const u = vt((0.2126729 * n + 0.7151522 * t + 0.072175 * e) / Ga); const i = vt((0.0193339 * n + 0.119192 * t + 0.9503041 * e) / Ka); return ft(116 * u - 16, 500 * (r - u), 200 * (u - i)); } function St(n) { return (n /= 255) <= 0.04045 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4); } function kt(n) { const t = parseFloat(n); return n.charAt(n.length - 1) === '%' ? Math.round(2.55 * t) : t; } function Et(n) { return typeof n === 'function' ? n : function () { return n; }; } function At(n) { return n; } function Nt(n) { return function (t, e, r) { return arguments.length === 2 && typeof e === 'function' && (r = e, e = null), Ct(t, e, n, r); }; } function Ct(n, t, e, r) { function u() { let n; const t = c.status; if (!t && qt(c) || t >= 200 && t < 300 || t === 304) { try { n = e.call(i, c); } catch (r) { return o.error.call(i, r), void 0; }o.load.call(i, n); } else o.error.call(i, c); } var i = {}; var o = ta.dispatch('beforesend', 'progress', 'load', 'error'); const a = {}; var c = new XMLHttpRequest(); let l = null; return !oa.XDomainRequest || 'withCredentials' in c || !/^(http(s)?:)?\/\//.test(n) || (c = new XDomainRequest()), 'onload' in c ? c.onload = c.onerror = u : c.onreadystatechange = function () { c.readyState > 3 && u(); }, c.onprogress = function (n) { const t = ta.event; ta.event = n; try { o.progress.call(i, c); } finally { ta.event = t; } }, i.header = function (n, t) { return n = (`${n}`).toLowerCase(), arguments.length < 2 ? a[n] : (t == null ? delete a[n] : a[n] = `${t}`, i); }, i.mimeType = function (n) { return arguments.length ? (t = n == null ? null : `${n}`, i) : t; }, i.responseType = function (n) { return arguments.length ? (l = n, i) : l; }, i.response = function (n) { return e = n, i; }, ['get', 'post'].forEach((n) => { i[n] = function () { return i.send.apply(i, [n].concat(ra(arguments))); }; }), i.send = function (e, r, u) { if (arguments.length === 2 && typeof r === 'function' && (u = r, r = null), c.open(e, n, !0), t == null || 'accept' in a || (a.accept = `${t},*/*`), c.setRequestHeader) for (const s in a)c.setRequestHeader(s, a[s]); return t != null && c.overrideMimeType && c.overrideMimeType(t), l != null && (c.responseType = l), u != null && i.on('error', u).on('load', (n) => { u(null, n); }), o.beforesend.call(i, c), c.send(r == null ? null : r), i; }, i.abort = function () { return c.abort(), i; }, ta.rebind(i, o, 'on'), r == null ? i : i.get(zt(r)); } function zt(n) { return n.length === 1 ? function (t, e) { n(t == null ? e : null); } : n; } function qt(n) { const t = n.responseType; return t && t !== 'text' ? n.response : n.responseText; } function Lt() { const n = Tt(); const t = Rt() - n; t > 24 ? (isFinite(t) && (clearTimeout(ic), ic = setTimeout(Lt, t)), uc = 0) : (uc = 1, ac(Lt)); } function Tt() { const n = Date.now(); for (oc = ec; oc;)n >= oc.t && (oc.f = oc.c(n - oc.t)), oc = oc.n; return n; } function Rt() { for (var n, t = ec, e = 1 / 0; t;)t.f ? t = n ? n.n = t.n : ec = t.n : (t.t < e && (e = t.t), t = (n = t).n); return rc = n, e; } function Dt(n, t) { return t - (n ? Math.ceil(Math.log(n) / Math.LN10) : 1); } function Pt(n, t) { const e = Math.pow(10, 3 * va(8 - t)); return { scale: t > 8 ? function (n) { return n / e; } : function (n) { return n * e; }, symbol: n }; } function Ut(n) { const t = n.decimal; const e = n.thousands; const r = n.grouping; const u = n.currency; const i = r && e ? function (n, t) { for (var u = n.length, i = [], o = 0, a = r[0], c = 0; u > 0 && a > 0 && (c + a + 1 > t && (a = Math.max(1, t - c)), i.push(n.substring(u -= a, u + a)), !((c += a + 1) > t));)a = r[o = (o + 1) % r.length]; return i.reverse().join(e); } : At; return function (n) { const e = lc.exec(n); let r = e[1] || ' '; let o = e[2] || '>'; const a = e[3] || '-'; const c = e[4] || ''; let l = e[5]; const s = +e[6]; let f = e[7]; let h = e[8]; let g = e[9]; let p = 1; let v = ''; let d = ''; let m = !1; let y = !0; switch (h && (h = +h.substring(1)), (l || r === '0' && o === '=') && (l = r = '0', o = '='), g) { case 'n': f = !0, g = 'g'; break; case '%': p = 100, d = '%', g = 'f'; break; case 'p': p = 100, d = '%', g = 'r'; break; case 'b': case 'o': case 'x': case 'X': c === '#' && (v = `0${g.toLowerCase()}`); case 'c': y = !1; case 'd': m = !0, h = 0; break; case 's': p = -1, g = 'r'; }c === '$' && (v = u[0], d = u[1]), g != 'r' || h || (g = 'g'), h != null && (g == 'g' ? h = Math.max(1, Math.min(21, h)) : (g == 'e' || g == 'f') && (h = Math.max(0, Math.min(20, h)))), g = sc.get(g) || jt; const M = l && f; return function (n) { let e = d; if (m && n % 1) return ''; let u = n < 0 || n === 0 && 1 / n < 0 ? (n = -n, '-') : a === '-' ? '' : a; if (p < 0) { const c = ta.formatPrefix(n, h); n = c.scale(n), e = c.symbol + d; } else n *= p; n = g(n, h); let x; let b; const _ = n.lastIndexOf('.'); if (_ < 0) { const w = y ? n.lastIndexOf('e') : -1; w < 0 ? (x = n, b = '') : (x = n.substring(0, w), b = n.substring(w)); } else x = n.substring(0, _), b = t + n.substring(_ + 1); !l && f && (x = i(x, 1 / 0)); let S = v.length + x.length + b.length + (M ? 0 : u.length); const k = s > S ? new Array(S = s - S + 1).join(r) : ''; return M && (x = i(k + x, k.length ? s - b.length : 1 / 0)), u += v, n = x + b, (o === '<' ? u + n + k : o === '>' ? k + u + n : o === '^' ? k.substring(0, S >>= 1) + u + n + k.substring(S) : u + (M ? n : k + n)) + e; }; }; } function jt(n) { return `${n}`; } function Ft() { this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]); } function Ht(n, t, e) { function r(t) { const e = n(t); const r = i(e, 1); return r - t > t - e ? e : r; } function u(e) { return t(e = n(new hc(e - 1)), 1), e; } function i(n, e) { return t(n = new hc(+n), e), n; } function o(n, r, i) { const o = u(n); const a = []; if (i > 1) for (;r > o;)e(o) % i || a.push(new Date(+o)), t(o, 1); else for (;r > o;)a.push(new Date(+o)), t(o, 1); return a; } function a(n, t, e) { try { hc = Ft; const r = new Ft(); return r._ = n, o(r, t, e); } finally { hc = Date; } }n.floor = n, n.round = r, n.ceil = u, n.offset = i, n.range = o; const c = n.utc = Ot(n); return c.floor = c, c.round = Ot(r), c.ceil = Ot(u), c.offset = Ot(i), c.range = a, n; } function Ot(n) { return function (t, e) { try { hc = Ft; const r = new Ft(); return r._ = t, n(r, e)._; } finally { hc = Date; } }; } function Yt(n) {
    function t(n) {
      function t(t) { for (var e, u, i, o = [], a = -1, c = 0; ++a < r;)n.charCodeAt(a) === 37 && (o.push(n.slice(c, a)), (u = pc[e = n.charAt(++a)]) != null && (e = n.charAt(++a)), (i = N[e]) && (e = i(t, u == null ? e === 'e' ? ' ' : '0' : u)), o.push(e), c = a + 1); return o.push(n.slice(c, a)), o.join(''); } var r = n.length; return t.parse = function (t) {
        const r = {
          y: 1900, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0, Z: null,
        }; const u = e(r, n, t, 0); if (u != t.length) return null; 'p' in r && (r.H = r.H % 12 + 12 * r.p); const i = r.Z != null && hc !== Ft; const o = new (i ? Ft : hc)(); return 'j' in r ? o.setFullYear(r.y, 0, r.j) : 'w' in r && ('W' in r || 'U' in r) ? (o.setFullYear(r.y, 0, 1), o.setFullYear(r.y, 0, 'W' in r ? (r.w + 6) % 7 + 7 * r.W - (o.getDay() + 5) % 7 : r.w + 7 * r.U - (o.getDay() + 6) % 7)) : o.setFullYear(r.y, r.m, r.d), o.setHours(r.H + (0 | r.Z / 100), r.M + r.Z % 100, r.S, r.L), i ? o._ : o;
      }, t.toString = function () { return n; }, t;
    } function e(n, t, e, r) { for (var u, i, o, a = 0, c = t.length, l = e.length; c > a;) { if (r >= l) return -1; if (u = t.charCodeAt(a++), u === 37) { if (o = t.charAt(a++), i = C[o in pc ? t.charAt(a++) : o], !i || (r = i(n, e, r)) < 0) return -1; } else if (u != e.charCodeAt(r++)) return -1; } return r; } function r(n, t, e) { _.lastIndex = 0; const r = _.exec(t.slice(e)); return r ? (n.w = w.get(r[0].toLowerCase()), e + r[0].length) : -1; } function u(n, t, e) { x.lastIndex = 0; const r = x.exec(t.slice(e)); return r ? (n.w = b.get(r[0].toLowerCase()), e + r[0].length) : -1; } function i(n, t, e) { E.lastIndex = 0; const r = E.exec(t.slice(e)); return r ? (n.m = A.get(r[0].toLowerCase()), e + r[0].length) : -1; } function o(n, t, e) { S.lastIndex = 0; const r = S.exec(t.slice(e)); return r ? (n.m = k.get(r[0].toLowerCase()), e + r[0].length) : -1; } function a(n, t, r) { return e(n, N.c.toString(), t, r); } function c(n, t, r) { return e(n, N.x.toString(), t, r); } function l(n, t, r) { return e(n, N.X.toString(), t, r); } function s(n, t, e) { const r = M.get(t.slice(e, e += 2).toLowerCase()); return r == null ? -1 : (n.p = r, e); } const f = n.dateTime; const h = n.date; const g = n.time; const p = n.periods; const v = n.days; const d = n.shortDays; const m = n.months; const y = n.shortMonths; t.utc = function (n) { function e(n) { try { hc = Ft; const t = new hc(); return t._ = n, r(t); } finally { hc = Date; } } var r = t(n); return e.parse = function (n) { try { hc = Ft; const t = r.parse(n); return t && t._; } finally { hc = Date; } }, e.toString = r.toString, e; }, t.multi = t.utc.multi = ce; var M = ta.map(); var x = Zt(v); var b = Vt(v); var _ = Zt(d); var w = Vt(d); var S = Zt(m); var k = Vt(m); var E = Zt(y); var A = Vt(y); p.forEach((n, t) => { M.set(n.toLowerCase(), t); }); var N = {
      a(n) { return d[n.getDay()]; }, A(n) { return v[n.getDay()]; }, b(n) { return y[n.getMonth()]; }, B(n) { return m[n.getMonth()]; }, c: t(f), d(n, t) { return It(n.getDate(), t, 2); }, e(n, t) { return It(n.getDate(), t, 2); }, H(n, t) { return It(n.getHours(), t, 2); }, I(n, t) { return It(n.getHours() % 12 || 12, t, 2); }, j(n, t) { return It(1 + fc.dayOfYear(n), t, 3); }, L(n, t) { return It(n.getMilliseconds(), t, 3); }, m(n, t) { return It(n.getMonth() + 1, t, 2); }, M(n, t) { return It(n.getMinutes(), t, 2); }, p(n) { return p[+(n.getHours() >= 12)]; }, S(n, t) { return It(n.getSeconds(), t, 2); }, U(n, t) { return It(fc.sundayOfYear(n), t, 2); }, w(n) { return n.getDay(); }, W(n, t) { return It(fc.mondayOfYear(n), t, 2); }, x: t(h), X: t(g), y(n, t) { return It(n.getFullYear() % 100, t, 2); }, Y(n, t) { return It(n.getFullYear() % 1e4, t, 4); }, Z: oe, '%': function () { return '%'; },
    }; var C = {
      a: r, A: u, b: i, B: o, c: a, d: ne, e: ne, H: ee, I: ee, j: te, L: ie, m: Qt, M: re, p: s, S: ue, U: $t, w: Xt, W: Bt, x: c, X: l, y: Jt, Y: Wt, Z: Gt, '%': ae,
    }; return t;
  } function It(n, t, e) { const r = n < 0 ? '-' : ''; const u = `${r ? -n : n}`; const i = u.length; return r + (e > i ? new Array(e - i + 1).join(t) + u : u); } function Zt(n) { return new RegExp(`^(?:${n.map(ta.requote).join('|')})`, 'i'); } function Vt(n) { for (var t = new a(), e = -1, r = n.length; ++e < r;)t.set(n[e].toLowerCase(), e); return t; } function Xt(n, t, e) { vc.lastIndex = 0; const r = vc.exec(t.slice(e, e + 1)); return r ? (n.w = +r[0], e + r[0].length) : -1; } function $t(n, t, e) { vc.lastIndex = 0; const r = vc.exec(t.slice(e)); return r ? (n.U = +r[0], e + r[0].length) : -1; } function Bt(n, t, e) { vc.lastIndex = 0; const r = vc.exec(t.slice(e)); return r ? (n.W = +r[0], e + r[0].length) : -1; } function Wt(n, t, e) { vc.lastIndex = 0; const r = vc.exec(t.slice(e, e + 4)); return r ? (n.y = +r[0], e + r[0].length) : -1; } function Jt(n, t, e) { vc.lastIndex = 0; const r = vc.exec(t.slice(e, e + 2)); return r ? (n.y = Kt(+r[0]), e + r[0].length) : -1; } function Gt(n, t, e) { return /^[+-]\d{4}$/.test(t = t.slice(e, e + 5)) ? (n.Z = -t, e + 5) : -1; } function Kt(n) { return n + (n > 68 ? 1900 : 2e3); } function Qt(n, t, e) { vc.lastIndex = 0; const r = vc.exec(t.slice(e, e + 2)); return r ? (n.m = r[0] - 1, e + r[0].length) : -1; } function ne(n, t, e) { vc.lastIndex = 0; const r = vc.exec(t.slice(e, e + 2)); return r ? (n.d = +r[0], e + r[0].length) : -1; } function te(n, t, e) { vc.lastIndex = 0; const r = vc.exec(t.slice(e, e + 3)); return r ? (n.j = +r[0], e + r[0].length) : -1; } function ee(n, t, e) { vc.lastIndex = 0; const r = vc.exec(t.slice(e, e + 2)); return r ? (n.H = +r[0], e + r[0].length) : -1; } function re(n, t, e) { vc.lastIndex = 0; const r = vc.exec(t.slice(e, e + 2)); return r ? (n.M = +r[0], e + r[0].length) : -1; } function ue(n, t, e) { vc.lastIndex = 0; const r = vc.exec(t.slice(e, e + 2)); return r ? (n.S = +r[0], e + r[0].length) : -1; } function ie(n, t, e) { vc.lastIndex = 0; const r = vc.exec(t.slice(e, e + 3)); return r ? (n.L = +r[0], e + r[0].length) : -1; } function oe(n) { const t = n.getTimezoneOffset(); const e = t > 0 ? '-' : '+'; const r = 0 | va(t) / 60; const u = va(t) % 60; return e + It(r, '0', 2) + It(u, '0', 2); } function ae(n, t, e) { dc.lastIndex = 0; const r = dc.exec(t.slice(e, e + 1)); return r ? e + r[0].length : -1; } function ce(n) { for (let t = n.length, e = -1; ++e < t;)n[e][0] = this(n[e][0]); return function (t) { for (var e = 0, r = n[e]; !r[1](t);)r = n[++e]; return r[0](t); }; } function le() {} function se(n, t, e) { const r = e.s = n + t; const u = r - n; const i = r - u; e.t = n - i + (t - u); } function fe(n, t) { n && xc.hasOwnProperty(n.type) && xc[n.type](n, t); } function he(n, t, e) { let r; let u = -1; const i = n.length - e; for (t.lineStart(); ++u < i;)r = n[u], t.point(r[0], r[1], r[2]); t.lineEnd(); } function ge(n, t) { let e = -1; const r = n.length; for (t.polygonStart(); ++e < r;)he(n[e], t, 1); t.polygonEnd(); } function pe() { function n(n, t) { n *= Fa, t = t * Fa / 2 + Da / 4; const e = n - r; const o = e >= 0 ? 1 : -1; const a = o * e; const c = Math.cos(t); const l = Math.sin(t); const s = i * l; const f = u * c + s * Math.cos(a); const h = s * o * Math.sin(a); _c.add(Math.atan2(h, f)), r = n, u = c, i = l; } let t; let e; let r; let u; let i; wc.point = function (o, a) { wc.point = n, r = (t = o) * Fa, u = Math.cos(a = (e = a) * Fa / 2 + Da / 4), i = Math.sin(a); }, wc.lineEnd = function () { n(t, e); }; } function ve(n) { const t = n[0]; const e = n[1]; const r = Math.cos(e); return [r * Math.cos(t), r * Math.sin(t), Math.sin(e)]; } function de(n, t) { return n[0] * t[0] + n[1] * t[1] + n[2] * t[2]; } function me(n, t) { return [n[1] * t[2] - n[2] * t[1], n[2] * t[0] - n[0] * t[2], n[0] * t[1] - n[1] * t[0]]; } function ye(n, t) { n[0] += t[0], n[1] += t[1], n[2] += t[2]; } function Me(n, t) { return [n[0] * t, n[1] * t, n[2] * t]; } function xe(n) { const t = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]); n[0] /= t, n[1] /= t, n[2] /= t; } function be(n) { return [Math.atan2(n[1], n[0]), tt(n[2])]; } function _e(n, t) { return va(n[0] - t[0]) < Ta && va(n[1] - t[1]) < Ta; } function we(n, t) { n *= Fa; const e = Math.cos(t *= Fa); Se(e * Math.cos(n), e * Math.sin(n), Math.sin(t)); } function Se(n, t, e) { ++Sc, Ec += (n - Ec) / Sc, Ac += (t - Ac) / Sc, Nc += (e - Nc) / Sc; } function ke() { function n(n, u) { n *= Fa; const i = Math.cos(u *= Fa); const o = i * Math.cos(n); const a = i * Math.sin(n); const c = Math.sin(u); var l = Math.atan2(Math.sqrt((l = e * c - r * a) * l + (l = r * o - t * c) * l + (l = t * a - e * o) * l), t * o + e * a + r * c); kc += l, Cc += l * (t + (t = o)), zc += l * (e + (e = a)), qc += l * (r + (r = c)), Se(t, e, r); } let t; let e; let r; Dc.point = function (u, i) { u *= Fa; const o = Math.cos(i *= Fa); t = o * Math.cos(u), e = o * Math.sin(u), r = Math.sin(i), Dc.point = n, Se(t, e, r); }; } function Ee() { Dc.point = we; } function Ae() { function n(n, t) { n *= Fa; const e = Math.cos(t *= Fa); const o = e * Math.cos(n); const a = e * Math.sin(n); const c = Math.sin(t); const l = u * c - i * a; const s = i * o - r * c; const f = r * a - u * o; const h = Math.sqrt(l * l + s * s + f * f); const g = r * o + u * a + i * c; const p = h && -nt(g) / h; const v = Math.atan2(h, g); Lc += p * l, Tc += p * s, Rc += p * f, kc += v, Cc += v * (r + (r = o)), zc += v * (u + (u = a)), qc += v * (i + (i = c)), Se(r, u, i); } let t; let e; let r; let u; let i; Dc.point = function (o, a) { t = o, e = a, Dc.point = n, o *= Fa; const c = Math.cos(a *= Fa); r = c * Math.cos(o), u = c * Math.sin(o), i = Math.sin(a), Se(r, u, i); }, Dc.lineEnd = function () { n(t, e), Dc.lineEnd = Ee, Dc.point = we; }; } function Ne(n, t) { function e(e, r) { return e = n(e, r), t(e[0], e[1]); } return n.invert && t.invert && (e.invert = function (e, r) { return e = t.invert(e, r), e && n.invert(e[0], e[1]); }), e; } function Ce() { return !0; } function ze(n, t, e, r, u) { const i = []; const o = []; if (n.forEach((n) => { if (!((t = n.length - 1) <= 0)) { var t; let e = n[0]; const r = n[t]; if (_e(e, r)) { u.lineStart(); for (let a = 0; t > a; ++a)u.point((e = n[a])[0], e[1]); return u.lineEnd(), void 0; } let c = new Le(e, n, null, !0); let l = new Le(e, null, c, !1); c.o = l, i.push(c), o.push(l), c = new Le(r, n, null, !1), l = new Le(r, null, c, !0), c.o = l, i.push(c), o.push(l); } }), o.sort(t), qe(i), qe(o), i.length) { for (var a = 0, c = e, l = o.length; l > a; ++a)o[a].e = c = !c; for (var s, f, h = i[0]; ;) { for (var g = h, p = !0; g.v;) if ((g = g.n) === h) return; s = g.z, u.lineStart(); do { if (g.v = g.o.v = !0, g.e) { if (p) for (var a = 0, l = s.length; l > a; ++a)u.point((f = s[a])[0], f[1]); else r(g.x, g.n.x, 1, u); g = g.n; } else { if (p) { s = g.p.z; for (var a = s.length - 1; a >= 0; --a)u.point((f = s[a])[0], f[1]); } else r(g.x, g.p.x, -1, u); g = g.p; }g = g.o, s = g.z, p = !p; } while (!g.v); u.lineEnd(); } } } function qe(n) { if (t = n.length) { for (var t, e, r = 0, u = n[0]; ++r < t;)u.n = e = n[r], e.p = u, u = e; u.n = e = n[0], e.p = u; } } function Le(n, t, e, r) { this.x = n, this.z = t, this.o = e, this.e = r, this.v = !1, this.n = this.p = null; } function Te(n, t, e, r) {
    return function (u, i) {
      function o(t, e) { const r = u(t, e); n(t = r[0], e = r[1]) && i.point(t, e); } function a(n, t) { const e = u(n, t); d.point(e[0], e[1]); } function c() { y.point = a, d.lineStart(); } function l() { y.point = o, d.lineEnd(); } function s(n, t) { v.push([n, t]); const e = u(n, t); x.point(e[0], e[1]); } function f() { x.lineStart(), v = []; } function h() { s(v[0][0], v[0][1]), x.lineEnd(); let n; const t = x.clean(); const e = M.buffer(); var r = e.length; if (v.pop(), p.push(v), v = null, r) if (1 & t) { n = e[0]; let u; var r = n.length - 1; let o = -1; if (r > 0) { for (b || (i.polygonStart(), b = !0), i.lineStart(); ++o < r;)i.point((u = n[o])[0], u[1]); i.lineEnd(); } } else r > 1 && 2 & t && e.push(e.pop().concat(e.shift())), g.push(e.filter(Re)); } let g; let p; let v; var d = t(i); const m = u.invert(r[0], r[1]); var y = {
        point: o, lineStart: c, lineEnd: l, polygonStart() { y.point = s, y.lineStart = f, y.lineEnd = h, g = [], p = []; }, polygonEnd() { y.point = o, y.lineStart = c, y.lineEnd = l, g = ta.merge(g); const n = He(m, p); g.length ? (b || (i.polygonStart(), b = !0), ze(g, Pe, n, e, i)) : n && (b || (i.polygonStart(), b = !0), i.lineStart(), e(null, null, 1, i), i.lineEnd()), b && (i.polygonEnd(), b = !1), g = p = null; }, sphere() { i.polygonStart(), i.lineStart(), e(null, null, 1, i), i.lineEnd(), i.polygonEnd(); },
      }; var M = De(); var x = t(M); var b = !1; return y;
    };
  } function Re(n) { return n.length > 1; } function De() {
    let n; let t = []; return {
      lineStart() { t.push(n = []); }, point(t, e) { n.push([t, e]); }, lineEnd: y, buffer() { const e = t; return t = [], n = null, e; }, rejoin() { t.length > 1 && t.push(t.pop().concat(t.shift())); },
    };
  } function Pe(n, t) { return ((n = n.x)[0] < 0 ? n[1] - ja - Ta : ja - n[1]) - ((t = t.x)[0] < 0 ? t[1] - ja - Ta : ja - t[1]); } function Ue(n) {
    let t; let e = 0 / 0; let r = 0 / 0; let u = 0 / 0; return {
      lineStart() { n.lineStart(), t = 1; }, point(i, o) { const a = i > 0 ? Da : -Da; const c = va(i - e); va(c - Da) < Ta ? (n.point(e, r = (r + o) / 2 > 0 ? ja : -ja), n.point(u, r), n.lineEnd(), n.lineStart(), n.point(a, r), n.point(i, r), t = 0) : u !== a && c >= Da && (va(e - u) < Ta && (e -= u * Ta), va(i - a) < Ta && (i -= a * Ta), r = je(e, r, i, o), n.point(u, r), n.lineEnd(), n.lineStart(), n.point(a, r), t = 0), n.point(e = i, r = o), u = a; }, lineEnd() { n.lineEnd(), e = r = 0 / 0; }, clean() { return 2 - t; },
    };
  } function je(n, t, e, r) { let u; let i; const o = Math.sin(n - e); return va(o) > Ta ? Math.atan((Math.sin(t) * (i = Math.cos(r)) * Math.sin(e) - Math.sin(r) * (u = Math.cos(t)) * Math.sin(n)) / (u * i * o)) : (t + r) / 2; } function Fe(n, t, e, r) { let u; if (n == null)u = e * ja, r.point(-Da, u), r.point(0, u), r.point(Da, u), r.point(Da, 0), r.point(Da, -u), r.point(0, -u), r.point(-Da, -u), r.point(-Da, 0), r.point(-Da, u); else if (va(n[0] - t[0]) > Ta) { const i = n[0] < t[0] ? Da : -Da; u = e * i / 2, r.point(-i, u), r.point(0, u), r.point(i, u); } else r.point(t[0], t[1]); } function He(n, t) { const e = n[0]; const r = n[1]; const u = [Math.sin(e), -Math.cos(e), 0]; let i = 0; let o = 0; _c.reset(); for (let a = 0, c = t.length; c > a; ++a) { const l = t[a]; const s = l.length; if (s) for (let f = l[0], h = f[0], g = f[1] / 2 + Da / 4, p = Math.sin(g), v = Math.cos(g), d = 1; ;) { d === s && (d = 0), n = l[d]; const m = n[0]; const y = n[1] / 2 + Da / 4; const M = Math.sin(y); const x = Math.cos(y); const b = m - h; const _ = b >= 0 ? 1 : -1; const w = _ * b; const S = w > Da; const k = p * M; if (_c.add(Math.atan2(k * _ * Math.sin(w), v * x + k * Math.cos(w))), i += S ? b + _ * Pa : b, S ^ h >= e ^ m >= e) { const E = me(ve(f), ve(n)); xe(E); const A = me(u, E); xe(A); const N = (S ^ b >= 0 ? -1 : 1) * tt(A[2]); (r > N || r === N && (E[0] || E[1])) && (o += S ^ b >= 0 ? 1 : -1); } if (!d++) break; h = m, p = M, v = x, f = n; } } return (-Ta > i || Ta > i && _c < 0) ^ 1 & o; } function Oe(n) {
    function t(n, t) { return Math.cos(n) * Math.cos(t) > i; } function e(n) {
      let e; let i; let c; let l; let s; return {
        lineStart() { l = c = !1, s = 1; }, point(f, h) { let g; const p = [f, h]; let v = t(f, h); const d = o ? v ? 0 : u(f, h) : v ? u(f + (f < 0 ? Da : -Da), h) : 0; if (!e && (l = c = v) && n.lineStart(), v !== c && (g = r(e, p), (_e(e, g) || _e(p, g)) && (p[0] += Ta, p[1] += Ta, v = t(p[0], p[1]))), v !== c)s = 0, v ? (n.lineStart(), g = r(p, e), n.point(g[0], g[1])) : (g = r(e, p), n.point(g[0], g[1]), n.lineEnd()), e = g; else if (a && e && o ^ v) { let m; d & i || !(m = r(p, e, !0)) || (s = 0, o ? (n.lineStart(), n.point(m[0][0], m[0][1]), n.point(m[1][0], m[1][1]), n.lineEnd()) : (n.point(m[1][0], m[1][1]), n.lineEnd(), n.lineStart(), n.point(m[0][0], m[0][1]))); }!v || e && _e(e, p) || n.point(p[0], p[1]), e = p, c = v, i = d; }, lineEnd() { c && n.lineEnd(), e = null; }, clean() { return s | (l && c) << 1; },
      };
    } function r(n, t, e) { const r = ve(n); const u = ve(t); const o = [1, 0, 0]; const a = me(r, u); const c = de(a, a); const l = a[0]; const s = c - l * l; if (!s) return !e && n; const f = i * c / s; const h = -i * l / s; const g = me(o, a); const p = Me(o, f); const v = Me(a, h); ye(p, v); const d = g; const m = de(p, d); const y = de(d, d); const M = m * m - y * (de(p, p) - 1); if (!(M < 0)) { const x = Math.sqrt(M); let b = Me(d, (-m - x) / y); if (ye(b, p), b = be(b), !e) return b; let _; let w = n[0]; let S = t[0]; let k = n[1]; let E = t[1]; w > S && (_ = w, w = S, S = _); const A = S - w; const N = va(A - Da) < Ta; const C = N || Ta > A; if (!N && k > E && (_ = k, k = E, E = _), C ? N ? k + E > 0 ^ b[1] < (va(b[0] - w) < Ta ? k : E) : k <= b[1] && b[1] <= E : A > Da ^ (w <= b[0] && b[0] <= S)) { const z = Me(d, (-m + x) / y); return ye(z, p), [b, be(z)]; } } } function u(t, e) { const r = o ? n : Da - n; let u = 0; return -r > t ? u |= 1 : t > r && (u |= 2), -r > e ? u |= 4 : e > r && (u |= 8), u; } var i = Math.cos(n); var o = i > 0; var a = va(i) > Ta; const c = pr(n, 6 * Fa); return Te(t, e, c, o ? [0, -n] : [-Da, n - Da]);
  } function Ye(n, t, e, r) { return function (u) { let i; const o = u.a; const a = u.b; const c = o.x; const l = o.y; const s = a.x; const f = a.y; let h = 0; let g = 1; const p = s - c; const v = f - l; if (i = n - c, p || !(i > 0)) { if (i /= p, p < 0) { if (h > i) return; g > i && (g = i); } else if (p > 0) { if (i > g) return; i > h && (h = i); } if (i = e - c, p || !(i < 0)) { if (i /= p, p < 0) { if (i > g) return; i > h && (h = i); } else if (p > 0) { if (h > i) return; g > i && (g = i); } if (i = t - l, v || !(i > 0)) { if (i /= v, v < 0) { if (h > i) return; g > i && (g = i); } else if (v > 0) { if (i > g) return; i > h && (h = i); } if (i = r - l, v || !(i < 0)) { if (i /= v, v < 0) { if (i > g) return; i > h && (h = i); } else if (v > 0) { if (h > i) return; g > i && (g = i); } return h > 0 && (u.a = { x: c + h * p, y: l + h * v }), g < 1 && (u.b = { x: c + g * p, y: l + g * v }), u; } } } } }; } function Ie(n, t, e, r) {
    function u(r, u) { return va(r[0] - n) < Ta ? u > 0 ? 0 : 3 : va(r[0] - e) < Ta ? u > 0 ? 2 : 1 : va(r[1] - t) < Ta ? u > 0 ? 1 : 0 : u > 0 ? 3 : 2; } function i(n, t) { return o(n.x, t.x); } function o(n, t) { const e = u(n, 1); const r = u(t, 1); return e !== r ? e - r : e === 0 ? t[1] - n[1] : e === 1 ? n[0] - t[0] : e === 2 ? n[1] - t[1] : t[0] - n[0]; } return function (a) {
      function c(n) { for (var t = 0, e = d.length, r = n[1], u = 0; e > u; ++u) for (var i, o = 1, a = d[u], c = a.length, l = a[0]; c > o; ++o)i = a[o], l[1] <= r ? i[1] > r && Q(l, i, n) > 0 && ++t : i[1] <= r && Q(l, i, n) < 0 && --t, l = i; return t !== 0; } function l(i, a, c, l) { let s = 0; let f = 0; if (i == null || (s = u(i, c)) !== (f = u(a, c)) || o(i, a) < 0 ^ c > 0) { do l.point(s === 0 || s === 3 ? n : e, s > 1 ? r : t); while ((s = (s + c + 4) % 4) !== f); } else l.point(a[0], a[1]); } function s(u, i) { return u >= n && e >= u && i >= t && r >= i; } function f(n, t) { s(n, t) && a.point(n, t); } function h() { C.point = p, d && d.push(m = []), S = !0, w = !1, b = _ = 0 / 0; } function g() { v && (p(y, M), x && w && A.rejoin(), v.push(A.buffer())), C.point = f, w && a.lineEnd(); } function p(n, t) { n = Math.max(-Uc, Math.min(Uc, n)), t = Math.max(-Uc, Math.min(Uc, t)); const e = s(n, t); if (d && m.push([n, t]), S)y = n, M = t, x = e, S = !1, e && (a.lineStart(), a.point(n, t)); else if (e && w)a.point(n, t); else { const r = { a: { x: b, y: _ }, b: { x: n, y: t } }; N(r) ? (w || (a.lineStart(), a.point(r.a.x, r.a.y)), a.point(r.b.x, r.b.y), e || a.lineEnd(), k = !1) : e && (a.lineStart(), a.point(n, t), k = !1); }b = n, _ = t, w = e; } let v; let d; let m; let y; let M; let x; let b; let _; let w; let S; let k; const E = a; var A = De(); var N = Ye(n, t, e, r); var C = {
        point: f, lineStart: h, lineEnd: g, polygonStart() { a = A, v = [], d = [], k = !0; }, polygonEnd() { a = E, v = ta.merge(v); const t = c([n, r]); const e = k && t; const u = v.length; (e || u) && (a.polygonStart(), e && (a.lineStart(), l(null, null, 1, a), a.lineEnd()), u && ze(v, i, t, l, a), a.polygonEnd()), v = d = m = null; },
      }; return C;
    };
  } function Ze(n) { let t = 0; let e = Da / 3; const r = or(n); const u = r(t, e); return u.parallels = function (n) { return arguments.length ? r(t = n[0] * Da / 180, e = n[1] * Da / 180) : [180 * (t / Da), 180 * (e / Da)]; }, u; } function Ve(n, t) { function e(n, t) { const e = Math.sqrt(i - 2 * u * Math.sin(t)) / u; return [e * Math.sin(n *= u), o - e * Math.cos(n)]; } const r = Math.sin(n); var u = (r + Math.sin(t)) / 2; var i = 1 + r * (2 * u - r); var o = Math.sqrt(i) / u; return e.invert = function (n, t) { const e = o - t; return [Math.atan2(n, e) / u, tt((i - (n * n + e * e) * u * u) / (2 * u))]; }, e; } function Xe() { function n(n, t) { Fc += u * n - r * t, r = n, u = t; } let t; let e; let r; let u; Zc.point = function (i, o) { Zc.point = n, t = r = i, e = u = o; }, Zc.lineEnd = function () { n(t, e); }; } function $e(n, t) { Hc > n && (Hc = n), n > Yc && (Yc = n), Oc > t && (Oc = t), t > Ic && (Ic = t); } function Be() {
    function n(n, t) { o.push('M', n, ',', t, i); } function t(n, t) { o.push('M', n, ',', t), a.point = e; } function e(n, t) { o.push('L', n, ',', t); } function r() { a.point = n; } function u() { o.push('Z'); } var i = We(4.5); var o = []; var a = {
      point: n, lineStart() { a.point = t; }, lineEnd: r, polygonStart() { a.lineEnd = u; }, polygonEnd() { a.lineEnd = r, a.point = n; }, pointRadius(n) { return i = We(n), a; }, result() { if (o.length) { const n = o.join(''); return o = [], n; } },
    }; return a;
  } function We(n) { return `m0,${n}a${n},${n} 0 1,1 0,${-2 * n}a${n},${n} 0 1,1 0,${2 * n}z`; } function Je(n, t) { Ec += n, Ac += t, ++Nc; } function Ge() { function n(n, r) { const u = n - t; const i = r - e; const o = Math.sqrt(u * u + i * i); Cc += o * (t + n) / 2, zc += o * (e + r) / 2, qc += o, Je(t = n, e = r); } let t; let e; Xc.point = function (r, u) { Xc.point = n, Je(t = r, e = u); }; } function Ke() { Xc.point = Je; } function Qe() { function n(n, t) { const e = n - r; const i = t - u; let o = Math.sqrt(e * e + i * i); Cc += o * (r + n) / 2, zc += o * (u + t) / 2, qc += o, o = u * n - r * t, Lc += o * (r + n), Tc += o * (u + t), Rc += 3 * o, Je(r = n, u = t); } let t; let e; let r; let u; Xc.point = function (i, o) { Xc.point = n, Je(t = r = i, e = u = o); }, Xc.lineEnd = function () { n(t, e); }; } function nr(n) {
    function t(t, e) { n.moveTo(t + o, e), n.arc(t, e, o, 0, Pa); } function e(t, e) { n.moveTo(t, e), a.point = r; } function r(t, e) { n.lineTo(t, e); } function u() { a.point = t; } function i() { n.closePath(); } var o = 4.5; var a = {
      point: t, lineStart() { a.point = e; }, lineEnd: u, polygonStart() { a.lineEnd = i; }, polygonEnd() { a.lineEnd = u, a.point = t; }, pointRadius(n) { return o = n, a; }, result: y,
    }; return a;
  } function tr(n) {
    function t(n) { return (a ? r : e)(n); } function e(t) { return ur(t, (e, r) => { e = n(e, r), t.point(e[0], e[1]); }); } function r(t) {
      function e(e, r) { e = n(e, r), t.point(e[0], e[1]); } function r() { M = 0 / 0, S.point = i, t.lineStart(); } function i(e, r) { const i = ve([e, r]); const o = n(e, r); u(M, x, y, b, _, w, M = o[0], x = o[1], y = e, b = i[0], _ = i[1], w = i[2], a, t), t.point(M, x); } function o() { S.point = e, t.lineEnd(); } function c() { r(), S.point = l, S.lineEnd = s; } function l(n, t) { i(f = n, h = t), g = M, p = x, v = b, d = _, m = w, S.point = i; } function s() { u(M, x, y, b, _, w, g, p, f, v, d, m, a, t), S.lineEnd = o, o(); } let f; let h; let g; let p; let v; let d; let m; let y; let M; let x; let b; let _; let w; var S = {
        point: e, lineStart: r, lineEnd: o, polygonStart() { t.polygonStart(), S.lineStart = c; }, polygonEnd() { t.polygonEnd(), S.lineStart = r; },
      }; return S;
    } function u(t, e, r, a, c, l, s, f, h, g, p, v, d, m) {
      const y = s - t; const M = f - e; const x = y * y + M * M; if (x > 4 * i && d--) {
        let b = a + g; let _ = c + p; let w = l + v; const S = Math.sqrt(b * b + _ * _ + w * w); const k = Math.asin(w /= S); const E = va(va(w) - 1) < Ta || va(r - h) < Ta ? (r + h) / 2 : Math.atan2(_, b); const A = n(E, k); const N = A[0]; const C = A[1]; const z = N - t; const q = C - e; const L = M * z - y * q;
        (L * L / x > i || va((y * z + M * q) / x - 0.5) > 0.3 || o > a * g + c * p + l * v) && (u(t, e, r, a, c, l, N, C, E, b /= S, _ /= S, w, d, m), m.point(N, C), u(N, C, E, b, _, w, s, f, h, g, p, v, d, m));
      }
    } var i = 0.5; var o = Math.cos(30 * Fa); var a = 16; return t.precision = function (n) { return arguments.length ? (a = (i = n * n) > 0 && 16, t) : Math.sqrt(i); }, t;
  } function er(n) { const t = tr((t, e) => n([t * Ha, e * Ha])); return function (n) { return ar(t(n)); }; } function rr(n) { this.stream = n; } function ur(n, t) {
    return {
      point: t, sphere() { n.sphere(); }, lineStart() { n.lineStart(); }, lineEnd() { n.lineEnd(); }, polygonStart() { n.polygonStart(); }, polygonEnd() { n.polygonEnd(); },
    };
  } function ir(n) { return or(() => n)(); } function or(n) { function t(n) { return n = a(n[0] * Fa, n[1] * Fa), [n[0] * h + c, l - n[1] * h]; } function e(n) { return n = a.invert((n[0] - c) / h, (l - n[1]) / h), n && [n[0] * Ha, n[1] * Ha]; } function r() { a = Ne(o = sr(m, y, M), i); const n = i(v, d); return c = g - n[0] * h, l = p + n[1] * h, u(); } function u() { return s && (s.valid = !1, s = null), t; } let i; let o; let a; let c; let l; let s; const f = tr((n, t) => (n = i(n, t), [n[0] * h + c, l - n[1] * h])); var h = 150; var g = 480; var p = 250; var v = 0; var d = 0; var m = 0; var y = 0; var M = 0; let x = Pc; let b = At; let _ = null; let w = null; return t.stream = function (n) { return s && (s.valid = !1), s = ar(x(o, f(b(n)))), s.valid = !0, s; }, t.clipAngle = function (n) { return arguments.length ? (x = n == null ? (_ = n, Pc) : Oe((_ = +n) * Fa), u()) : _; }, t.clipExtent = function (n) { return arguments.length ? (w = n, b = n ? Ie(n[0][0], n[0][1], n[1][0], n[1][1]) : At, u()) : w; }, t.scale = function (n) { return arguments.length ? (h = +n, r()) : h; }, t.translate = function (n) { return arguments.length ? (g = +n[0], p = +n[1], r()) : [g, p]; }, t.center = function (n) { return arguments.length ? (v = n[0] % 360 * Fa, d = n[1] % 360 * Fa, r()) : [v * Ha, d * Ha]; }, t.rotate = function (n) { return arguments.length ? (m = n[0] % 360 * Fa, y = n[1] % 360 * Fa, M = n.length > 2 ? n[2] % 360 * Fa : 0, r()) : [m * Ha, y * Ha, M * Ha]; }, ta.rebind(t, f, 'precision'), function () { return i = n.apply(this, arguments), t.invert = i.invert && e, r(); }; } function ar(n) { return ur(n, (t, e) => { n.point(t * Fa, e * Fa); }); } function cr(n, t) { return [n, t]; } function lr(n, t) { return [n > Da ? n - Pa : -Da > n ? n + Pa : n, t]; } function sr(n, t, e) { return n ? t || e ? Ne(hr(n), gr(t, e)) : hr(n) : t || e ? gr(t, e) : lr; } function fr(n) { return function (t, e) { return t += n, [t > Da ? t - Pa : -Da > t ? t + Pa : t, e]; }; } function hr(n) { const t = fr(n); return t.invert = fr(-n), t; } function gr(n, t) { function e(n, t) { const e = Math.cos(t); const a = Math.cos(n) * e; const c = Math.sin(n) * e; const l = Math.sin(t); const s = l * r + a * u; return [Math.atan2(c * i - s * o, a * r - l * u), tt(s * i + c * o)]; } var r = Math.cos(n); var u = Math.sin(n); var i = Math.cos(t); var o = Math.sin(t); return e.invert = function (n, t) { const e = Math.cos(t); const a = Math.cos(n) * e; const c = Math.sin(n) * e; const l = Math.sin(t); const s = l * i - c * o; return [Math.atan2(c * i + l * o, a * r + s * u), tt(s * r - a * u)]; }, e; } function pr(n, t) { const e = Math.cos(n); const r = Math.sin(n); return function (u, i, o, a) { const c = o * t; u != null ? (u = vr(e, u), i = vr(e, i), (o > 0 ? i > u : u > i) && (u += o * Pa)) : (u = n + o * Pa, i = n - 0.5 * c); for (var l, s = u; o > 0 ? s > i : i > s; s -= c)a.point((l = be([e, -r * Math.cos(s), -r * Math.sin(s)]))[0], l[1]); }; } function vr(n, t) { const e = ve(t); e[0] -= n, xe(e); const r = nt(-e[1]); return ((-e[2] < 0 ? -r : r) + 2 * Math.PI - Ta) % (2 * Math.PI); } function dr(n, t, e) { const r = ta.range(n, t - Ta, e).concat(t); return function (n) { return r.map((t) => [n, t]); }; } function mr(n, t, e) { const r = ta.range(n, t - Ta, e).concat(t); return function (n) { return r.map((t) => [t, n]); }; } function yr(n) { return n.source; } function Mr(n) { return n.target; } function xr(n, t, e, r) { const u = Math.cos(t); const i = Math.sin(t); const o = Math.cos(r); const a = Math.sin(r); const c = u * Math.cos(n); const l = u * Math.sin(n); const s = o * Math.cos(e); const f = o * Math.sin(e); const h = 2 * Math.asin(Math.sqrt(it(r - t) + u * o * it(e - n))); const g = 1 / Math.sin(h); const p = h ? function (n) { const t = Math.sin(n *= h) * g; const e = Math.sin(h - n) * g; const r = e * c + t * s; const u = e * l + t * f; const o = e * i + t * a; return [Math.atan2(u, r) * Ha, Math.atan2(o, Math.sqrt(r * r + u * u)) * Ha]; } : function () { return [n * Ha, t * Ha]; }; return p.distance = h, p; } function br() { function n(n, u) { const i = Math.sin(u *= Fa); const o = Math.cos(u); let a = va((n *= Fa) - t); const c = Math.cos(a); $c += Math.atan2(Math.sqrt((a = o * Math.sin(a)) * a + (a = r * i - e * o * c) * a), e * i + r * o * c), t = n, e = i, r = o; } let t; let e; let r; Bc.point = function (u, i) { t = u * Fa, e = Math.sin(i *= Fa), r = Math.cos(i), Bc.point = n; }, Bc.lineEnd = function () { Bc.point = Bc.lineEnd = y; }; } function _r(n, t) { function e(t, e) { const r = Math.cos(t); const u = Math.cos(e); const i = n(r * u); return [i * u * Math.sin(t), i * Math.sin(e)]; } return e.invert = function (n, e) { const r = Math.sqrt(n * n + e * e); const u = t(r); const i = Math.sin(u); const o = Math.cos(u); return [Math.atan2(n * i, r * o), Math.asin(r && e * i / r)]; }, e; } function wr(n, t) { function e(n, t) { o > 0 ? -ja + Ta > t && (t = -ja + Ta) : t > ja - Ta && (t = ja - Ta); const e = o / Math.pow(u(t), i); return [e * Math.sin(i * n), o - e * Math.cos(i * n)]; } const r = Math.cos(n); var u = function (n) { return Math.tan(Da / 4 + n / 2); }; var i = n === t ? Math.sin(n) : Math.log(r / Math.cos(t)) / Math.log(u(t) / u(n)); var o = r * Math.pow(u(n), i) / i; return i ? (e.invert = function (n, t) { const e = o - t; const r = K(i) * Math.sqrt(n * n + e * e); return [Math.atan2(n, e) / i, 2 * Math.atan(Math.pow(o / r, 1 / i)) - ja]; }, e) : kr; } function Sr(n, t) { function e(n, t) { const e = i - t; return [e * Math.sin(u * n), i - e * Math.cos(u * n)]; } const r = Math.cos(n); var u = n === t ? Math.sin(n) : (r - Math.cos(t)) / (t - n); var i = r / u + n; return va(u) < Ta ? cr : (e.invert = function (n, t) { const e = i - t; return [Math.atan2(n, e) / u, i - K(u) * Math.sqrt(n * n + e * e)]; }, e); } function kr(n, t) { return [n, Math.log(Math.tan(Da / 4 + t / 2))]; } function Er(n) { let t; const e = ir(n); const r = e.scale; const u = e.translate; const i = e.clipExtent; return e.scale = function () { const n = r.apply(e, arguments); return n === e ? t ? e.clipExtent(null) : e : n; }, e.translate = function () { const n = u.apply(e, arguments); return n === e ? t ? e.clipExtent(null) : e : n; }, e.clipExtent = function (n) { let o = i.apply(e, arguments); if (o === e) { if (t = n == null) { const a = Da * r(); const c = u(); i([[c[0] - a, c[1] - a], [c[0] + a, c[1] + a]]); } } else t && (o = null); return o; }, e.clipExtent(null); } function Ar(n, t) { return [Math.log(Math.tan(Da / 4 + t / 2)), -n]; } function Nr(n) { return n[0]; } function Cr(n) { return n[1]; } function zr(n) { for (var t = n.length, e = [0, 1], r = 2, u = 2; t > u; u++) { for (;r > 1 && Q(n[e[r - 2]], n[e[r - 1]], n[u]) <= 0;)--r; e[r++] = u; } return e.slice(0, r); } function qr(n, t) { return n[0] - t[0] || n[1] - t[1]; } function Lr(n, t, e) { return (e[0] - t[0]) * (n[1] - t[1]) < (e[1] - t[1]) * (n[0] - t[0]); } function Tr(n, t, e, r) { const u = n[0]; const i = e[0]; const o = t[0] - u; const a = r[0] - i; const c = n[1]; const l = e[1]; const s = t[1] - c; const f = r[1] - l; const h = (a * (c - l) - f * (u - i)) / (f * o - a * s); return [u + h * o, c + h * s]; } function Rr(n) { const t = n[0]; const e = n[n.length - 1]; return !(t[0] - e[0] || t[1] - e[1]); } function Dr() { eu(this), this.edge = this.site = this.circle = null; } function Pr(n) { const t = ol.pop() || new Dr(); return t.site = n, t; } function Ur(n) { $r(n), rl.remove(n), ol.push(n), eu(n); } function jr(n) { const t = n.circle; const e = t.x; const r = t.cy; const u = { x: e, y: r }; let i = n.P; let o = n.N; const a = [n]; Ur(n); for (var c = i; c.circle && va(e - c.circle.x) < Ta && va(r - c.circle.cy) < Ta;)i = c.P, a.unshift(c), Ur(c), c = i; a.unshift(c), $r(c); for (var l = o; l.circle && va(e - l.circle.x) < Ta && va(r - l.circle.cy) < Ta;)o = l.N, a.push(l), Ur(l), l = o; a.push(l), $r(l); let s; const f = a.length; for (s = 1; f > s; ++s)l = a[s], c = a[s - 1], Qr(l.edge, c.site, l.site, u); c = a[0], l = a[f - 1], l.edge = Gr(c.site, l.site, null, u), Xr(c), Xr(l); } function Fr(n) { for (var t, e, r, u, i = n.x, o = n.y, a = rl._; a;) if (r = Hr(a, o) - i, r > Ta)a = a.L; else { if (u = i - Or(a, o), !(u > Ta)) { r > -Ta ? (t = a.P, e = a) : u > -Ta ? (t = a, e = a.N) : t = e = a; break; } if (!a.R) { t = a; break; }a = a.R; } const c = Pr(n); if (rl.insert(t, c), t || e) { if (t === e) return $r(t), e = Pr(t.site), rl.insert(c, e), c.edge = e.edge = Gr(t.site, c.site), Xr(t), Xr(e), void 0; if (!e) return c.edge = Gr(t.site, c.site), void 0; $r(t), $r(e); const l = t.site; const s = l.x; const f = l.y; const h = n.x - s; const g = n.y - f; const p = e.site; const v = p.x - s; const d = p.y - f; const m = 2 * (h * d - g * v); const y = h * h + g * g; const M = v * v + d * d; const x = { x: (d * y - g * M) / m + s, y: (h * M - v * y) / m + f }; Qr(e.edge, l, p, x), c.edge = Gr(l, n, null, x), e.edge = Gr(n, p, null, x), Xr(t), Xr(e); } } function Hr(n, t) { let e = n.site; const r = e.x; const u = e.y; const i = u - t; if (!i) return r; const o = n.P; if (!o) return -1 / 0; e = o.site; const a = e.x; const c = e.y; const l = c - t; if (!l) return a; const s = a - r; const f = 1 / i - 1 / l; const h = s / l; return f ? (-h + Math.sqrt(h * h - 2 * f * (s * s / (-2 * l) - c + l / 2 + u - i / 2))) / f + r : (r + a) / 2; } function Or(n, t) { const e = n.N; if (e) return Hr(e, t); const r = n.site; return r.y === t ? r.x : 1 / 0; } function Yr(n) { this.site = n, this.edges = []; } function Ir(n) { for (var t, e, r, u, i, o, a, c, l, s, f = n[0][0], h = n[1][0], g = n[0][1], p = n[1][1], v = el, d = v.length; d--;) if (i = v[d], i && i.prepare()) for (a = i.edges, c = a.length, o = 0; c > o;)s = a[o].end(), r = s.x, u = s.y, l = a[++o % c].start(), t = l.x, e = l.y, (va(r - t) > Ta || va(u - e) > Ta) && (a.splice(o, 0, new nu(Kr(i.site, s, va(r - f) < Ta && p - u > Ta ? { x: f, y: va(t - f) < Ta ? e : p } : va(u - p) < Ta && h - r > Ta ? { x: va(e - p) < Ta ? t : h, y: p } : va(r - h) < Ta && u - g > Ta ? { x: h, y: va(t - h) < Ta ? e : g } : va(u - g) < Ta && r - f > Ta ? { x: va(e - g) < Ta ? t : f, y: g } : null), i.site, null)), ++c); } function Zr(n, t) { return t.angle - n.angle; } function Vr() { eu(this), this.x = this.y = this.arc = this.site = this.cy = null; } function Xr(n) { const t = n.P; const e = n.N; if (t && e) { const r = t.site; const u = n.site; const i = e.site; if (r !== i) { const o = u.x; const a = u.y; const c = r.x - o; const l = r.y - a; const s = i.x - o; var f = i.y - a; const h = 2 * (c * f - l * s); if (!(h >= -Ra)) { const g = c * c + l * l; const p = s * s + f * f; const v = (f * g - l * p) / h; const d = (c * p - s * g) / h; var f = d + a; const m = al.pop() || new Vr(); m.arc = n, m.site = u, m.x = v + o, m.y = f + Math.sqrt(v * v + d * d), m.cy = f, n.circle = m; for (var y = null, M = il._; M;) if (m.y < M.y || m.y === M.y && m.x <= M.x) { if (!M.L) { y = M.P; break; }M = M.L; } else { if (!M.R) { y = M; break; }M = M.R; }il.insert(y, m), y || (ul = m); } } } } function $r(n) { const t = n.circle; t && (t.P || (ul = t.N), il.remove(t), al.push(t), eu(t), n.circle = null); } function Br(n) { for (var t, e = tl, r = Ye(n[0][0], n[0][1], n[1][0], n[1][1]), u = e.length; u--;)t = e[u], (!Wr(t, n) || !r(t) || va(t.a.x - t.b.x) < Ta && va(t.a.y - t.b.y) < Ta) && (t.a = t.b = null, e.splice(u, 1)); } function Wr(n, t) { let e = n.b; if (e) return !0; let r; let u; let i = n.a; const o = t[0][0]; const a = t[1][0]; const c = t[0][1]; const l = t[1][1]; const s = n.l; const f = n.r; const h = s.x; const g = s.y; const p = f.x; const v = f.y; const d = (h + p) / 2; const m = (g + v) / 2; if (v === g) { if (o > d || d >= a) return; if (h > p) { if (i) { if (i.y >= l) return; } else i = { x: d, y: c }; e = { x: d, y: l }; } else { if (i) { if (i.y < c) return; } else i = { x: d, y: l }; e = { x: d, y: c }; } } else if (r = (h - p) / (v - g), u = m - r * d, r < -1 || r > 1) if (h > p) { if (i) { if (i.y >= l) return; } else i = { x: (c - u) / r, y: c }; e = { x: (l - u) / r, y: l }; } else { if (i) { if (i.y < c) return; } else i = { x: (l - u) / r, y: l }; e = { x: (c - u) / r, y: c }; } else if (v > g) { if (i) { if (i.x >= a) return; } else i = { x: o, y: r * o + u }; e = { x: a, y: r * a + u }; } else { if (i) { if (i.x < o) return; } else i = { x: a, y: r * a + u }; e = { x: o, y: r * o + u }; } return n.a = i, n.b = e, !0; } function Jr(n, t) { this.l = n, this.r = t, this.a = this.b = null; } function Gr(n, t, e, r) { const u = new Jr(n, t); return tl.push(u), e && Qr(u, n, t, e), r && Qr(u, t, n, r), el[n.i].edges.push(new nu(u, n, t)), el[t.i].edges.push(new nu(u, t, n)), u; } function Kr(n, t, e) { const r = new Jr(n, null); return r.a = t, r.b = e, tl.push(r), r; } function Qr(n, t, e, r) { n.a || n.b ? n.l === e ? n.b = r : n.a = r : (n.a = r, n.l = t, n.r = e); } function nu(n, t, e) { const r = n.a; const u = n.b; this.edge = n, this.site = t, this.angle = e ? Math.atan2(e.y - t.y, e.x - t.x) : n.l === t ? Math.atan2(u.x - r.x, r.y - u.y) : Math.atan2(r.x - u.x, u.y - r.y); } function tu() { this._ = null; } function eu(n) { n.U = n.C = n.L = n.R = n.P = n.N = null; } function ru(n, t) { const e = t; const r = t.R; const u = e.U; u ? u.L === e ? u.L = r : u.R = r : n._ = r, r.U = u, e.U = r, e.R = r.L, e.R && (e.R.U = e), r.L = e; } function uu(n, t) { const e = t; const r = t.L; const u = e.U; u ? u.L === e ? u.L = r : u.R = r : n._ = r, r.U = u, e.U = r, e.L = r.R, e.L && (e.L.U = e), r.R = e; } function iu(n) { for (;n.L;)n = n.L; return n; } function ou(n, t) { let e; let r; let u; let i = n.sort(au).pop(); for (tl = [], el = new Array(n.length), rl = new tu(), il = new tu(); ;) if (u = ul, i && (!u || i.y < u.y || i.y === u.y && i.x < u.x))(i.x !== e || i.y !== r) && (el[i.i] = new Yr(i), Fr(i), e = i.x, r = i.y), i = n.pop(); else { if (!u) break; jr(u.arc); }t && (Br(t), Ir(t)); const o = { cells: el, edges: tl }; return rl = il = tl = el = null, o; } function au(n, t) { return t.y - n.y || t.x - n.x; } function cu(n, t, e) { return (n.x - e.x) * (t.y - n.y) - (n.x - t.x) * (e.y - n.y); } function lu(n) { return n.x; } function su(n) { return n.y; } function fu() {
    return {
      leaf: !0, nodes: [], point: null, x: null, y: null,
    };
  } function hu(n, t, e, r, u, i) { if (!n(t, e, r, u, i)) { const o = 0.5 * (e + u); const a = 0.5 * (r + i); const c = t.nodes; c[0] && hu(n, c[0], e, r, o, a), c[1] && hu(n, c[1], o, r, u, a), c[2] && hu(n, c[2], e, a, o, i), c[3] && hu(n, c[3], o, a, u, i); } } function gu(n, t, e, r, u, i, o) { let a; let c = 1 / 0; return (function l(n, s, f, h, g) { if (!(s > i || f > o || r > h || u > g)) { if (p = n.point) { var p; const v = t - p[0]; const d = e - p[1]; const m = v * v + d * d; if (c > m) { const y = Math.sqrt(c = m); r = t - y, u = e - y, i = t + y, o = e + y, a = p; } } for (let M = n.nodes, x = 0.5 * (s + h), b = 0.5 * (f + g), _ = t >= x, w = e >= b, S = w << 1 | _, k = S + 4; k > S; ++S) if (n = M[3 & S]) switch (3 & S) { case 0: l(n, s, f, x, b); break; case 1: l(n, x, f, h, b); break; case 2: l(n, s, b, x, g); break; case 3: l(n, x, b, h, g); } } }(n, r, u, i, o)), a; } function pu(n, t) { n = ta.rgb(n), t = ta.rgb(t); const e = n.r; const r = n.g; const u = n.b; const i = t.r - e; const o = t.g - r; const a = t.b - u; return function (n) { return `#${xt(Math.round(e + i * n))}${xt(Math.round(r + o * n))}${xt(Math.round(u + a * n))}`; }; } function vu(n, t) { let e; const r = {}; const u = {}; for (e in n)e in t ? r[e] = yu(n[e], t[e]) : u[e] = n[e]; for (e in t)e in n || (u[e] = t[e]); return function (n) { for (e in r)u[e] = r[e](n); return u; }; } function du(n, t) { return n = +n, t = +t, function (e) { return n * (1 - e) + t * e; }; } function mu(n, t) { let e; let r; let u; let i = ll.lastIndex = sl.lastIndex = 0; let o = -1; const a = []; const c = []; for (n += '', t += ''; (e = ll.exec(n)) && (r = sl.exec(t));)(u = r.index) > i && (u = t.slice(i, u), a[o] ? a[o] += u : a[++o] = u), (e = e[0]) === (r = r[0]) ? a[o] ? a[o] += r : a[++o] = r : (a[++o] = null, c.push({ i: o, x: du(e, r) })), i = sl.lastIndex; return i < t.length && (u = t.slice(i), a[o] ? a[o] += u : a[++o] = u), a.length < 2 ? c[0] ? (t = c[0].x, function (n) { return `${t(n)}`; }) : function () { return t; } : (t = c.length, function (n) { for (var e, r = 0; t > r; ++r)a[(e = c[r]).i] = e.x(n); return a.join(''); }); } function yu(n, t) { for (var e, r = ta.interpolators.length; --r >= 0 && !(e = ta.interpolators[r](n, t)););return e; } function Mu(n, t) { let e; const r = []; const u = []; const i = n.length; const o = t.length; const a = Math.min(n.length, t.length); for (e = 0; a > e; ++e)r.push(yu(n[e], t[e])); for (;i > e; ++e)u[e] = n[e]; for (;o > e; ++e)u[e] = t[e]; return function (n) { for (e = 0; a > e; ++e)u[e] = r[e](n); return u; }; } function xu(n) { return function (t) { return t <= 0 ? 0 : t >= 1 ? 1 : n(t); }; } function bu(n) { return function (t) { return 1 - n(1 - t); }; } function _u(n) { return function (t) { return 0.5 * (t < 0.5 ? n(2 * t) : 2 - n(2 - 2 * t)); }; } function wu(n) { return n * n; } function Su(n) { return n * n * n; } function ku(n) { if (n <= 0) return 0; if (n >= 1) return 1; const t = n * n; const e = t * n; return 4 * (n < 0.5 ? e : 3 * (n - t) + e - 0.75); } function Eu(n) { return function (t) { return Math.pow(t, n); }; } function Au(n) { return 1 - Math.cos(n * ja); } function Nu(n) { return Math.pow(2, 10 * (n - 1)); } function Cu(n) { return 1 - Math.sqrt(1 - n * n); } function zu(n, t) { let e; return arguments.length < 2 && (t = 0.45), arguments.length ? e = t / Pa * Math.asin(1 / n) : (n = 1, e = t / 4), function (r) { return 1 + n * Math.pow(2, -10 * r) * Math.sin((r - e) * Pa / t); }; } function qu(n) { return n || (n = 1.70158), function (t) { return t * t * ((n + 1) * t - n); }; } function Lu(n) { return 1 / 2.75 > n ? 7.5625 * n * n : 2 / 2.75 > n ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75 : 2.5 / 2.75 > n ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375 : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375; } function Tu(n, t) { n = ta.hcl(n), t = ta.hcl(t); let e = n.h; let r = n.c; const u = n.l; let i = t.h - e; let o = t.c - r; const a = t.l - u; return isNaN(o) && (o = 0, r = isNaN(r) ? t.c : r), isNaN(i) ? (i = 0, e = isNaN(e) ? t.h : e) : i > 180 ? i -= 360 : i < -180 && (i += 360), function (n) { return `${st(e + i * n, r + o * n, u + a * n)}`; }; } function Ru(n, t) { n = ta.hsl(n), t = ta.hsl(t); let e = n.h; let r = n.s; const u = n.l; let i = t.h - e; let o = t.s - r; const a = t.l - u; return isNaN(o) && (o = 0, r = isNaN(r) ? t.s : r), isNaN(i) ? (i = 0, e = isNaN(e) ? t.h : e) : i > 180 ? i -= 360 : i < -180 && (i += 360), function (n) { return `${ct(e + i * n, r + o * n, u + a * n)}`; }; } function Du(n, t) { n = ta.lab(n), t = ta.lab(t); const e = n.l; const r = n.a; const u = n.b; const i = t.l - e; const o = t.a - r; const a = t.b - u; return function (n) { return `${ht(e + i * n, r + o * n, u + a * n)}`; }; } function Pu(n, t) { return t -= n, function (e) { return Math.round(n + t * e); }; } function Uu(n) { const t = [n.a, n.b]; const e = [n.c, n.d]; let r = Fu(t); let u = ju(t, e); const i = Fu(Hu(e, t, -u)) || 0; t[0] * e[1] < e[0] * t[1] && (t[0] *= -1, t[1] *= -1, r *= -1, u *= -1), this.rotate = (r ? Math.atan2(t[1], t[0]) : Math.atan2(-e[0], e[1])) * Ha, this.translate = [n.e, n.f], this.scale = [r, i], this.skew = i ? Math.atan2(u, i) * Ha : 0; } function ju(n, t) { return n[0] * t[0] + n[1] * t[1]; } function Fu(n) { const t = Math.sqrt(ju(n, n)); return t && (n[0] /= t, n[1] /= t), t; } function Hu(n, t, e) { return n[0] += e * t[0], n[1] += e * t[1], n; } function Ou(n, t) { let e; const r = []; const u = []; const i = ta.transform(n); const o = ta.transform(t); const a = i.translate; const c = o.translate; let l = i.rotate; let s = o.rotate; const f = i.skew; const h = o.skew; const g = i.scale; const p = o.scale; return a[0] != c[0] || a[1] != c[1] ? (r.push('translate(', null, ',', null, ')'), u.push({ i: 1, x: du(a[0], c[0]) }, { i: 3, x: du(a[1], c[1]) })) : c[0] || c[1] ? r.push(`translate(${c})`) : r.push(''), l != s ? (l - s > 180 ? s += 360 : s - l > 180 && (l += 360), u.push({ i: r.push(`${r.pop()}rotate(`, null, ')') - 2, x: du(l, s) })) : s && r.push(`${r.pop()}rotate(${s})`), f != h ? u.push({ i: r.push(`${r.pop()}skewX(`, null, ')') - 2, x: du(f, h) }) : h && r.push(`${r.pop()}skewX(${h})`), g[0] != p[0] || g[1] != p[1] ? (e = r.push(`${r.pop()}scale(`, null, ',', null, ')'), u.push({ i: e - 4, x: du(g[0], p[0]) }, { i: e - 2, x: du(g[1], p[1]) })) : (p[0] != 1 || p[1] != 1) && r.push(`${r.pop()}scale(${p})`), e = u.length, function (n) { for (var t, i = -1; ++i < e;)r[(t = u[i]).i] = t.x(n); return r.join(''); }; } function Yu(n, t) { return t = (t -= n = +n) || 1 / t, function (e) { return (e - n) / t; }; } function Iu(n, t) { return t = (t -= n = +n) || 1 / t, function (e) { return Math.max(0, Math.min(1, (e - n) / t)); }; } function Zu(n) { for (var t = n.source, e = n.target, r = Xu(t, e), u = [t]; t !== r;)t = t.parent, u.push(t); for (let i = u.length; e !== r;)u.splice(i, 0, e), e = e.parent; return u; } function Vu(n) { for (var t = [], e = n.parent; e != null;)t.push(n), n = e, e = e.parent; return t.push(n), t; } function Xu(n, t) { if (n === t) return n; for (var e = Vu(n), r = Vu(t), u = e.pop(), i = r.pop(), o = null; u === i;)o = u, u = e.pop(), i = r.pop(); return o; } function $u(n) { n.fixed |= 2; } function Bu(n) { n.fixed &= -7; } function Wu(n) { n.fixed |= 4, n.px = n.x, n.py = n.y; } function Ju(n) { n.fixed &= -5; } function Gu(n, t, e) { let r = 0; let u = 0; if (n.charge = 0, !n.leaf) for (var i, o = n.nodes, a = o.length, c = -1; ++c < a;)i = o[c], i != null && (Gu(i, t, e), n.charge += i.charge, r += i.charge * i.cx, u += i.charge * i.cy); if (n.point) { n.leaf || (n.point.x += Math.random() - 0.5, n.point.y += Math.random() - 0.5); const l = t * e[n.point.index]; n.charge += n.pointCharge = l, r += l * n.point.x, u += l * n.point.y; }n.cx = r / n.charge, n.cy = u / n.charge; } function Ku(n, t) { return ta.rebind(n, t, 'sort', 'children', 'value'), n.nodes = n, n.links = ui, n; } function Qu(n, t) { for (let e = [n]; (n = e.pop()) != null;) if (t(n), (u = n.children) && (r = u.length)) for (var r, u; --r >= 0;)e.push(u[r]); } function ni(n, t) { for (var e = [n], r = []; (n = e.pop()) != null;) if (r.push(n), (i = n.children) && (u = i.length)) for (var u, i, o = -1; ++o < u;)e.push(i[o]); for (;(n = r.pop()) != null;)t(n); } function ti(n) { return n.children; } function ei(n) { return n.value; } function ri(n, t) { return t.value - n.value; } function ui(n) { return ta.merge(n.map((n) => (n.children || []).map((t) => ({ source: n, target: t })))); } function ii(n) { return n.x; } function oi(n) { return n.y; } function ai(n, t, e) { n.y0 = t, n.y = e; } function ci(n) { return ta.range(n.length); } function li(n) { for (var t = -1, e = n[0].length, r = []; ++t < e;)r[t] = 0; return r; } function si(n) { for (var t, e = 1, r = 0, u = n[0][1], i = n.length; i > e; ++e)(t = n[e][1]) > u && (r = e, u = t); return r; } function fi(n) { return n.reduce(hi, 0); } function hi(n, t) { return n + t[1]; } function gi(n, t) { return pi(n, Math.ceil(Math.log(t.length) / Math.LN2 + 1)); } function pi(n, t) { for (var e = -1, r = +n[0], u = (n[1] - r) / t, i = []; ++e <= t;)i[e] = u * e + r; return i; } function vi(n) { return [ta.min(n), ta.max(n)]; } function di(n, t) { return n.value - t.value; } function mi(n, t) { const e = n._pack_next; n._pack_next = t, t._pack_prev = n, t._pack_next = e, e._pack_prev = t; } function yi(n, t) { n._pack_next = t, t._pack_prev = n; } function Mi(n, t) { const e = t.x - n.x; const r = t.y - n.y; const u = n.r + t.r; return 0.999 * u * u > e * e + r * r; } function xi(n) { function t(n) { s = Math.min(n.x - n.r, s), f = Math.max(n.x + n.r, f), h = Math.min(n.y - n.r, h), g = Math.max(n.y + n.r, g); } if ((e = n.children) && (l = e.length)) { var e; let r; let u; let i; let o; let a; let c; var l; var s = 1 / 0; var f = -1 / 0; var h = 1 / 0; var g = -1 / 0; if (e.forEach(bi), r = e[0], r.x = -r.r, r.y = 0, t(r), l > 1 && (u = e[1], u.x = u.r, u.y = 0, t(u), l > 2)) for (i = e[2], Si(r, u, i), t(i), mi(r, i), r._pack_prev = i, mi(i, u), u = r._pack_next, o = 3; l > o; o++) { Si(r, u, i = e[o]); let p = 0; let v = 1; let d = 1; for (a = u._pack_next; a !== u; a = a._pack_next, v++) if (Mi(a, i)) { p = 1; break; } if (p == 1) for (c = r._pack_prev; c !== a._pack_prev && !Mi(c, i); c = c._pack_prev, d++);p ? (d > v || v == d && u.r < r.r ? yi(r, u = a) : yi(r = c, u), o--) : (mi(r, i), u = i, t(i)); } const m = (s + f) / 2; const y = (h + g) / 2; let M = 0; for (o = 0; l > o; o++)i = e[o], i.x -= m, i.y -= y, M = Math.max(M, i.r + Math.sqrt(i.x * i.x + i.y * i.y)); n.r = M, e.forEach(_i); } } function bi(n) { n._pack_next = n._pack_prev = n; } function _i(n) { delete n._pack_next, delete n._pack_prev; } function wi(n, t, e, r) { const u = n.children; if (n.x = t += r * n.x, n.y = e += r * n.y, n.r *= r, u) for (let i = -1, o = u.length; ++i < o;)wi(u[i], t, e, r); } function Si(n, t, e) { let r = n.r + e.r; const u = t.x - n.x; const i = t.y - n.y; if (r && (u || i)) { let o = t.r + e.r; const a = u * u + i * i; o *= o, r *= r; const c = 0.5 + (r - o) / (2 * a); const l = Math.sqrt(Math.max(0, 2 * o * (r + a) - (r -= a) * r - o * o)) / (2 * a); e.x = n.x + c * u + l * i, e.y = n.y + c * i - l * u; } else e.x = n.x + r, e.y = n.y; } function ki(n, t) { return n.parent == t.parent ? 1 : 2; } function Ei(n) { const t = n.children; return t.length ? t[0] : n.t; } function Ai(n) { let t; const e = n.children; return (t = e.length) ? e[t - 1] : n.t; } function Ni(n, t, e) { const r = e / (t.i - n.i); t.c -= r, t.s += e, n.c += r, t.z += e, t.m += e; } function Ci(n) { for (var t, e = 0, r = 0, u = n.children, i = u.length; --i >= 0;)t = u[i], t.z += e, t.m += e, e += t.s + (r += t.c); } function zi(n, t, e) { return n.a.parent === t.parent ? n.a : e; } function qi(n) { return 1 + ta.max(n, (n) => n.y); } function Li(n) { return n.reduce((n, t) => n + t.x, 0) / n.length; } function Ti(n) { const t = n.children; return t && t.length ? Ti(t[0]) : n; } function Ri(n) { let t; const e = n.children; return e && (t = e.length) ? Ri(e[t - 1]) : n; } function Di(n) {
    return {
      x: n.x, y: n.y, dx: n.dx, dy: n.dy,
    };
  } function Pi(n, t) {
    let e = n.x + t[3]; let r = n.y + t[0]; let u = n.dx - t[1] - t[3]; let i = n.dy - t[0] - t[2]; return u < 0 && (e += u / 2, u = 0), i < 0 && (r += i / 2, i = 0), {
      x: e, y: r, dx: u, dy: i,
    };
  } function Ui(n) { const t = n[0]; const e = n[n.length - 1]; return e > t ? [t, e] : [e, t]; } function ji(n) { return n.rangeExtent ? n.rangeExtent() : Ui(n.range()); } function Fi(n, t, e, r) { const u = e(n[0], n[1]); const i = r(t[0], t[1]); return function (n) { return i(u(n)); }; } function Hi(n, t) { let e; let r = 0; let u = n.length - 1; let i = n[r]; let o = n[u]; return i > o && (e = r, r = u, u = e, e = i, i = o, o = e), n[r] = t.floor(i), n[u] = t.ceil(o), n; } function Oi(n) { return n ? { floor(t) { return Math.floor(t / n) * n; }, ceil(t) { return Math.ceil(t / n) * n; } } : bl; } function Yi(n, t, e, r) { const u = []; const i = []; let o = 0; const a = Math.min(n.length, t.length) - 1; for (n[a] < n[0] && (n = n.slice().reverse(), t = t.slice().reverse()); ++o <= a;)u.push(e(n[o - 1], n[o])), i.push(r(t[o - 1], t[o])); return function (t) { const e = ta.bisect(n, t, 1, a) - 1; return i[e](u[e](t)); }; } function Ii(n, t, e, r) { function u() { const u = Math.min(n.length, t.length) > 2 ? Yi : Fi; const c = r ? Iu : Yu; return o = u(n, t, c, e), a = u(t, n, c, yu), i; } function i(n) { return o(n); } let o; let a; return i.invert = function (n) { return a(n); }, i.domain = function (t) { return arguments.length ? (n = t.map(Number), u()) : n; }, i.range = function (n) { return arguments.length ? (t = n, u()) : t; }, i.rangeRound = function (n) { return i.range(n).interpolate(Pu); }, i.clamp = function (n) { return arguments.length ? (r = n, u()) : r; }, i.interpolate = function (n) { return arguments.length ? (e = n, u()) : e; }, i.ticks = function (t) { return $i(n, t); }, i.tickFormat = function (t, e) { return Bi(n, t, e); }, i.nice = function (t) { return Vi(n, t), u(); }, i.copy = function () { return Ii(n, t, e, r); }, u(); } function Zi(n, t) { return ta.rebind(n, t, 'range', 'rangeRound', 'interpolate', 'clamp'); } function Vi(n, t) { return Hi(n, Oi(Xi(n, t)[2])); } function Xi(n, t) { t == null && (t = 10); const e = Ui(n); const r = e[1] - e[0]; let u = Math.pow(10, Math.floor(Math.log(r / t) / Math.LN10)); const i = t / r * u; return i <= 0.15 ? u *= 10 : i <= 0.35 ? u *= 5 : i <= 0.75 && (u *= 2), e[0] = Math.ceil(e[0] / u) * u, e[1] = Math.floor(e[1] / u) * u + 0.5 * u, e[2] = u, e; } function $i(n, t) { return ta.range.apply(ta, Xi(n, t)); } function Bi(n, t, e) { const r = Xi(n, t); if (e) { const u = lc.exec(e); if (u.shift(), u[8] === 's') { const i = ta.formatPrefix(Math.max(va(r[0]), va(r[1]))); return u[7] || (u[7] = `.${Wi(i.scale(r[2]))}`), u[8] = 'f', e = ta.format(u.join('')), function (n) { return e(i.scale(n)) + i.symbol; }; }u[7] || (u[7] = `.${Ji(u[8], r)}`), e = u.join(''); } else e = `,.${Wi(r[2])}f`; return ta.format(e); } function Wi(n) { return -Math.floor(Math.log(n) / Math.LN10 + 0.01); } function Ji(n, t) { const e = Wi(t[2]); return n in _l ? Math.abs(e - Wi(Math.max(va(t[0]), va(t[1])))) + +(n !== 'e') : e - 2 * (n === '%'); } function Gi(n, t, e, r) { function u(n) { return (e ? Math.log(n < 0 ? 0 : n) : -Math.log(n > 0 ? 0 : -n)) / Math.log(t); } function i(n) { return e ? Math.pow(t, n) : -Math.pow(t, -n); } function o(t) { return n(u(t)); } return o.invert = function (t) { return i(n.invert(t)); }, o.domain = function (t) { return arguments.length ? (e = t[0] >= 0, n.domain((r = t.map(Number)).map(u)), o) : r; }, o.base = function (e) { return arguments.length ? (t = +e, n.domain(r.map(u)), o) : t; }, o.nice = function () { const t = Hi(r.map(u), e ? Math : Sl); return n.domain(t), r = t.map(i), o; }, o.ticks = function () { const n = Ui(r); let o = []; const a = n[0]; const c = n[1]; let l = Math.floor(u(a)); let s = Math.ceil(u(c)); const f = t % 1 ? 2 : t; if (isFinite(s - l)) { if (e) { for (;s > l; l++) for (var h = 1; f > h; h++)o.push(i(l) * h); o.push(i(l)); } else for (o.push(i(l)); l++ < s;) for (var h = f - 1; h > 0; h--)o.push(i(l) * h); for (l = 0; o[l] < a; l++);for (s = o.length; o[s - 1] > c; s--);o = o.slice(l, s); } return o; }, o.tickFormat = function (n, t) { if (!arguments.length) return wl; arguments.length < 2 ? t = wl : typeof t !== 'function' && (t = ta.format(t)); let r; const a = Math.max(0.1, n / o.ticks().length); const c = e ? (r = 1e-12, Math.ceil) : (r = -1e-12, Math.floor); return function (n) { return n / i(c(u(n) + r)) <= a ? t(n) : ''; }; }, o.copy = function () { return Gi(n.copy(), t, e, r); }, Zi(o, n); } function Ki(n, t, e) { function r(t) { return n(u(t)); } var u = Qi(t); let i = Qi(1 / t); return r.invert = function (t) { return i(n.invert(t)); }, r.domain = function (t) { return arguments.length ? (n.domain((e = t.map(Number)).map(u)), r) : e; }, r.ticks = function (n) { return $i(e, n); }, r.tickFormat = function (n, t) { return Bi(e, n, t); }, r.nice = function (n) { return r.domain(Vi(e, n)); }, r.exponent = function (o) { return arguments.length ? (u = Qi(t = o), i = Qi(1 / t), n.domain(e.map(u)), r) : t; }, r.copy = function () { return Ki(n.copy(), t, e); }, Zi(r, n); } function Qi(n) { return function (t) { return t < 0 ? -Math.pow(-t, n) : Math.pow(t, n); }; } function no(n, t) { function e(e) { return i[((u.get(e) || (t.t === 'range' ? u.set(e, n.push(e)) : 0 / 0)) - 1) % i.length]; } function r(t, e) { return ta.range(n.length).map((n) => t + e * n); } let u; let i; let o; return e.domain = function (r) { if (!arguments.length) return n; n = [], u = new a(); for (var i, o = -1, c = r.length; ++o < c;)u.has(i = r[o]) || u.set(i, n.push(i)); return e[t.t].apply(e, t.a); }, e.range = function (n) { return arguments.length ? (i = n, o = 0, t = { t: 'range', a: arguments }, e) : i; }, e.rangePoints = function (u, a) { arguments.length < 2 && (a = 0); let c = u[0]; const l = u[1]; const s = n.length < 2 ? (c = (c + l) / 2, 0) : (l - c) / (n.length - 1 + a); return i = r(c + s * a / 2, s), o = 0, t = { t: 'rangePoints', a: arguments }, e; }, e.rangeRoundPoints = function (u, a) { arguments.length < 2 && (a = 0); let c = u[0]; let l = u[1]; const s = n.length < 2 ? (c = l = Math.round((c + l) / 2), 0) : 0 | (l - c) / (n.length - 1 + a); return i = r(c + Math.round(s * a / 2 + (l - c - (n.length - 1 + a) * s) / 2), s), o = 0, t = { t: 'rangeRoundPoints', a: arguments }, e; }, e.rangeBands = function (u, a, c) { arguments.length < 2 && (a = 0), arguments.length < 3 && (c = a); const l = u[1] < u[0]; const s = u[l - 0]; const f = u[1 - l]; const h = (f - s) / (n.length - a + 2 * c); return i = r(s + h * c, h), l && i.reverse(), o = h * (1 - a), t = { t: 'rangeBands', a: arguments }, e; }, e.rangeRoundBands = function (u, a, c) { arguments.length < 2 && (a = 0), arguments.length < 3 && (c = a); const l = u[1] < u[0]; const s = u[l - 0]; const f = u[1 - l]; const h = Math.floor((f - s) / (n.length - a + 2 * c)); return i = r(s + Math.round((f - s - (n.length - a) * h) / 2), h), l && i.reverse(), o = Math.round(h * (1 - a)), t = { t: 'rangeRoundBands', a: arguments }, e; }, e.rangeBand = function () { return o; }, e.rangeExtent = function () { return Ui(t.a[0]); }, e.copy = function () { return no(n, t); }, e.domain(n); } function to(r, u) { function i() { let n = 0; const t = u.length; for (a = []; ++n < t;)a[n - 1] = ta.quantile(r, n / t); return o; } function o(n) { return isNaN(n = +n) ? void 0 : u[ta.bisect(a, n)]; } let a; return o.domain = function (u) { return arguments.length ? (r = u.map(t).filter(e).sort(n), i()) : r; }, o.range = function (n) { return arguments.length ? (u = n, i()) : u; }, o.quantiles = function () { return a; }, o.invertExtent = function (n) { return n = u.indexOf(n), n < 0 ? [0 / 0, 0 / 0] : [n > 0 ? a[n - 1] : r[0], n < a.length ? a[n] : r[r.length - 1]]; }, o.copy = function () { return to(r, u); }, i(); } function eo(n, t, e) { function r(t) { return e[Math.max(0, Math.min(o, Math.floor(i * (t - n))))]; } function u() { return i = e.length / (t - n), o = e.length - 1, r; } let i; let o; return r.domain = function (e) { return arguments.length ? (n = +e[0], t = +e[e.length - 1], u()) : [n, t]; }, r.range = function (n) { return arguments.length ? (e = n, u()) : e; }, r.invertExtent = function (t) { return t = e.indexOf(t), t = t < 0 ? 0 / 0 : t / i + n, [t, t + 1 / i]; }, r.copy = function () { return eo(n, t, e); }, u(); } function ro(n, t) { function e(e) { return e >= e ? t[ta.bisect(n, e)] : void 0; } return e.domain = function (t) { return arguments.length ? (n = t, e) : n; }, e.range = function (n) { return arguments.length ? (t = n, e) : t; }, e.invertExtent = function (e) { return e = t.indexOf(e), [n[e - 1], n[e]]; }, e.copy = function () { return ro(n, t); }, e; } function uo(n) { function t(n) { return +n; } return t.invert = t, t.domain = t.range = function (e) { return arguments.length ? (n = e.map(t), t) : n; }, t.ticks = function (t) { return $i(n, t); }, t.tickFormat = function (t, e) { return Bi(n, t, e); }, t.copy = function () { return uo(n); }, t; } function io() { return 0; } function oo(n) { return n.innerRadius; } function ao(n) { return n.outerRadius; } function co(n) { return n.startAngle; } function lo(n) { return n.endAngle; } function so(n) { return n && n.padAngle; } function fo(n, t, e, r) { return (n - e) * t - (t - r) * n > 0 ? 0 : 1; } function ho(n, t, e, r, u) { const i = n[0] - t[0]; const o = n[1] - t[1]; const a = (u ? r : -r) / Math.sqrt(i * i + o * o); const c = a * o; const l = -a * i; const s = n[0] + c; const f = n[1] + l; const h = t[0] + c; const g = t[1] + l; const p = (s + h) / 2; const v = (f + g) / 2; const d = h - s; const m = g - f; const y = d * d + m * m; const M = e - r; const x = s * g - h * f; const b = (m < 0 ? -1 : 1) * Math.sqrt(M * M * y - x * x); let _ = (x * m - d * b) / y; let w = (-x * d - m * b) / y; const S = (x * m + d * b) / y; const k = (-x * d + m * b) / y; const E = _ - p; const A = w - v; const N = S - p; const C = k - v; return E * E + A * A > N * N + C * C && (_ = S, w = k), [[_ - c, w - l], [_ * e / M, w * e / M]]; } function go(n) { function t(t) { function o() { l.push('M', i(n(s), a)); } for (var c, l = [], s = [], f = -1, h = t.length, g = Et(e), p = Et(r); ++f < h;)u.call(this, c = t[f], f) ? s.push([+g.call(this, c, f), +p.call(this, c, f)]) : s.length && (o(), s = []); return s.length && o(), l.length ? l.join('') : null; } var e = Nr; var r = Cr; var u = Ce; var i = po; let o = i.key; var a = 0.7; return t.x = function (n) { return arguments.length ? (e = n, t) : e; }, t.y = function (n) { return arguments.length ? (r = n, t) : r; }, t.defined = function (n) { return arguments.length ? (u = n, t) : u; }, t.interpolate = function (n) { return arguments.length ? (o = typeof n === 'function' ? i = n : (i = zl.get(n) || po).key, t) : o; }, t.tension = function (n) { return arguments.length ? (a = n, t) : a; }, t; } function po(n) { return n.join('L'); } function vo(n) { return `${po(n)}Z`; } function mo(n) { for (var t = 0, e = n.length, r = n[0], u = [r[0], ',', r[1]]; ++t < e;)u.push('H', (r[0] + (r = n[t])[0]) / 2, 'V', r[1]); return e > 1 && u.push('H', r[0]), u.join(''); } function yo(n) { for (var t = 0, e = n.length, r = n[0], u = [r[0], ',', r[1]]; ++t < e;)u.push('V', (r = n[t])[1], 'H', r[0]); return u.join(''); } function Mo(n) { for (var t = 0, e = n.length, r = n[0], u = [r[0], ',', r[1]]; ++t < e;)u.push('H', (r = n[t])[0], 'V', r[1]); return u.join(''); } function xo(n, t) { return n.length < 4 ? po(n) : n[1] + wo(n.slice(1, -1), So(n, t)); } function bo(n, t) { return n.length < 3 ? po(n) : n[0] + wo((n.push(n[0]), n), So([n[n.length - 2]].concat(n, [n[1]]), t)); } function _o(n, t) { return n.length < 3 ? po(n) : n[0] + wo(n, So(n, t)); } function wo(n, t) { if (t.length < 1 || n.length != t.length && n.length != t.length + 2) return po(n); const e = n.length != t.length; let r = ''; let u = n[0]; let i = n[1]; const o = t[0]; let a = o; let c = 1; if (e && (r += `Q${i[0] - 2 * o[0] / 3},${i[1] - 2 * o[1] / 3},${i[0]},${i[1]}`, u = n[1], c = 2), t.length > 1) { a = t[1], i = n[c], c++, r += `C${u[0] + o[0]},${u[1] + o[1]},${i[0] - a[0]},${i[1] - a[1]},${i[0]},${i[1]}`; for (let l = 2; l < t.length; l++, c++)i = n[c], a = t[l], r += `S${i[0] - a[0]},${i[1] - a[1]},${i[0]},${i[1]}`; } if (e) { const s = n[c]; r += `Q${i[0] + 2 * a[0] / 3},${i[1] + 2 * a[1] / 3},${s[0]},${s[1]}`; } return r; } function So(n, t) { for (var e, r = [], u = (1 - t) / 2, i = n[0], o = n[1], a = 1, c = n.length; ++a < c;)e = i, i = o, o = n[a], r.push([u * (o[0] - e[0]), u * (o[1] - e[1])]); return r; } function ko(n) { if (n.length < 3) return po(n); let t = 1; const e = n.length; let r = n[0]; const u = r[0]; const i = r[1]; const o = [u, u, u, (r = n[1])[0]]; const a = [i, i, i, r[1]]; const c = [u, ',', i, 'L', Co(Tl, o), ',', Co(Tl, a)]; for (n.push(n[e - 1]); ++t <= e;)r = n[t], o.shift(), o.push(r[0]), a.shift(), a.push(r[1]), zo(c, o, a); return n.pop(), c.push('L', r), c.join(''); } function Eo(n) { if (n.length < 4) return po(n); for (var t, e = [], r = -1, u = n.length, i = [0], o = [0]; ++r < 3;)t = n[r], i.push(t[0]), o.push(t[1]); for (e.push(`${Co(Tl, i)},${Co(Tl, o)}`), --r; ++r < u;)t = n[r], i.shift(), i.push(t[0]), o.shift(), o.push(t[1]), zo(e, i, o); return e.join(''); } function Ao(n) { for (var t, e, r = -1, u = n.length, i = u + 4, o = [], a = []; ++r < 4;)e = n[r % u], o.push(e[0]), a.push(e[1]); for (t = [Co(Tl, o), ',', Co(Tl, a)], --r; ++r < i;)e = n[r % u], o.shift(), o.push(e[0]), a.shift(), a.push(e[1]), zo(t, o, a); return t.join(''); } function No(n, t) { const e = n.length - 1; if (e) for (var r, u, i = n[0][0], o = n[0][1], a = n[e][0] - i, c = n[e][1] - o, l = -1; ++l <= e;)r = n[l], u = l / e, r[0] = t * r[0] + (1 - t) * (i + u * a), r[1] = t * r[1] + (1 - t) * (o + u * c); return ko(n); } function Co(n, t) { return n[0] * t[0] + n[1] * t[1] + n[2] * t[2] + n[3] * t[3]; } function zo(n, t, e) { n.push('C', Co(ql, t), ',', Co(ql, e), ',', Co(Ll, t), ',', Co(Ll, e), ',', Co(Tl, t), ',', Co(Tl, e)); } function qo(n, t) { return (t[1] - n[1]) / (t[0] - n[0]); } function Lo(n) { for (var t = 0, e = n.length - 1, r = [], u = n[0], i = n[1], o = r[0] = qo(u, i); ++t < e;)r[t] = (o + (o = qo(u = i, i = n[t + 1]))) / 2; return r[t] = o, r; } function To(n) { for (var t, e, r, u, i = [], o = Lo(n), a = -1, c = n.length - 1; ++a < c;)t = qo(n[a], n[a + 1]), va(t) < Ta ? o[a] = o[a + 1] = 0 : (e = o[a] / t, r = o[a + 1] / t, u = e * e + r * r, u > 9 && (u = 3 * t / Math.sqrt(u), o[a] = u * e, o[a + 1] = u * r)); for (a = -1; ++a <= c;)u = (n[Math.min(c, a + 1)][0] - n[Math.max(0, a - 1)][0]) / (6 * (1 + o[a] * o[a])), i.push([u || 0, o[a] * u || 0]); return i; } function Ro(n) { return n.length < 3 ? po(n) : n[0] + wo(n, To(n)); } function Do(n) { for (var t, e, r, u = -1, i = n.length; ++u < i;)t = n[u], e = t[0], r = t[1] - ja, t[0] = e * Math.cos(r), t[1] = e * Math.sin(r); return n; } function Po(n) {
    function t(t) { function c() { v.push('M', a(n(m), f), s, l(n(d.reverse()), f), 'Z'); } for (var h, g, p, v = [], d = [], m = [], y = -1, M = t.length, x = Et(e), b = Et(u), _ = e === r ? function () { return g; } : Et(r), w = u === i ? function () { return p; } : Et(i); ++y < M;)o.call(this, h = t[y], y) ? (d.push([g = +x.call(this, h, y), p = +b.call(this, h, y)]), m.push([+_.call(this, h, y), +w.call(this, h, y)])) : d.length && (c(), d = [], m = []); return d.length && c(), v.length ? v.join('') : null; } var e = Nr; var r = Nr; var u = 0; var i = Cr; var o = Ce; var a = po; let c = a.key; var l = a; var s = 'L'; var f = 0.7; return t.x = function (n) { return arguments.length ? (e = r = n, t) : r; }, t.x0 = function (n) { return arguments.length ? (e = n, t) : e; }, t.x1 = function (n) { return arguments.length ? (r = n, t) : r; }, t.y = function (n) { return arguments.length ? (u = i = n, t) : i; }, t.y0 = function (n) { return arguments.length ? (u = n, t) : u; }, t.y1 = function (n) { return arguments.length ? (i = n, t) : i; }, t.defined = function (n) { return arguments.length ? (o = n, t) : o; }, t.interpolate = function (n) {
      return arguments.length ? (c = typeof n === 'function' ? a = n : (a = zl.get(n) || po).key, l = a.reverse || a, s = a.closed ? 'M' : 'L', t) : c;
    }, t.tension = function (n) { return arguments.length ? (f = n, t) : f; }, t;
  } function Uo(n) { return n.radius; } function jo(n) { return [n.x, n.y]; } function Fo(n) { return function () { const t = n.apply(this, arguments); const e = t[0]; const r = t[1] - ja; return [e * Math.cos(r), e * Math.sin(r)]; }; } function Ho() { return 64; } function Oo() { return 'circle'; } function Yo(n) { const t = Math.sqrt(n / Da); return `M0,${t}A${t},${t} 0 1,1 0,${-t}A${t},${t} 0 1,1 0,${t}Z`; } function Io(n, t, e) { return xa(n, Fl), n.namespace = t, n.id = e, n; } function Zo(n, t, e, r) { const u = n.id; const i = n.namespace; return H(n, typeof e === 'function' ? (n, o, a) => { n[i][u].tween.set(t, r(e.call(n, n.__data__, o, a))); } : (e = r(e), function (n) { n[i][u].tween.set(t, e); })); } function Vo(n) { return n == null && (n = ''), function () { this.textContent = n; }; } function Xo(n) { return n == null ? '__transition__' : `__transition_${n}__`; } function $o(n, t, e, r, u) {
    const i = n[e] || (n[e] = { active: 0, count: 0 }); let o = i[r]; if (!o) {
      const c = u.time; o = i[r] = {
        tween: new a(), time: c, delay: u.delay, duration: u.duration, ease: u.ease,
      }, u = null, ++i.count, ta.timer((u) => { function a(e) { return i.active > r ? s(!1) : (i.active = r, o.event && o.event.start.call(n, g, t), o.tween.forEach((e, r) => { (r = r.call(n, g, t)) && d.push(r); }), h = o.ease, f = o.duration, ta.timer(() => (v.c = l(e || 1) ? Ce : l, 1), 0, c), void 0); } function l(t) { if (i.active !== r) return s(!1); for (var e = t / f, u = h(e), o = d.length; o > 0;)d[--o].call(n, u); return e >= 1 ? s(!0) : void 0; } function s(u) { return o.event && o.event[u ? 'end' : 'interrupt'].call(n, g, t), --i.count ? delete i[r] : delete n[e], 1; } let f; let h; var g = n.__data__; const p = o.delay; var v = oc; var d = []; return v.t = p + c, u >= p ? a(u - p) : (v.c = a, void 0); }, 0, c);
    }
  } function Bo(n, t, e) { n.attr('transform', (n) => { const r = t(n); return `translate(${isFinite(r) ? r : e(n)},0)`; }); } function Wo(n, t, e) { n.attr('transform', (n) => { const r = t(n); return `translate(0,${isFinite(r) ? r : e(n)})`; }); } function Jo(n) { return n.toISOString(); } function Go(n, t, e) { function r(t) { return n(t); } function u(n, e) { const r = n[1] - n[0]; const u = r / e; const i = ta.bisect(Bl, u); return i == Bl.length ? [t.year, Xi(n.map((n) => n / 31536e6), e)[2]] : i ? t[u / Bl[i - 1] < Bl[i] / u ? i - 1 : i] : [Gl, Xi(n, e)[2]]; } return r.invert = function (t) { return Ko(n.invert(t)); }, r.domain = function (t) { return arguments.length ? (n.domain(t), r) : n.domain().map(Ko); }, r.nice = function (n, t) { function e(e) { return !isNaN(e) && !n.range(e, Ko(+e + 1), t).length; } const i = r.domain(); const o = Ui(i); const a = n == null ? u(o, 10) : typeof n === 'number' && u(o, n); return a && (n = a[0], t = a[1]), r.domain(Hi(i, t > 1 ? { floor(t) { for (;e(t = n.floor(t));)t = Ko(t - 1); return t; }, ceil(t) { for (;e(t = n.ceil(t));)t = Ko(+t + 1); return t; } } : n)); }, r.ticks = function (n, t) { const e = Ui(r.domain()); const i = n == null ? u(e, 10) : typeof n === 'number' ? u(e, n) : !n.range && [{ range: n }, t]; return i && (n = i[0], t = i[1]), n.range(e[0], Ko(+e[1] + 1), t < 1 ? 1 : t); }, r.tickFormat = function () { return e; }, r.copy = function () { return Go(n.copy(), t, e); }, Zi(r, n); } function Ko(n) { return new Date(n); } function Qo(n) { return JSON.parse(n.responseText); } function na(n) { const t = ua.createRange(); return t.selectNode(ua.body), t.createContextualFragment(n.responseText); } var ta = { version: '3.5.0' }; Date.now || (Date.now = function () { return +new Date(); }); const ea = [].slice; var ra = function (n) { return ea.call(n); }; var ua = document; var ia = ua.documentElement; var oa = window; try { ra(ia.childNodes)[0].nodeType; } catch (aa) { ra = function (n) { for (var t = n.length, e = new Array(t); t--;)e[t] = n[t]; return e; }; } try { ua.createElement('div').style.setProperty('opacity', 0, ''); } catch (ca) { const la = oa.Element.prototype; const sa = la.setAttribute; const fa = la.setAttributeNS; const ha = oa.CSSStyleDeclaration.prototype; const ga = ha.setProperty; la.setAttribute = function (n, t) { sa.call(this, n, `${t}`); }, la.setAttributeNS = function (n, t, e) { fa.call(this, n, t, `${e}`); }, ha.setProperty = function (n, t, e) { ga.call(this, n, `${t}`, e); }; }ta.ascending = n, ta.descending = function (n, t) { return n > t ? -1 : t > n ? 1 : t >= n ? 0 : 0 / 0; }, ta.min = function (n, t) { let e; let r; let u = -1; const i = n.length; if (arguments.length === 1) { for (;++u < i;) if ((r = n[u]) != null && r >= r) { e = r; break; } for (;++u < i;)(r = n[u]) != null && e > r && (e = r); } else { for (;++u < i;) if ((r = t.call(n, n[u], u)) != null && r >= r) { e = r; break; } for (;++u < i;)(r = t.call(n, n[u], u)) != null && e > r && (e = r); } return e; }, ta.max = function (n, t) { let e; let r; let u = -1; const i = n.length; if (arguments.length === 1) { for (;++u < i;) if ((r = n[u]) != null && r >= r) { e = r; break; } for (;++u < i;)(r = n[u]) != null && r > e && (e = r); } else { for (;++u < i;) if ((r = t.call(n, n[u], u)) != null && r >= r) { e = r; break; } for (;++u < i;)(r = t.call(n, n[u], u)) != null && r > e && (e = r); } return e; }, ta.extent = function (n, t) { let e; let r; let u; let i = -1; const o = n.length; if (arguments.length === 1) { for (;++i < o;) if ((r = n[i]) != null && r >= r) { e = u = r; break; } for (;++i < o;)(r = n[i]) != null && (e > r && (e = r), r > u && (u = r)); } else { for (;++i < o;) if ((r = t.call(n, n[i], i)) != null && r >= r) { e = u = r; break; } for (;++i < o;)(r = t.call(n, n[i], i)) != null && (e > r && (e = r), r > u && (u = r)); } return [e, u]; }, ta.sum = function (n, t) { let r; let u = 0; const i = n.length; let o = -1; if (arguments.length === 1) for (;++o < i;)e(r = +n[o]) && (u += r); else for (;++o < i;)e(r = +t.call(n, n[o], o)) && (u += r); return u; }, ta.mean = function (n, r) { let u; let i = 0; const o = n.length; let a = -1; let c = o; if (arguments.length === 1) for (;++a < o;)e(u = t(n[a])) ? i += u : --c; else for (;++a < o;)e(u = t(r.call(n, n[a], a))) ? i += u : --c; return c ? i / c : void 0; }, ta.quantile = function (n, t) { const e = (n.length - 1) * t + 1; const r = Math.floor(e); const u = +n[r - 1]; const i = e - r; return i ? u + i * (n[r] - u) : u; }, ta.median = function (r, u) { let i; const o = []; const a = r.length; let c = -1; if (arguments.length === 1) for (;++c < a;)e(i = t(r[c])) && o.push(i); else for (;++c < a;)e(i = t(u.call(r, r[c], c))) && o.push(i); return o.length ? ta.quantile(o.sort(n), 0.5) : void 0; }; const pa = r(n); ta.bisectLeft = pa.left, ta.bisect = ta.bisectRight = pa.right, ta.bisector = function (t) { return r(t.length === 1 ? (e, r) => n(t(e), r) : t); }, ta.shuffle = function (n, t, e) { (i = arguments.length) < 3 && (e = n.length, i < 2 && (t = 0)); for (var r, u, i = e - t; i;)u = 0 | Math.random() * i--, r = n[i + t], n[i + t] = n[u + t], n[u + t] = r; return n; }, ta.permute = function (n, t) { for (var e = t.length, r = new Array(e); e--;)r[e] = n[t[e]]; return r; }, ta.pairs = function (n) { for (var t, e = 0, r = n.length - 1, u = n[0], i = new Array(r < 0 ? 0 : r); r > e;)i[e] = [t = u, u = n[++e]]; return i; }, ta.zip = function () { if (!(r = arguments.length)) return []; for (var n = -1, t = ta.min(arguments, u), e = new Array(t); ++n < t;) for (var r, i = -1, o = e[n] = new Array(r); ++i < r;)o[i] = arguments[i][n]; return e; }, ta.transpose = function (n) { return ta.zip.apply(ta, n); }, ta.keys = function (n) { const t = []; for (const e in n)t.push(e); return t; }, ta.values = function (n) { const t = []; for (const e in n)t.push(n[e]); return t; }, ta.entries = function (n) { const t = []; for (const e in n)t.push({ key: e, value: n[e] }); return t; }, ta.merge = function (n) { for (var t, e, r, u = n.length, i = -1, o = 0; ++i < u;)o += n[i].length; for (e = new Array(o); --u >= 0;) for (r = n[u], t = r.length; --t >= 0;)e[--o] = r[t]; return e; }; var va = Math.abs; ta.range = function (n, t, e) { if (arguments.length < 3 && (e = 1, arguments.length < 2 && (t = n, n = 0)), 1 / 0 === (t - n) / e) throw new Error('infinite range'); let r; const u = []; const o = i(va(e)); let a = -1; if (n *= o, t *= o, e *= o, e < 0) for (;(r = n + e * ++a) > t;)u.push(r / o); else for (;(r = n + e * ++a) < t;)u.push(r / o); return u; }, ta.map = function (n, t) { const e = new a(); if (n instanceof a)n.forEach((n, t) => { e.set(n, t); }); else if (Array.isArray(n)) { let r; let u = -1; const i = n.length; if (arguments.length === 1) for (;++u < i;)e.set(u, n[u]); else for (;++u < i;)e.set(t.call(n, r = n[u], u), r); } else for (const o in n)e.set(o, n[o]); return e; }; var da = '__proto__'; var ma = '\x00'; o(a, {
    has: s, get(n) { return this._[c(n)]; }, set(n, t) { return this._[c(n)] = t; }, remove: f, keys: h, values() { const n = []; for (const t in this._)n.push(this._[t]); return n; }, entries() { const n = []; for (const t in this._)n.push({ key: l(t), value: this._[t] }); return n; }, size: g, empty: p, forEach(n) { for (const t in this._)n.call(this, l(t), this._[t]); },
  }), ta.nest = function () { function n(t, o, c) { if (c >= i.length) return r ? r.call(u, o) : e ? o.sort(e) : o; for (var l, s, f, h, g = -1, p = o.length, v = i[c++], d = new a(); ++g < p;)(h = d.get(l = v(s = o[g]))) ? h.push(s) : d.set(l, [s]); return t ? (s = t(), f = function (e, r) { s.set(e, n(t, r, c)); }) : (s = {}, f = function (e, r) { s[e] = n(t, r, c); }), d.forEach(f), s; } function t(n, e) { if (e >= i.length) return n; const r = []; const u = o[e++]; return n.forEach((n, u) => { r.push({ key: n, values: t(u, e) }); }), u ? r.sort((n, t) => u(n.key, t.key)) : r; } let e; let r; var u = {}; var i = []; var o = []; return u.map = function (t, e) { return n(e, t, 0); }, u.entries = function (e) { return t(n(ta.map, e, 0), 0); }, u.key = function (n) { return i.push(n), u; }, u.sortKeys = function (n) { return o[i.length - 1] = n, u; }, u.sortValues = function (n) { return e = n, u; }, u.rollup = function (n) { return r = n, u; }, u; }, ta.set = function (n) { const t = new v(); if (n) for (let e = 0, r = n.length; r > e; ++e)t.add(n[e]); return t; }, o(v, {
    has: s, add(n) { return this._[c(n += '')] = !0, n; }, remove: f, values: h, size: g, empty: p, forEach(n) { for (const t in this._)n.call(this, l(t)); },
  }), ta.behavior = {}, ta.rebind = function (n, t) { for (var e, r = 1, u = arguments.length; ++r < u;)n[e = arguments[r]] = d(n, t, t[e]); return n; }; var ya = ['webkit', 'ms', 'moz', 'Moz', 'o', 'O']; ta.dispatch = function () { for (var n = new M(), t = -1, e = arguments.length; ++t < e;)n[arguments[t]] = x(n); return n; }, M.prototype.on = function (n, t) { const e = n.indexOf('.'); let r = ''; if (e >= 0 && (r = n.slice(e + 1), n = n.slice(0, e)), n) return arguments.length < 2 ? this[n].on(r) : this[n].on(r, t); if (arguments.length === 2) { if (t == null) for (n in this) this.hasOwnProperty(n) && this[n].on(r, null); return this; } }, ta.event = null, ta.requote = function (n) { return n.replace(Ma, '\\$&'); }; var Ma = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g; var xa = {}.__proto__ ? function (n, t) { n.__proto__ = t; } : function (n, t) { for (const e in t)n[e] = t[e]; }; var ba = function (n, t) { return t.querySelector(n); }; var _a = function (n, t) { return t.querySelectorAll(n); }; const wa = ia.matches || ia[m(ia, 'matchesSelector')]; var Sa = function (n, t) { return wa.call(n, t); }; typeof Sizzle === 'function' && (ba = function (n, t) { return Sizzle(n, t)[0] || null; }, _a = Sizzle, Sa = Sizzle.matchesSelector), ta.selection = function () { return Na; }; var ka = ta.selection.prototype = []; ka.select = function (n) { let t; let e; let r; let u; const i = []; n = k(n); for (let o = -1, a = this.length; ++o < a;) { i.push(t = []), t.parentNode = (r = this[o]).parentNode; for (let c = -1, l = r.length; ++c < l;)(u = r[c]) ? (t.push(e = n.call(u, u.__data__, c, o)), e && '__data__' in u && (e.__data__ = u.__data__)) : t.push(null); } return S(i); }, ka.selectAll = function (n) { let t; let e; const r = []; n = E(n); for (let u = -1, i = this.length; ++u < i;) for (let o = this[u], a = -1, c = o.length; ++a < c;)(e = o[a]) && (r.push(t = ra(n.call(e, e.__data__, a, u))), t.parentNode = e); return S(r); }; const Ea = {
    svg: 'http://www.w3.org/2000/svg', xhtml: 'http://www.w3.org/1999/xhtml', xlink: 'http://www.w3.org/1999/xlink', xml: 'http://www.w3.org/XML/1998/namespace', xmlns: 'http://www.w3.org/2000/xmlns/',
  }; ta.ns = { prefix: Ea, qualify(n) { const t = n.indexOf(':'); let e = n; return t >= 0 && (e = n.slice(0, t), n = n.slice(t + 1)), Ea.hasOwnProperty(e) ? { space: Ea[e], local: n } : n; } }, ka.attr = function (n, t) { if (arguments.length < 2) { if (typeof n === 'string') { const e = this.node(); return n = ta.ns.qualify(n), n.local ? e.getAttributeNS(n.space, n.local) : e.getAttribute(n); } for (t in n) this.each(A(t, n[t])); return this; } return this.each(A(n, t)); }, ka.classed = function (n, t) { if (arguments.length < 2) { if (typeof n === 'string') { const e = this.node(); const r = (n = z(n)).length; let u = -1; if (t = e.classList) { for (;++u < r;) if (!t.contains(n[u])) return !1; } else for (t = e.getAttribute('class'); ++u < r;) if (!C(n[u]).test(t)) return !1; return !0; } for (t in n) this.each(q(t, n[t])); return this; } return this.each(q(n, t)); }, ka.style = function (n, t, e) { const r = arguments.length; if (r < 3) { if (typeof n !== 'string') { r < 2 && (t = ''); for (e in n) this.each(T(e, n[e], t)); return this; } if (r < 2) return oa.getComputedStyle(this.node(), null).getPropertyValue(n); e = ''; } return this.each(T(n, t, e)); }, ka.property = function (n, t) { if (arguments.length < 2) { if (typeof n === 'string') return this.node()[n]; for (t in n) this.each(R(t, n[t])); return this; } return this.each(R(n, t)); }, ka.text = function (n) { return arguments.length ? this.each(typeof n === 'function' ? function () { const t = n.apply(this, arguments); this.textContent = t == null ? '' : t; } : n == null ? function () { this.textContent = ''; } : function () { this.textContent = n; }) : this.node().textContent; }, ka.html = function (n) { return arguments.length ? this.each(typeof n === 'function' ? function () { const t = n.apply(this, arguments); this.innerHTML = t == null ? '' : t; } : n == null ? function () { this.innerHTML = ''; } : function () { this.innerHTML = n; }) : this.node().innerHTML; }, ka.append = function (n) { return n = D(n), this.select(function () { return this.appendChild(n.apply(this, arguments)); }); }, ka.insert = function (n, t) { return n = D(n), t = k(t), this.select(function () { return this.insertBefore(n.apply(this, arguments), t.apply(this, arguments) || null); }); }, ka.remove = function () { return this.each(P); }, ka.data = function (n, t) { function e(n, e) { let r; let u; let i; const o = n.length; const f = e.length; const h = Math.min(o, f); const g = new Array(f); const p = new Array(f); const v = new Array(o); if (t) { let d; const m = new a(); const y = new Array(o); for (r = -1; ++r < o;)m.has(d = t.call(u = n[r], u.__data__, r)) ? v[r] = u : m.set(d, u), y[r] = d; for (r = -1; ++r < f;)(u = m.get(d = t.call(e, i = e[r], r))) ? u !== !0 && (g[r] = u, u.__data__ = i) : p[r] = U(i), m.set(d, !0); for (r = -1; ++r < o;)m.get(y[r]) !== !0 && (v[r] = n[r]); } else { for (r = -1; ++r < h;)u = n[r], i = e[r], u ? (u.__data__ = i, g[r] = u) : p[r] = U(i); for (;f > r; ++r)p[r] = U(e[r]); for (;o > r; ++r)v[r] = n[r]; }p.update = g, p.parentNode = g.parentNode = v.parentNode = n.parentNode, c.push(p), l.push(g), s.push(v); } let r; let u; let i = -1; let o = this.length; if (!arguments.length) { for (n = new Array(o = (r = this[0]).length); ++i < o;)(u = r[i]) && (n[i] = u.__data__); return n; } var c = O([]); var l = S([]); var s = S([]); if (typeof n === 'function') for (;++i < o;)e(r = this[i], n.call(r, r.parentNode.__data__, i)); else for (;++i < o;)e(r = this[i], n); return l.enter = function () { return c; }, l.exit = function () { return s; }, l; }, ka.datum = function (n) { return arguments.length ? this.property('__data__', n) : this.property('__data__'); }, ka.filter = function (n) { let t; let e; let r; const u = []; typeof n !== 'function' && (n = j(n)); for (let i = 0, o = this.length; o > i; i++) { u.push(t = []), t.parentNode = (e = this[i]).parentNode; for (let a = 0, c = e.length; c > a; a++)(r = e[a]) && n.call(r, r.__data__, a, i) && t.push(r); } return S(u); }, ka.order = function () { for (let n = -1, t = this.length; ++n < t;) for (var e, r = this[n], u = r.length - 1, i = r[u]; --u >= 0;)(e = r[u]) && (i && i !== e.nextSibling && i.parentNode.insertBefore(e, i), i = e); return this; }, ka.sort = function (n) { n = F.apply(this, arguments); for (let t = -1, e = this.length; ++t < e;) this[t].sort(n); return this.order(); }, ka.each = function (n) { return H(this, (t, e, r) => { n.call(t, t.__data__, e, r); }); }, ka.call = function (n) { const t = ra(arguments); return n.apply(t[0] = this, t), this; }, ka.empty = function () { return !this.node(); }, ka.node = function () { for (let n = 0, t = this.length; t > n; n++) for (let e = this[n], r = 0, u = e.length; u > r; r++) { const i = e[r]; if (i) return i; } return null; }, ka.size = function () { let n = 0; return H(this, () => { ++n; }), n; }; var Aa = []; ta.selection.enter = O, ta.selection.enter.prototype = Aa, Aa.append = ka.append, Aa.empty = ka.empty, Aa.node = ka.node, Aa.call = ka.call, Aa.size = ka.size, Aa.select = function (n) { for (var t, e, r, u, i, o = [], a = -1, c = this.length; ++a < c;) { r = (u = this[a]).update, o.push(t = []), t.parentNode = u.parentNode; for (let l = -1, s = u.length; ++l < s;)(i = u[l]) ? (t.push(r[l] = e = n.call(u.parentNode, i.__data__, l, a)), e.__data__ = i.__data__) : t.push(null); } return S(o); }, Aa.insert = function (n, t) { return arguments.length < 2 && (t = Y(this)), ka.insert.call(this, n, t); }, ka.transition = function (n) {
    for (var t, e, r = Dl || ++Hl, u = Xo(n), i = [], o = Pl || {
        time: Date.now(), ease: ku, delay: 0, duration: 250,
      }, a = -1, c = this.length; ++a < c;) { i.push(t = []); for (let l = this[a], s = -1, f = l.length; ++s < f;)(e = l[s]) && $o(e, s, u, r, o), t.push(e); } return Io(i, u, r);
  }, ka.interrupt = function (n) { const t = Xo(n); return this.each(function () { const n = this[t]; n && ++n.active; }); }, ta.select = function (n) { const t = [typeof n === 'string' ? ba(n, ua) : n]; return t.parentNode = ia, S([t]); }, ta.selectAll = function (n) { const t = ra(typeof n === 'string' ? _a(n, ua) : n); return t.parentNode = ia, S([t]); }; var Na = ta.select(ia); ka.on = function (n, t, e) { let r = arguments.length; if (r < 3) { if (typeof n !== 'string') { r < 2 && (t = !1); for (e in n) this.each(Z(e, n[e], t)); return this; } if (r < 2) return (r = this.node()[`__on${n}`]) && r._; e = !1; } return this.each(Z(n, t, e)); }; var Ca = ta.map({ mouseenter: 'mouseover', mouseleave: 'mouseout' }); Ca.forEach((n) => { `on${n}` in ua && Ca.remove(n); }); var za = 'onselectstart' in ua ? null : m(ia.style, 'userSelect'); var qa = 0; ta.mouse = function (n) { return B(n, _()); }; var La = /WebKit/.test(oa.navigator.userAgent) ? -1 : 0; ta.touch = function (n, t, e) { if (arguments.length < 3 && (e = t, t = _().changedTouches), t) for (var r, u = 0, i = t.length; i > u; ++u) if ((r = t[u]).identifier === e) return B(n, r); }, ta.behavior.drag = function () {
    function n() { this.on('mousedown.drag', u).on('touchstart.drag', i); } function t(n, t, u, i, o) {
      return function () {
        function a() {
          let n; let e; const r = t(h, v); r && (n = r[0] - M[0], e = r[1] - M[1], p |= n | e, M = r, g({
            type: 'drag', x: r[0] + l[0], y: r[1] + l[1], dx: n, dy: e,
          }));
        } function c() { t(h, v) && (m.on(i + d, null).on(o + d, null), y(p && ta.event.target === f), g({ type: 'dragend' })); } let l; const s = this; var f = ta.event.target; var h = s.parentNode; var g = e.of(s, arguments); var p = 0; var v = n(); var d = `.drag${v == null ? '' : `-${v}`}`; var m = ta.select(u()).on(i + d, a).on(o + d, c); var y = $(); var M = t(h, v); r ? (l = r.apply(s, arguments), l = [l.x - M[0], l.y - M[1]]) : l = [0, 0], g({ type: 'dragstart' });
      };
    } var e = w(n, 'drag', 'dragstart', 'dragend'); var r = null; var u = t(y, ta.mouse, G, 'mousemove', 'mouseup'); var i = t(W, ta.touch, J, 'touchmove', 'touchend'); return n.origin = function (t) { return arguments.length ? (r = t, n) : r; }, ta.rebind(n, e, 'on');
  }, ta.touches = function (n, t) { return arguments.length < 2 && (t = _().touches), t ? ra(t).map((t) => { const e = B(n, t); return e.identifier = t.identifier, e; }) : []; }; var Ta = 1e-6; var Ra = Ta * Ta; var Da = Math.PI; var Pa = 2 * Da; const Ua = Pa - Ta; var ja = Da / 2; var Fa = Da / 180; var Ha = 180 / Da; const Oa = Math.SQRT2; const Ya = 2; const Ia = 4; ta.interpolateZoom = function (n, t) { function e(n) { const t = n * y; if (m) { const e = rt(v); const o = i / (Ya * h) * (e * ut(Oa * t + v) - et(v)); return [r + o * l, u + o * s, i * e / rt(Oa * t + v)]; } return [r + n * l, u + n * s, i * Math.exp(Oa * t)]; } var r = n[0]; var u = n[1]; var i = n[2]; const o = t[0]; const a = t[1]; const c = t[2]; var l = o - r; var s = a - u; const f = l * l + s * s; var h = Math.sqrt(f); const g = (c * c - i * i + Ia * f) / (2 * i * Ya * h); const p = (c * c - i * i - Ia * f) / (2 * c * Ya * h); var v = Math.log(Math.sqrt(g * g + 1) - g); const d = Math.log(Math.sqrt(p * p + 1) - p); var m = d - v; var y = (m || Math.log(c / i)) / Oa; return e.duration = 1e3 * y, e; }, ta.behavior.zoom = function () {
    function n(n) { n.on(z, s).on(`${Xa}.zoom`, h).on('dblclick.zoom', g).on(T, f); } function t(n) { return [(n[0] - k.x) / k.k, (n[1] - k.y) / k.k]; } function e(n) { return [n[0] * k.k + k.x, n[1] * k.k + k.y]; } function r(n) { k.k = Math.max(A[0], Math.min(A[1], n)); } function u(n, t) { t = e(t), k.x += n[0] - t[0], k.y += n[1] - t[1]; } function i(t, e, i, o) { t.__chart__ = { x: k.x, y: k.y, k: k.k }, r(Math.pow(2, o)), u(v = e, i), t = ta.select(t), N > 0 && (t = t.transition().duration(N)), t.call(n.event); } function o() { x && x.domain(M.range().map((n) => (n - k.x) / k.k).map(M.invert)), S && S.domain(_.range().map((n) => (n - k.y) / k.k).map(_.invert)); } function a(n) { C++ || n({ type: 'zoomstart' }); } function c(n) { o(), n({ type: 'zoom', scale: k.k, translate: [k.x, k.y] }); } function l(n) { --C || n({ type: 'zoomend' }), v = null; } function s() { function n() { s = 1, u(ta.mouse(r), h), c(o); } function e() { f.on(q, null).on(L, null), g(s && ta.event.target === i), l(o); } var r = this; var i = ta.event.target; var o = R.of(r, arguments); var s = 0; var f = ta.select(oa).on(q, n).on(L, e); var h = t(ta.mouse(r)); var g = $(); I(r), a(o); } function f() { function n() { const n = ta.touches(p); return g = k.k, n.forEach((n) => { n.identifier in d && (d[n.identifier] = t(n)); }), n; } function e() { const t = ta.event.target; ta.select(t).on(x, o).on(_, h), w.push(t); for (let e = ta.event.changedTouches, r = 0, u = e.length; u > r; ++r)d[e[r].identifier] = null; const a = n(); const c = Date.now(); if (a.length === 1) { if (c - y < 500) { var l = a[0]; i(p, l, d[l.identifier], Math.floor(Math.log(k.k) / Math.LN2) + 1), b(); }y = c; } else if (a.length > 1) { var l = a[0]; const s = a[1]; const f = l[0] - s[0]; const g = l[1] - s[1]; m = f * f + g * g; } } function o() { let n; let t; let e; let i; const o = ta.touches(p); I(p); for (let a = 0, l = o.length; l > a; ++a, i = null) if (e = o[a], i = d[e.identifier]) { if (t) break; n = e, t = i; } if (i) { var s = (s = e[0] - n[0]) * s + (s = e[1] - n[1]) * s; const f = m && Math.sqrt(s / m); n = [(n[0] + e[0]) / 2, (n[1] + e[1]) / 2], t = [(t[0] + i[0]) / 2, (t[1] + i[1]) / 2], r(f * g); }y = null, u(n, t), c(v); } function h() { if (ta.event.touches.length) { for (let t = ta.event.changedTouches, e = 0, r = t.length; r > e; ++e) delete d[t[e].identifier]; for (const u in d) return void n(); }ta.selectAll(w).on(M, null), S.on(z, s).on(T, f), E(), l(v); } let g; var p = this; var v = R.of(p, arguments); var d = {}; var m = 0; var M = `.zoom-${ta.event.changedTouches[0].identifier}`; var x = `touchmove${M}`; var _ = `touchend${M}`; var w = []; var S = ta.select(p); var E = $(); e(), a(v), S.on(z, null).on(T, e); } function h() { const n = R.of(this, arguments); m ? clearTimeout(m) : (p = t(v = d || ta.mouse(this)), I(this), a(n)), m = setTimeout(() => { m = null, l(n); }, 50), b(), r(Math.pow(2, 0.002 * Za()) * k.k), u(v, p), c(n); } function g() { const n = ta.mouse(this); const e = Math.log(k.k) / Math.LN2; i(this, n, t(n), ta.event.shiftKey ? Math.ceil(e) - 1 : Math.floor(e) + 1); } let p; let v; let d; let m; let y; let M; let x; let _; let S; var k = { x: 0, y: 0, k: 1 }; let E = [960, 500]; var A = Va; var N = 250; var C = 0; var z = 'mousedown.zoom'; var q = 'mousemove.zoom'; var L = 'mouseup.zoom'; var T = 'touchstart.zoom'; var R = w(n, 'zoomstart', 'zoom', 'zoomend'); return n.event = function (n) {
      n.each(function () {
        const n = R.of(this, arguments); const t = k; Dl ? ta.select(this).transition().each('start.zoom', function () { k = this.__chart__ || { x: 0, y: 0, k: 1 }, a(n); }).tween('zoom:zoom', () => { const e = E[0]; const r = E[1]; const u = v ? v[0] : e / 2; const i = v ? v[1] : r / 2; const o = ta.interpolateZoom([(u - k.x) / k.k, (i - k.y) / k.k, e / k.k], [(u - t.x) / t.k, (i - t.y) / t.k, e / t.k]); return function (t) { const r = o(t); const a = e / r[2]; this.__chart__ = k = { x: u - r[0] * a, y: i - r[1] * a, k: a }, c(n); }; })
          .each('interrupt.zoom', () => { l(n); })
          .each('end.zoom', () => { l(n); }) : (this.__chart__ = k, a(n), c(n), l(n));
      });
    }, n.translate = function (t) { return arguments.length ? (k = { x: +t[0], y: +t[1], k: k.k }, o(), n) : [k.x, k.y]; }, n.scale = function (t) { return arguments.length ? (k = { x: k.x, y: k.y, k: +t }, o(), n) : k.k; }, n.scaleExtent = function (t) { return arguments.length ? (A = t == null ? Va : [+t[0], +t[1]], n) : A; }, n.center = function (t) { return arguments.length ? (d = t && [+t[0], +t[1]], n) : d; }, n.size = function (t) { return arguments.length ? (E = t && [+t[0], +t[1]], n) : E; }, n.duration = function (t) { return arguments.length ? (N = +t, n) : N; }, n.x = function (t) { return arguments.length ? (x = t, M = t.copy(), k = { x: 0, y: 0, k: 1 }, n) : x; }, n.y = function (t) { return arguments.length ? (S = t, _ = t.copy(), k = { x: 0, y: 0, k: 1 }, n) : S; }, ta.rebind(n, R, 'on');
  }; let Za; var Va = [0, 1 / 0]; var Xa = 'onwheel' in ua ? (Za = function () { return -ta.event.deltaY * (ta.event.deltaMode ? 120 : 1); }, 'wheel') : 'onmousewheel' in ua ? (Za = function () { return ta.event.wheelDelta; }, 'mousewheel') : (Za = function () { return -ta.event.detail; }, 'MozMousePixelScroll'); ta.color = ot, ot.prototype.toString = function () { return `${this.rgb()}`; }, ta.hsl = at; const $a = at.prototype = new ot(); $a.brighter = function (n) { return n = Math.pow(0.7, arguments.length ? n : 1), new at(this.h, this.s, this.l / n); }, $a.darker = function (n) { return n = Math.pow(0.7, arguments.length ? n : 1), new at(this.h, this.s, n * this.l); }, $a.rgb = function () { return ct(this.h, this.s, this.l); }, ta.hcl = lt; const Ba = lt.prototype = new ot(); Ba.brighter = function (n) { return new lt(this.h, this.c, Math.min(100, this.l + Wa * (arguments.length ? n : 1))); }, Ba.darker = function (n) { return new lt(this.h, this.c, Math.max(0, this.l - Wa * (arguments.length ? n : 1))); }, Ba.rgb = function () { return st(this.h, this.c, this.l).rgb(); }, ta.lab = ft; var Wa = 18; var Ja = 0.95047; var Ga = 1; var Ka = 1.08883; const Qa = ft.prototype = new ot(); Qa.brighter = function (n) { return new ft(Math.min(100, this.l + Wa * (arguments.length ? n : 1)), this.a, this.b); }, Qa.darker = function (n) { return new ft(Math.max(0, this.l - Wa * (arguments.length ? n : 1)), this.a, this.b); }, Qa.rgb = function () { return ht(this.l, this.a, this.b); }, ta.rgb = mt; const nc = mt.prototype = new ot(); nc.brighter = function (n) { n = Math.pow(0.7, arguments.length ? n : 1); let t = this.r; let e = this.g; let r = this.b; const u = 30; return t || e || r ? (t && u > t && (t = u), e && u > e && (e = u), r && u > r && (r = u), new mt(Math.min(255, t / n), Math.min(255, e / n), Math.min(255, r / n))) : new mt(u, u, u); }, nc.darker = function (n) { return n = Math.pow(0.7, arguments.length ? n : 1), new mt(n * this.r, n * this.g, n * this.b); }, nc.hsl = function () { return _t(this.r, this.g, this.b); }, nc.toString = function () { return `#${xt(this.r)}${xt(this.g)}${xt(this.b)}`; }; var tc = ta.map({
    aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074,
  }); tc.forEach((n, t) => { tc.set(n, yt(t)); }), ta.functor = Et, ta.xhr = Nt(At), ta.dsv = function (n, t) {
    function e(n, e, i) { arguments.length < 3 && (i = e, e = null); const o = Ct(n, t, e == null ? r : u(e), i); return o.row = function (n) { return arguments.length ? o.response((e = n) == null ? r : u(n)) : e; }, o; } function r(n) { return e.parse(n.responseText); } function u(n) { return function (t) { return e.parse(t.responseText, n); }; } function i(t) { return t.map(o).join(n); } function o(n) { return a.test(n) ? `"${n.replace(/\"/g, '""')}"` : n; } var a = new RegExp(`["${n}\n]`); const c = n.charCodeAt(0); return e.parse = function (n, t) { let r; return e.parseRows(n, (n, e) => { if (r) return r(n, e - 1); const u = new Function('d', `return {${n.map((n, t) => `${JSON.stringify(n)}: d[${t}]`).join(',')}}`); r = t ? function (n, e) { return t(u(n), e); } : u; }); }, e.parseRows = function (n, t) { function e() { if (s >= l) return o; if (u) return u = !1, i; const t = s; if (n.charCodeAt(t) === 34) { for (var e = t; e++ < l;) if (n.charCodeAt(e) === 34) { if (n.charCodeAt(e + 1) !== 34) break; ++e; }s = e + 2; var r = n.charCodeAt(e + 1); return r === 13 ? (u = !0, n.charCodeAt(e + 2) === 10 && ++s) : r === 10 && (u = !0), n.slice(t + 1, e).replace(/""/g, '"'); } for (;l > s;) { var r = n.charCodeAt(s++); let a = 1; if (r === 10)u = !0; else if (r === 13)u = !0, n.charCodeAt(s) === 10 && (++s, ++a); else if (r !== c) continue; return n.slice(t, s - a); } return n.slice(t); } for (var r, u, i = {}, o = {}, a = [], l = n.length, s = 0, f = 0; (r = e()) !== o;) { for (var h = []; r !== i && r !== o;)h.push(r), r = e(); t && (h = t(h, f++)) == null || a.push(h); } return a; }, e.format = function (t) {
      if (Array.isArray(t[0])) return e.formatRows(t); const r = new v();
      const u = []; return t.forEach((n) => { for (const t in n)r.has(t) || u.push(r.add(t)); }), [u.map(o).join(n)].concat(t.map((t) => u.map((n) => o(t[n])).join(n))).join('\n');
    }, e.formatRows = function (n) { return n.map(i).join('\n'); }, e;
  }, ta.csv = ta.dsv(',', 'text/csv'), ta.tsv = ta.dsv('	', 'text/tab-separated-values'); let ec; let rc; let uc; let ic; let oc; var ac = oa[m(oa, 'requestAnimationFrame')] || function (n) { setTimeout(n, 17); }; ta.timer = function (n, t, e) {
    const r = arguments.length; r < 2 && (t = 0), r < 3 && (e = Date.now()); const u = e + t; const i = {
      c: n, t: u, f: !1, n: null,
    }; rc ? rc.n = i : ec = i, rc = i, uc || (ic = clearTimeout(ic), uc = 1, ac(Lt));
  }, ta.timer.flush = function () { Tt(), Rt(); }, ta.round = function (n, t) { return t ? Math.round(n * (t = Math.pow(10, t))) / t : Math.round(n); }; const cc = ['y', 'z', 'a', 'f', 'p', 'n', '\xb5', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'].map(Pt); ta.formatPrefix = function (n, t) { let e = 0; return n && (n < 0 && (n *= -1), t && (n = ta.round(n, Dt(n, t))), e = 1 + Math.floor(1e-12 + Math.log(n) / Math.LN10), e = Math.max(-24, Math.min(24, 3 * Math.floor((e - 1) / 3)))), cc[8 + e / 3]; }; var lc = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i; var sc = ta.map({
    b(n) { return n.toString(2); }, c(n) { return String.fromCharCode(n); }, o(n) { return n.toString(8); }, x(n) { return n.toString(16); }, X(n) { return n.toString(16).toUpperCase(); }, g(n, t) { return n.toPrecision(t); }, e(n, t) { return n.toExponential(t); }, f(n, t) { return n.toFixed(t); }, r(n, t) { return (n = ta.round(n, Dt(n, t))).toFixed(Math.max(0, Math.min(20, Dt(n * (1 + 1e-15), t)))); },
  }); var fc = ta.time = {}; var hc = Date; Ft.prototype = {
    getDate() { return this._.getUTCDate(); }, getDay() { return this._.getUTCDay(); }, getFullYear() { return this._.getUTCFullYear(); }, getHours() { return this._.getUTCHours(); }, getMilliseconds() { return this._.getUTCMilliseconds(); }, getMinutes() { return this._.getUTCMinutes(); }, getMonth() { return this._.getUTCMonth(); }, getSeconds() { return this._.getUTCSeconds(); }, getTime() { return this._.getTime(); }, getTimezoneOffset() { return 0; }, valueOf() { return this._.valueOf(); }, setDate() { gc.setUTCDate.apply(this._, arguments); }, setDay() { gc.setUTCDay.apply(this._, arguments); }, setFullYear() { gc.setUTCFullYear.apply(this._, arguments); }, setHours() { gc.setUTCHours.apply(this._, arguments); }, setMilliseconds() { gc.setUTCMilliseconds.apply(this._, arguments); }, setMinutes() { gc.setUTCMinutes.apply(this._, arguments); }, setMonth() { gc.setUTCMonth.apply(this._, arguments); }, setSeconds() { gc.setUTCSeconds.apply(this._, arguments); }, setTime() { gc.setTime.apply(this._, arguments); },
  }; var gc = Date.prototype; fc.year = Ht((n) => (n = fc.day(n), n.setMonth(0, 1), n), (n, t) => { n.setFullYear(n.getFullYear() + t); }, (n) => n.getFullYear()), fc.years = fc.year.range, fc.years.utc = fc.year.utc.range, fc.day = Ht((n) => { const t = new hc(2e3, 0); return t.setFullYear(n.getFullYear(), n.getMonth(), n.getDate()), t; }, (n, t) => { n.setDate(n.getDate() + t); }, (n) => n.getDate() - 1), fc.days = fc.day.range, fc.days.utc = fc.day.utc.range, fc.dayOfYear = function (n) { const t = fc.year(n); return Math.floor((n - t - 6e4 * (n.getTimezoneOffset() - t.getTimezoneOffset())) / 864e5); }, ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'].forEach((n, t) => { t = 7 - t; const e = fc[n] = Ht((n) => ((n = fc.day(n)).setDate(n.getDate() - (n.getDay() + t) % 7), n), (n, t) => { n.setDate(n.getDate() + 7 * Math.floor(t)); }, (n) => { const e = fc.year(n).getDay(); return Math.floor((fc.dayOfYear(n) + (e + t) % 7) / 7) - (e !== t); }); fc[`${n}s`] = e.range, fc[`${n}s`].utc = e.utc.range, fc[`${n}OfYear`] = function (n) { const e = fc.year(n).getDay(); return Math.floor((fc.dayOfYear(n) + (e + t) % 7) / 7); }; }), fc.week = fc.sunday, fc.weeks = fc.sunday.range, fc.weeks.utc = fc.sunday.utc.range, fc.weekOfYear = fc.sundayOfYear; var pc = { '-': '', _: ' ', 0: '0' }; var vc = /^\s*\d+/; var dc = /^%/; ta.locale = function (n) { return { numberFormat: Ut(n), timeFormat: Yt(n) }; }; const mc = ta.locale({
    decimal: '.', thousands: ',', grouping: [3], currency: ['$', ''], dateTime: '%a %b %e %X %Y', date: '%m/%d/%Y', time: '%H:%M:%S', periods: ['AM', 'PM'], days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'], shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  }); ta.format = mc.numberFormat, ta.geo = {}, le.prototype = {
    s: 0, t: 0, add(n) { se(n, this.t, yc), se(yc.s, this.s, this), this.s ? this.t += yc.t : this.s = yc.t; }, reset() { this.s = this.t = 0; }, valueOf() { return this.s; },
  }; var yc = new le(); ta.geo.stream = function (n, t) { n && Mc.hasOwnProperty(n.type) ? Mc[n.type](n, t) : fe(n, t); }; var Mc = { Feature(n, t) { fe(n.geometry, t); }, FeatureCollection(n, t) { for (let e = n.features, r = -1, u = e.length; ++r < u;)fe(e[r].geometry, t); } }; var xc = {
    Sphere(n, t) { t.sphere(); },
    Point(n, t) { n = n.coordinates, t.point(n[0], n[1], n[2]); },
    MultiPoint(n, t) { for (let e = n.coordinates, r = -1, u = e.length; ++r < u;)n = e[r], t.point(n[0], n[1], n[2]); },
    LineString(n, t) { he(n.coordinates, t, 0); },
    MultiLineString(n, t) { for (let e = n.coordinates, r = -1, u = e.length; ++r < u;)he(e[r], t, 0); },
    Polygon(n, t) { ge(n.coordinates, t); },
    MultiPolygon(n, t) {
      for (let e = n.coordinates, r = -1, u = e.length; ++r < u;)ge(e[r], t);
    },
    GeometryCollection(n, t) { for (let e = n.geometries, r = -1, u = e.length; ++r < u;)fe(e[r], t); },
  }; ta.geo.area = function (n) { return bc = 0, ta.geo.stream(n, wc), bc; }; let bc; var _c = new le(); var wc = {
    sphere() { bc += 4 * Da; }, point: y, lineStart: y, lineEnd: y, polygonStart() { _c.reset(), wc.lineStart = pe; }, polygonEnd() { const n = 2 * _c; bc += n < 0 ? 4 * Da + n : n, wc.lineStart = wc.lineEnd = wc.point = y; },
  }; ta.geo.bounds = (function () {
    function n(n, t) { M.push(x = [s = n, h = n]), f > t && (f = t), t > g && (g = t); } function t(t, e) { const r = ve([t * Fa, e * Fa]); if (m) { const u = me(m, r); const i = [u[1], -u[0], 0]; let o = me(i, u); xe(o), o = be(o); const c = t - p; const l = c > 0 ? 1 : -1; let v = o[0] * Ha * l; const d = va(c) > 180; if (d ^ (v > l * p && l * t > v)) { var y = o[1] * Ha; y > g && (g = y); } else if (v = (v + 360) % 360 - 180, d ^ (v > l * p && l * t > v)) { var y = -o[1] * Ha; f > y && (f = y); } else f > e && (f = e), e > g && (g = e); d ? p > t ? a(s, t) > a(s, h) && (h = t) : a(t, h) > a(s, h) && (s = t) : h >= s ? (s > t && (s = t), t > h && (h = t)) : t > p ? a(s, t) > a(s, h) && (h = t) : a(t, h) > a(s, h) && (s = t); } else n(t, e); m = r, p = t; } function e() { b.point = t; } function r() { x[0] = s, x[1] = h, b.point = n, m = null; } function u(n, e) { if (m) { const r = n - p; y += va(r) > 180 ? r + (r > 0 ? 360 : -360) : r; } else v = n, d = e; wc.point(n, e), t(n, e); } function i() { wc.lineStart(); } function o() { u(v, d), wc.lineEnd(), va(y) > Ta && (s = -(h = 180)), x[0] = s, x[1] = h, m = null; } function a(n, t) { return (t -= n) < 0 ? t + 360 : t; } function c(n, t) { return n[0] - t[0]; } function l(n, t) { return t[0] <= t[1] ? t[0] <= n && n <= t[1] : n < t[0] || t[1] < n; } let s; let f; let h; let g; let p; let v; let d; let m; let y; let M; let x; var b = {
      point: n, lineStart: e, lineEnd: r, polygonStart() { b.point = u, b.lineStart = i, b.lineEnd = o, y = 0, wc.polygonStart(); }, polygonEnd() { wc.polygonEnd(), b.point = n, b.lineStart = e, b.lineEnd = r, _c < 0 ? (s = -(h = 180), f = -(g = 90)) : y > Ta ? g = 90 : -Ta > y && (f = -90), x[0] = s, x[1] = h; },
    }; return function (n) { g = h = -(s = f = 1 / 0), M = [], ta.geo.stream(n, b); var t = M.length; if (t) { M.sort(c); for (var e, r = 1, u = M[0], i = [u]; t > r; ++r)e = M[r], l(e[0], u) || l(e[1], u) ? (a(u[0], e[1]) > a(u[0], u[1]) && (u[1] = e[1]), a(e[0], u[1]) > a(u[0], u[1]) && (u[0] = e[0])) : i.push(u = e); for (var o, e, p = -1 / 0, t = i.length - 1, r = 0, u = i[t]; t >= r; u = e, ++r)e = i[r], (o = a(u[1], e[0])) > p && (p = o, s = e[0], h = u[1]); } return M = x = null, 1 / 0 === s || 1 / 0 === f ? [[0 / 0, 0 / 0], [0 / 0, 0 / 0]] : [[s, f], [h, g]]; };
  }()), ta.geo.centroid = function (n) { Sc = kc = Ec = Ac = Nc = Cc = zc = qc = Lc = Tc = Rc = 0, ta.geo.stream(n, Dc); let t = Lc; let e = Tc; let r = Rc; let u = t * t + e * e + r * r; return Ra > u && (t = Cc, e = zc, r = qc, Ta > kc && (t = Ec, e = Ac, r = Nc), u = t * t + e * e + r * r, Ra > u) ? [0 / 0, 0 / 0] : [Math.atan2(e, t) * Ha, tt(r / Math.sqrt(u)) * Ha]; }; let Sc; let kc; let Ec; let Ac; let Nc; let Cc; let zc; let qc; let Lc; let Tc; let Rc; var Dc = {
    sphere: y, point: we, lineStart: ke, lineEnd: Ee, polygonStart() { Dc.lineStart = Ae; }, polygonEnd() { Dc.lineStart = ke; },
  }; var Pc = Te(Ce, Ue, Fe, [-Da, -Da / 2]); var Uc = 1e9; ta.geo.clipExtent = function () { let n; let t; let e; let r; let u; let i; var o = { stream(n) { return u && (u.valid = !1), u = i(n), u.valid = !0, u; }, extent(a) { return arguments.length ? (i = Ie(n = +a[0][0], t = +a[0][1], e = +a[1][0], r = +a[1][1]), u && (u.valid = !1, u = null), o) : [[n, t], [e, r]]; } }; return o.extent([[0, 0], [960, 500]]); }, (ta.geo.conicEqualArea = function () { return Ze(Ve); }).raw = Ve, ta.geo.albers = function () {
    return ta.geo.conicEqualArea().rotate([96, 0]).center([-0.6, 38.7]).parallels([29.5, 45.5])
      .scale(1070);
  }, ta.geo.albersUsa = function () {
    function n(n) { const i = n[0]; const o = n[1]; return t = null, e(i, o), t || (r(i, o), t) || u(i, o), t; } let t; let e; let r; let u; const i = ta.geo.albers(); const o = ta.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]); const a = ta.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]); const c = { point(n, e) { t = [n, e]; } }; return n.invert = function (n) { const t = i.scale(); const e = i.translate(); const r = (n[0] - e[0]) / t; const u = (n[1] - e[1]) / t; return (u >= 0.12 && u < 0.234 && r >= -0.425 && r < -0.214 ? o : u >= 0.166 && u < 0.234 && r >= -0.214 && r < -0.115 ? a : i).invert(n); }, n.stream = function (n) {
      const t = i.stream(n); const e = o.stream(n); const r = a.stream(n); return {
        point(n, u) { t.point(n, u), e.point(n, u), r.point(n, u); }, sphere() { t.sphere(), e.sphere(), r.sphere(); }, lineStart() { t.lineStart(), e.lineStart(), r.lineStart(); }, lineEnd() { t.lineEnd(), e.lineEnd(), r.lineEnd(); }, polygonStart() { t.polygonStart(), e.polygonStart(), r.polygonStart(); }, polygonEnd() { t.polygonEnd(), e.polygonEnd(), r.polygonEnd(); },
      };
    }, n.precision = function (t) { return arguments.length ? (i.precision(t), o.precision(t), a.precision(t), n) : i.precision(); }, n.scale = function (t) { return arguments.length ? (i.scale(t), o.scale(0.35 * t), a.scale(t), n.translate(i.translate())) : i.scale(); }, n.translate = function (t) { if (!arguments.length) return i.translate(); const l = i.scale(); const s = +t[0]; const f = +t[1]; return e = i.translate(t).clipExtent([[s - 0.455 * l, f - 0.238 * l], [s + 0.455 * l, f + 0.238 * l]]).stream(c).point, r = o.translate([s - 0.307 * l, f + 0.201 * l]).clipExtent([[s - 0.425 * l + Ta, f + 0.12 * l + Ta], [s - 0.214 * l - Ta, f + 0.234 * l - Ta]]).stream(c).point, u = a.translate([s - 0.205 * l, f + 0.212 * l]).clipExtent([[s - 0.214 * l + Ta, f + 0.166 * l + Ta], [s - 0.115 * l - Ta, f + 0.234 * l - Ta]]).stream(c).point, n; }, n.scale(1070);
  }; let jc; let Fc; let Hc; let Oc; let Yc; let Ic; var Zc = {
    point: y, lineStart: y, lineEnd: y, polygonStart() { Fc = 0, Zc.lineStart = Xe; }, polygonEnd() { Zc.lineStart = Zc.lineEnd = Zc.point = y, jc += va(Fc / 2); },
  }; const Vc = {
    point: $e, lineStart: y, lineEnd: y, polygonStart: y, polygonEnd: y,
  }; var Xc = {
    point: Je, lineStart: Ge, lineEnd: Ke, polygonStart() { Xc.lineStart = Qe; }, polygonEnd() { Xc.point = Je, Xc.lineStart = Ge, Xc.lineEnd = Ke; },
  }; ta.geo.path = function () { function n(n) { return n && (typeof a === 'function' && i.pointRadius(+a.apply(this, arguments)), o && o.valid || (o = u(i)), ta.geo.stream(n, o)), i.result(); } function t() { return o = null, n; } let e; let r; let u; let i; let o; var a = 4.5; return n.area = function (n) { return jc = 0, ta.geo.stream(n, u(Zc)), jc; }, n.centroid = function (n) { return Ec = Ac = Nc = Cc = zc = qc = Lc = Tc = Rc = 0, ta.geo.stream(n, u(Xc)), Rc ? [Lc / Rc, Tc / Rc] : qc ? [Cc / qc, zc / qc] : Nc ? [Ec / Nc, Ac / Nc] : [0 / 0, 0 / 0]; }, n.bounds = function (n) { return Yc = Ic = -(Hc = Oc = 1 / 0), ta.geo.stream(n, u(Vc)), [[Hc, Oc], [Yc, Ic]]; }, n.projection = function (n) { return arguments.length ? (u = (e = n) ? n.stream || er(n) : At, t()) : e; }, n.context = function (n) { return arguments.length ? (i = (r = n) == null ? new Be() : new nr(n), typeof a !== 'function' && i.pointRadius(a), t()) : r; }, n.pointRadius = function (t) { return arguments.length ? (a = typeof t === 'function' ? t : (i.pointRadius(+t), +t), n) : a; }, n.projection(ta.geo.albersUsa()).context(null); }, ta.geo.transform = function (n) { return { stream(t) { const e = new rr(t); for (const r in n)e[r] = n[r]; return e; } }; }, rr.prototype = {
    point(n, t) { this.stream.point(n, t); }, sphere() { this.stream.sphere(); }, lineStart() { this.stream.lineStart(); }, lineEnd() { this.stream.lineEnd(); }, polygonStart() { this.stream.polygonStart(); }, polygonEnd() { this.stream.polygonEnd(); },
  }, ta.geo.projection = ir, ta.geo.projectionMutator = or, (ta.geo.equirectangular = function () { return ir(cr); }).raw = cr.invert = cr, ta.geo.rotation = function (n) { function t(t) { return t = n(t[0] * Fa, t[1] * Fa), t[0] *= Ha, t[1] *= Ha, t; } return n = sr(n[0] % 360 * Fa, n[1] * Fa, n.length > 2 ? n[2] * Fa : 0), t.invert = function (t) { return t = n.invert(t[0] * Fa, t[1] * Fa), t[0] *= Ha, t[1] *= Ha, t; }, t; }, lr.invert = cr, ta.geo.circle = function () { function n() { const n = typeof r === 'function' ? r.apply(this, arguments) : r; const t = sr(-n[0] * Fa, -n[1] * Fa, 0).invert; const u = []; return e(null, null, 1, { point(n, e) { u.push(n = t(n, e)), n[0] *= Ha, n[1] *= Ha; } }), { type: 'Polygon', coordinates: [u] }; } let t; let e; var r = [0, 0]; let u = 6; return n.origin = function (t) { return arguments.length ? (r = t, n) : r; }, n.angle = function (r) { return arguments.length ? (e = pr((t = +r) * Fa, u * Fa), n) : t; }, n.precision = function (r) { return arguments.length ? (e = pr(t * Fa, (u = +r) * Fa), n) : u; }, n.angle(90); }, ta.geo.distance = function (n, t) { let e; const r = (t[0] - n[0]) * Fa; const u = n[1] * Fa; const i = t[1] * Fa; const o = Math.sin(r); const a = Math.cos(r); const c = Math.sin(u); const l = Math.cos(u); const s = Math.sin(i); const f = Math.cos(i); return Math.atan2(Math.sqrt((e = f * o) * e + (e = l * s - c * f * a) * e), c * s + l * f * a); }, ta.geo.graticule = function () {
    function n() { return { type: 'MultiLineString', coordinates: t() }; } function t() {
      return ta.range(Math.ceil(i / d) * d, u, d).map(h).concat(ta.range(Math.ceil(l / m) * m, c, m).map(g)).concat(ta.range(Math.ceil(r / p) * p, e, p).filter((n) => va(n % d) > Ta).map(s))
        .concat(ta.range(Math.ceil(a / v) * v, o, v).filter((n) => va(n % m) > Ta).map(f));
    } let e; let r; let u; let i; let o; let a; let c; let l; let s; let f; let h; let g; var p = 10; var v = p; var d = 90; var m = 360; let y = 2.5; return n.lines = function () { return t().map((n) => ({ type: 'LineString', coordinates: n })); }, n.outline = function () { return { type: 'Polygon', coordinates: [h(i).concat(g(c).slice(1), h(u).reverse().slice(1), g(l).reverse().slice(1))] }; }, n.extent = function (t) { return arguments.length ? n.majorExtent(t).minorExtent(t) : n.minorExtent(); }, n.majorExtent = function (t) { return arguments.length ? (i = +t[0][0], u = +t[1][0], l = +t[0][1], c = +t[1][1], i > u && (t = i, i = u, u = t), l > c && (t = l, l = c, c = t), n.precision(y)) : [[i, l], [u, c]]; }, n.minorExtent = function (t) { return arguments.length ? (r = +t[0][0], e = +t[1][0], a = +t[0][1], o = +t[1][1], r > e && (t = r, r = e, e = t), a > o && (t = a, a = o, o = t), n.precision(y)) : [[r, a], [e, o]]; }, n.step = function (t) { return arguments.length ? n.majorStep(t).minorStep(t) : n.minorStep(); }, n.majorStep = function (t) { return arguments.length ? (d = +t[0], m = +t[1], n) : [d, m]; }, n.minorStep = function (t) { return arguments.length ? (p = +t[0], v = +t[1], n) : [p, v]; }, n.precision = function (t) { return arguments.length ? (y = +t, s = dr(a, o, 90), f = mr(r, e, y), h = dr(l, c, 90), g = mr(i, u, y), n) : y; }, n.majorExtent([[-180, -90 + Ta], [180, 90 - Ta]]).minorExtent([[-180, -80 - Ta], [180, 80 + Ta]]);
  }, ta.geo.greatArc = function () { function n() { return { type: 'LineString', coordinates: [t || r.apply(this, arguments), e || u.apply(this, arguments)] }; } let t; let e; var r = yr; var u = Mr; return n.distance = function () { return ta.geo.distance(t || r.apply(this, arguments), e || u.apply(this, arguments)); }, n.source = function (e) { return arguments.length ? (r = e, t = typeof e === 'function' ? null : e, n) : r; }, n.target = function (t) { return arguments.length ? (u = t, e = typeof t === 'function' ? null : t, n) : u; }, n.precision = function () { return arguments.length ? n : 0; }, n; }, ta.geo.interpolate = function (n, t) { return xr(n[0] * Fa, n[1] * Fa, t[0] * Fa, t[1] * Fa); }, ta.geo.length = function (n) { return $c = 0, ta.geo.stream(n, Bc), $c; }; let $c; var Bc = {
    sphere: y, point: y, lineStart: br, lineEnd: y, polygonStart: y, polygonEnd: y,
  }; const Wc = _r((n) => Math.sqrt(2 / (1 + n)), (n) => 2 * Math.asin(n / 2)); (ta.geo.azimuthalEqualArea = function () { return ir(Wc); }).raw = Wc; const Jc = _r((n) => { const t = Math.acos(n); return t && t / Math.sin(t); }, At); (ta.geo.azimuthalEquidistant = function () { return ir(Jc); }).raw = Jc, (ta.geo.conicConformal = function () { return Ze(wr); }).raw = wr, (ta.geo.conicEquidistant = function () { return Ze(Sr); }).raw = Sr; const Gc = _r((n) => 1 / n, Math.atan); (ta.geo.gnomonic = function () { return ir(Gc); }).raw = Gc, kr.invert = function (n, t) { return [n, 2 * Math.atan(Math.exp(t)) - ja]; }, (ta.geo.mercator = function () { return Er(kr); }).raw = kr; const Kc = _r(() => 1, Math.asin); (ta.geo.orthographic = function () { return ir(Kc); }).raw = Kc; const Qc = _r((n) => 1 / (1 + n), (n) => 2 * Math.atan(n)); (ta.geo.stereographic = function () { return ir(Qc); }).raw = Qc, Ar.invert = function (n, t) { return [-t, 2 * Math.atan(Math.exp(n)) - ja]; }, (ta.geo.transverseMercator = function () { const n = Er(Ar); const t = n.center; const e = n.rotate; return n.center = function (n) { return n ? t([-n[1], n[0]]) : (n = t(), [n[1], -n[0]]); }, n.rotate = function (n) { return n ? e([n[0], n[1], n.length > 2 ? n[2] + 90 : 90]) : (n = e(), [n[0], n[1], n[2] - 90]); }, e([0, 0, 90]); }).raw = Ar, ta.geom = {}, ta.geom.hull = function (n) { function t(n) { if (n.length < 3) return []; let t; const u = Et(e); const i = Et(r); const o = n.length; const a = []; const c = []; for (t = 0; o > t; t++)a.push([+u.call(this, n[t], t), +i.call(this, n[t], t), t]); for (a.sort(qr), t = 0; o > t; t++)c.push([a[t][0], -a[t][1]]); const l = zr(a); const s = zr(c); const f = s[0] === l[0]; const h = s[s.length - 1] === l[l.length - 1]; const g = []; for (t = l.length - 1; t >= 0; --t)g.push(n[a[l[t]][2]]); for (t = +f; t < s.length - h; ++t)g.push(n[a[s[t]][2]]); return g; } var e = Nr; var r = Cr; return arguments.length ? t(n) : (t.x = function (n) { return arguments.length ? (e = n, t) : e; }, t.y = function (n) { return arguments.length ? (r = n, t) : r; }, t); }, ta.geom.polygon = function (n) { return xa(n, nl), n; }; var nl = ta.geom.polygon.prototype = []; nl.area = function () { for (var n, t = -1, e = this.length, r = this[e - 1], u = 0; ++t < e;)n = r, r = this[t], u += n[1] * r[0] - n[0] * r[1]; return 0.5 * u; }, nl.centroid = function (n) { let t; let e; let r = -1; const u = this.length; let i = 0; let o = 0; let a = this[u - 1]; for (arguments.length || (n = -1 / (6 * this.area())); ++r < u;)t = a, a = this[r], e = t[0] * a[1] - a[0] * t[1], i += (t[0] + a[0]) * e, o += (t[1] + a[1]) * e; return [i * n, o * n]; }, nl.clip = function (n) { for (var t, e, r, u, i, o, a = Rr(n), c = -1, l = this.length - Rr(this), s = this[l - 1]; ++c < l;) { for (t = n.slice(), n.length = 0, u = this[c], i = t[(r = t.length - a) - 1], e = -1; ++e < r;)o = t[e], Lr(o, s, u) ? (Lr(i, s, u) || n.push(Tr(i, o, s, u)), n.push(o)) : Lr(i, s, u) && n.push(Tr(i, o, s, u)), i = o; a && n.push(n[0]), s = u; } return n; }; let tl; let el; let rl; let ul; let il; var ol = []; var al = []; Yr.prototype.prepare = function () { for (var n, t = this.edges, e = t.length; e--;)n = t[e].edge, n.b && n.a || t.splice(e, 1); return t.sort(Zr), t.length; }, nu.prototype = { start() { return this.edge.l === this.site ? this.edge.a : this.edge.b; }, end() { return this.edge.l === this.site ? this.edge.b : this.edge.a; } }, tu.prototype = { insert(n, t) { let e; let r; let u; if (n) { if (t.P = n, t.N = n.N, n.N && (n.N.P = t), n.N = t, n.R) { for (n = n.R; n.L;)n = n.L; n.L = t; } else n.R = t; e = n; } else this._ ? (n = iu(this._), t.P = null, t.N = n, n.P = n.L = t, e = n) : (t.P = t.N = null, this._ = t, e = null); for (t.L = t.R = null, t.U = e, t.C = !0, n = t; e && e.C;)r = e.U, e === r.L ? (u = r.R, u && u.C ? (e.C = u.C = !1, r.C = !0, n = r) : (n === e.R && (ru(this, e), n = e, e = n.U), e.C = !1, r.C = !0, uu(this, r))) : (u = r.L, u && u.C ? (e.C = u.C = !1, r.C = !0, n = r) : (n === e.L && (uu(this, e), n = e, e = n.U), e.C = !1, r.C = !0, ru(this, r))), e = n.U; this._.C = !1; }, remove(n) { n.N && (n.N.P = n.P), n.P && (n.P.N = n.N), n.N = n.P = null; let t; let e; let r; let u = n.U; const i = n.L; const o = n.R; if (e = i ? o ? iu(o) : i : o, u ? u.L === n ? u.L = e : u.R = e : this._ = e, i && o ? (r = e.C, e.C = n.C, e.L = i, i.U = e, e !== o ? (u = e.U, e.U = n.U, n = e.R, u.L = n, e.R = o, o.U = e) : (e.U = u, u = e, n = e.R)) : (r = n.C, n = e), n && (n.U = u), !r) { if (n && n.C) return n.C = !1, void 0; do { if (n === this._) break; if (n === u.L) { if (t = u.R, t.C && (t.C = !1, u.C = !0, ru(this, u), t = u.R), t.L && t.L.C || t.R && t.R.C) { t.R && t.R.C || (t.L.C = !1, t.C = !0, uu(this, t), t = u.R), t.C = u.C, u.C = t.R.C = !1, ru(this, u), n = this._; break; } } else if (t = u.L, t.C && (t.C = !1, u.C = !0, uu(this, u), t = u.L), t.L && t.L.C || t.R && t.R.C) { t.L && t.L.C || (t.R.C = !1, t.C = !0, ru(this, t), t = u.L), t.C = u.C, u.C = t.L.C = !1, uu(this, u), n = this._; break; }t.C = !0, n = u, u = u.U; } while (!n.C); n && (n.C = !1); } } }, ta.geom.voronoi = function (n) { function t(n) { const t = new Array(n.length); const r = a[0][0]; const u = a[0][1]; const i = a[1][0]; const o = a[1][1]; return ou(e(n), a).cells.forEach((e, a) => { const c = e.edges; const l = e.site; const s = t[a] = c.length ? c.map((n) => { const t = n.start(); return [t.x, t.y]; }) : l.x >= r && l.x <= i && l.y >= u && l.y <= o ? [[r, o], [i, o], [i, u], [r, u]] : []; s.point = n[a]; }), t; } function e(n) { return n.map((n, t) => ({ x: Math.round(i(n, t) / Ta) * Ta, y: Math.round(o(n, t) / Ta) * Ta, i: t })); } let r = Nr; let u = Cr; var i = r; var o = u; var a = cl; return n ? t(n) : (t.links = function (n) { return ou(e(n)).edges.filter((n) => n.l && n.r).map((t) => ({ source: n[t.l.i], target: n[t.r.i] })); }, t.triangles = function (n) { const t = []; return ou(e(n)).cells.forEach((e, r) => { for (var u, i, o = e.site, a = e.edges.sort(Zr), c = -1, l = a.length, s = a[l - 1].edge, f = s.l === o ? s.r : s.l; ++c < l;)u = s, i = f, s = a[c].edge, f = s.l === o ? s.r : s.l, r < i.i && r < f.i && cu(o, i, f) < 0 && t.push([n[r], n[i.i], n[f.i]]); }), t; }, t.x = function (n) { return arguments.length ? (i = Et(r = n), t) : r; }, t.y = function (n) { return arguments.length ? (o = Et(u = n), t) : u; }, t.clipExtent = function (n) { return arguments.length ? (a = n == null ? cl : n, t) : a === cl ? null : a; }, t.size = function (n) { return arguments.length ? t.clipExtent(n && [[0, 0], n]) : a === cl ? null : a && a[1]; }, t); }; var cl = [[-1e6, -1e6], [1e6, 1e6]]; ta.geom.delaunay = function (n) { return ta.geom.voronoi().triangles(n); }, ta.geom.quadtree = function (n, t, e, r, u) { function i(n) { function i(n, t, e, r, u, i, o, a) { if (!isNaN(e) && !isNaN(r)) if (n.leaf) { const c = n.x; const s = n.y; if (c != null) if (va(c - e) + va(s - r) < 0.01)l(n, t, e, r, u, i, o, a); else { const f = n.point; n.x = n.y = n.point = null, l(n, f, c, s, u, i, o, a), l(n, t, e, r, u, i, o, a); } else n.x = e, n.y = r, n.point = t; } else l(n, t, e, r, u, i, o, a); } function l(n, t, e, r, u, o, a, c) { const l = 0.5 * (u + a); const s = 0.5 * (o + c); const f = e >= l; const h = r >= s; const g = h << 1 | f; n.leaf = !1, n = n.nodes[g] || (n.nodes[g] = fu()), f ? u = l : a = l, h ? o = s : c = s, i(n, t, e, r, u, o, a, c); } let s; let f; let h; let g; let p; let v; let d; let m; let y; const M = Et(a); const x = Et(c); if (t != null)v = t, d = e, m = r, y = u; else if (m = y = -(v = d = 1 / 0), f = [], h = [], p = n.length, o) for (g = 0; p > g; ++g)s = n[g], s.x < v && (v = s.x), s.y < d && (d = s.y), s.x > m && (m = s.x), s.y > y && (y = s.y), f.push(s.x), h.push(s.y); else for (g = 0; p > g; ++g) { const b = +M(s = n[g], g); const _ = +x(s, g); v > b && (v = b), d > _ && (d = _), b > m && (m = b), _ > y && (y = _), f.push(b), h.push(_); } const w = m - v; const S = y - d; w > S ? y = d + w : m = v + S; const k = fu(); if (k.add = function (n) { i(k, n, +M(n, ++g), +x(n, g), v, d, m, y); }, k.visit = function (n) { hu(n, k, v, d, m, y); }, k.find = function (n) { return gu(k, n[0], n[1], v, d, m, y); }, g = -1, t == null) { for (;++g < p;)i(k, n[g], f[g], h[g], v, d, m, y); --g; } else n.forEach(k.add); return f = h = n = s = null, k; } let o; var a = Nr; var c = Cr; return (o = arguments.length) ? (a = lu, c = su, o === 3 && (u = e, r = t, e = t = 0), i(n)) : (i.x = function (n) { return arguments.length ? (a = n, i) : a; }, i.y = function (n) { return arguments.length ? (c = n, i) : c; }, i.extent = function (n) { return arguments.length ? (n == null ? t = e = r = u = null : (t = +n[0][0], e = +n[0][1], r = +n[1][0], u = +n[1][1]), i) : t == null ? null : [[t, e], [r, u]]; }, i.size = function (n) { return arguments.length ? (n == null ? t = e = r = u = null : (t = e = 0, r = +n[0], u = +n[1]), i) : t == null ? null : [r - t, u - e]; }, i); }, ta.interpolateRgb = pu, ta.interpolateObject = vu, ta.interpolateNumber = du, ta.interpolateString = mu; var ll = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g; var sl = new RegExp(ll.source, 'g'); ta.interpolate = yu, ta.interpolators = [function (n, t) { const e = typeof t; return (e === 'string' ? tc.has(t) || /^(#|rgb\(|hsl\()/.test(t) ? pu : mu : t instanceof ot ? pu : Array.isArray(t) ? Mu : e === 'object' && isNaN(t) ? vu : du)(n, t); }], ta.interpolateArray = Mu; const fl = function () { return At; }; const hl = ta.map({
    linear: fl, poly: Eu, quad() { return wu; }, cubic() { return Su; }, sin() { return Au; }, exp() { return Nu; }, circle() { return Cu; }, elastic: zu, back: qu, bounce() { return Lu; },
  }); const gl = ta.map({
    'in': At, out: bu, 'in-out': _u, 'out-in': function (n) { return _u(bu(n)); },
  }); ta.ease = function (n) { const t = n.indexOf('-'); let e = t >= 0 ? n.slice(0, t) : n; let r = t >= 0 ? n.slice(t + 1) : 'in'; return e = hl.get(e) || fl, r = gl.get(r) || At, xu(r(e.apply(null, ea.call(arguments, 1)))); }, ta.interpolateHcl = Tu, ta.interpolateHsl = Ru, ta.interpolateLab = Du, ta.interpolateRound = Pu, ta.transform = function (n) { const t = ua.createElementNS(ta.ns.prefix.svg, 'g'); return (ta.transform = function (n) { if (n != null) { t.setAttribute('transform', n); var e = t.transform.baseVal.consolidate(); } return new Uu(e ? e.matrix : pl); })(n); }, Uu.prototype.toString = function () { return `translate(${this.translate})rotate(${this.rotate})skewX(${this.skew})scale(${this.scale})`; }; var pl = {
    a: 1, b: 0, c: 0, d: 1, e: 0, f: 0,
  }; ta.interpolateTransform = Ou, ta.layout = {}, ta.layout.bundle = function () { return function (n) { for (var t = [], e = -1, r = n.length; ++e < r;)t.push(Zu(n[e])); return t; }; }, ta.layout.chord = function () {
    function n() {
      let n; let l; let f; let h; let g; const p = {}; const v = []; const d = ta.range(i); const m = []; for (e = [], r = [], n = 0, h = -1; ++h < i;) { for (l = 0, g = -1; ++g < i;)l += u[h][g]; v.push(l), m.push(ta.range(i)), n += l; } for (o && d.sort((n, t) => o(v[n], v[t])), a && m.forEach((n, t) => { n.sort((n, e) => a(u[t][n], u[t][e])); }), n = (Pa - s * i) / n, l = 0, h = -1; ++h < i;) {
        for (f = l, g = -1; ++g < i;) {
          var y = d[h]; const M = m[y][g]; const x = u[y][M]; const b = l; const _ = l += x * n; p[`${y}-${M}`] = {
            index: y, subindex: M, startAngle: b, endAngle: _, value: x,
          };
        }r[y] = {
          index: y, startAngle: f, endAngle: l, value: (l - f) / n,
        }, l += s;
      } for (h = -1; ++h < i;) for (g = h - 1; ++g < i;) { const w = p[`${h}-${g}`]; const S = p[`${g}-${h}`]; (w.value || S.value) && e.push(w.value < S.value ? { source: S, target: w } : { source: w, target: S }); }c && t();
    } function t() { e.sort((n, t) => c((n.source.value + n.target.value) / 2, (t.source.value + t.target.value) / 2)); } let e; let r; let u; let i; let o; let a; let c; const l = {}; var s = 0; return l.matrix = function (n) { return arguments.length ? (i = (u = n) && u.length, e = r = null, l) : u; }, l.padding = function (n) { return arguments.length ? (s = n, e = r = null, l) : s; }, l.sortGroups = function (n) { return arguments.length ? (o = n, e = r = null, l) : o; }, l.sortSubgroups = function (n) { return arguments.length ? (a = n, e = null, l) : a; }, l.sortChords = function (n) { return arguments.length ? (c = n, e && t(), l) : c; }, l.chords = function () { return e || n(), e; }, l.groups = function () { return r || n(), r; }, l;
  }, ta.layout.force = function () {
    function n(n) { return function (t, e, r, u) { if (t.point !== n) { const i = t.cx - n.x; const o = t.cy - n.y; const a = u - e; const c = i * i + o * o; if (c > a * a / d) { if (p > c) { var l = t.charge / c; n.px -= i * l, n.py -= o * l; } return !0; } if (t.point && c && p > c) { var l = t.pointCharge / c; n.px -= i * l, n.py -= o * l; } } return !t.charge; }; } function t(n) { n.px = ta.event.x, n.py = ta.event.y, a.resume(); } let e; let r; let u; let i; let o; var a = {}; const c = ta.dispatch('start', 'tick', 'end'); let l = [1, 1]; let s = 0.9; let f = vl; let h = dl; let g = -30; var p = ml; let v = 0.1; var d = 0.64; let m = []; let y = []; return a.tick = function () { if ((r *= 0.99) < 0.005) return c.end({ type: 'end', alpha: r = 0 }), !0; let t; let e; let a; let f; let h; let p; let d; let M; let x; const b = m.length; const _ = y.length; for (e = 0; _ > e; ++e)a = y[e], f = a.source, h = a.target, M = h.x - f.x, x = h.y - f.y, (p = M * M + x * x) && (p = r * i[e] * ((p = Math.sqrt(p)) - u[e]) / p, M *= p, x *= p, h.x -= M * (d = f.weight / (h.weight + f.weight)), h.y -= x * d, f.x += M * (d = 1 - d), f.y += x * d); if ((d = r * v) && (M = l[0] / 2, x = l[1] / 2, e = -1, d)) for (;++e < b;)a = m[e], a.x += (M - a.x) * d, a.y += (x - a.y) * d; if (g) for (Gu(t = ta.geom.quadtree(m), r, o), e = -1; ++e < b;)(a = m[e]).fixed || t.visit(n(a)); for (e = -1; ++e < b;)a = m[e], a.fixed ? (a.x = a.px, a.y = a.py) : (a.x -= (a.px - (a.px = a.x)) * s, a.y -= (a.py - (a.py = a.y)) * s); c.tick({ type: 'tick', alpha: r }); }, a.nodes = function (n) { return arguments.length ? (m = n, a) : m; }, a.links = function (n) { return arguments.length ? (y = n, a) : y; }, a.size = function (n) { return arguments.length ? (l = n, a) : l; }, a.linkDistance = function (n) { return arguments.length ? (f = typeof n === 'function' ? n : +n, a) : f; }, a.distance = a.linkDistance, a.linkStrength = function (n) { return arguments.length ? (h = typeof n === 'function' ? n : +n, a) : h; }, a.friction = function (n) { return arguments.length ? (s = +n, a) : s; }, a.charge = function (n) { return arguments.length ? (g = typeof n === 'function' ? n : +n, a) : g; }, a.chargeDistance = function (n) { return arguments.length ? (p = n * n, a) : Math.sqrt(p); }, a.gravity = function (n) { return arguments.length ? (v = +n, a) : v; }, a.theta = function (n) { return arguments.length ? (d = n * n, a) : Math.sqrt(d); }, a.alpha = function (n) { return arguments.length ? (n = +n, r ? r = n > 0 ? n : 0 : n > 0 && (c.start({ type: 'start', alpha: r = n }), ta.timer(a.tick)), a) : r; }, a.start = function () { function n(n, r) { if (!e) { for (e = new Array(c), a = 0; c > a; ++a)e[a] = []; for (a = 0; l > a; ++a) { const u = y[a]; e[u.source.index].push(u.target), e[u.target.index].push(u.source); } } for (var i, o = e[t], a = -1, l = o.length; ++a < l;) if (!isNaN(i = o[a][n])) return i; return Math.random() * r; } let t; let e; let r; var c = m.length; const s = y.length; const p = l[0]; const v = l[1]; for (t = 0; c > t; ++t)(r = m[t]).index = t, r.weight = 0; for (t = 0; s > t; ++t)r = y[t], typeof r.source === 'number' && (r.source = m[r.source]), typeof r.target === 'number' && (r.target = m[r.target]), ++r.source.weight, ++r.target.weight; for (t = 0; c > t; ++t)r = m[t], isNaN(r.x) && (r.x = n('x', p)), isNaN(r.y) && (r.y = n('y', v)), isNaN(r.px) && (r.px = r.x), isNaN(r.py) && (r.py = r.y); if (u = [], typeof f === 'function') for (t = 0; s > t; ++t)u[t] = +f.call(this, y[t], t); else for (t = 0; s > t; ++t)u[t] = f; if (i = [], typeof h === 'function') for (t = 0; s > t; ++t)i[t] = +h.call(this, y[t], t); else for (t = 0; s > t; ++t)i[t] = h; if (o = [], typeof g === 'function') for (t = 0; c > t; ++t)o[t] = +g.call(this, m[t], t); else for (t = 0; c > t; ++t)o[t] = g; return a.resume(); }, a.resume = function () { return a.alpha(0.1); }, a.stop = function () { return a.alpha(0); }, a.drag = function () {
      return e || (e = ta.behavior.drag().origin(At).on('dragstart.force', $u).on('drag.force', t)
        .on('dragend.force', Bu)), arguments.length ? (this.on('mouseover.force', Wu).on('mouseout.force', Ju).call(e), void 0) : e;
    }, ta.rebind(a, c, 'on');
  }; var vl = 20; var dl = 1; var ml = 1 / 0; ta.layout.hierarchy = function () { function n(u) { let i; const o = [u]; const a = []; for (u.depth = 0; (i = o.pop()) != null;) if (a.push(i), (l = e.call(n, i, i.depth)) && (c = l.length)) { for (var c, l, s; --c >= 0;)o.push(s = l[c]), s.parent = i, s.depth = i.depth + 1; r && (i.value = 0), i.children = l; } else r && (i.value = +r.call(n, i, i.depth) || 0), delete i.children; return ni(u, (n) => { let e; let u; t && (e = n.children) && e.sort(t), r && (u = n.parent) && (u.value += n.value); }), a; } var t = ri; var e = ti; var r = ei; return n.sort = function (e) { return arguments.length ? (t = e, n) : t; }, n.children = function (t) { return arguments.length ? (e = t, n) : e; }, n.value = function (t) { return arguments.length ? (r = t, n) : r; }, n.revalue = function (t) { return r && (Qu(t, (n) => { n.children && (n.value = 0); }), ni(t, (t) => { let e; t.children || (t.value = +r.call(n, t, t.depth) || 0), (e = t.parent) && (e.value += t.value); })), t; }, n; }, ta.layout.partition = function () { function n(t, e, r, u) { const i = t.children; if (t.x = e, t.y = t.depth * u, t.dx = r, t.dy = u, i && (o = i.length)) { var o; let a; let c; let l = -1; for (r = t.value ? r / t.value : 0; ++l < o;)n(a = i[l], e, c = a.value * r, u), e += c; } } function t(n) { const e = n.children; let r = 0; if (e && (u = e.length)) for (var u, i = -1; ++i < u;)r = Math.max(r, t(e[i])); return 1 + r; } function e(e, i) { const o = r.call(this, e, i); return n(o[0], 0, u[0], u[1] / t(o[0])), o; } var r = ta.layout.hierarchy(); var u = [1, 1]; return e.size = function (n) { return arguments.length ? (u = n, e) : u; }, Ku(e, r); }, ta.layout.pie = function () {
    function n(o) {
      let a; const c = o.length; const l = o.map((e, r) => +t.call(n, e, r)); let s = +(typeof r === 'function' ? r.apply(this, arguments) : r); const f = (typeof u === 'function' ? u.apply(this, arguments) : u) - s; const h = Math.min(Math.abs(f) / c, +(typeof i === 'function' ? i.apply(this, arguments) : i)); const g = h * (f < 0 ? -1 : 1); const p = (f - c * g) / ta.sum(l); const v = ta.range(c); const d = []; return e != null && v.sort(e === yl ? (n, t) => l[t] - l[n] : (n, t) => e(o[n], o[t])), v.forEach((n) => {
        d[n] = {
          data: o[n], value: a = l[n], startAngle: s, endAngle: s += a * p + g, padAngle: h,
        };
      }), d;
    } var t = Number; var e = yl; var r = 0; var u = Pa; var i = 0; return n.value = function (e) { return arguments.length ? (t = e, n) : t; }, n.sort = function (t) { return arguments.length ? (e = t, n) : e; }, n.startAngle = function (t) { return arguments.length ? (r = t, n) : r; }, n.endAngle = function (t) { return arguments.length ? (u = t, n) : u; }, n.padAngle = function (t) { return arguments.length ? (i = t, n) : i; }, n;
  }; var yl = {}; ta.layout.stack = function () { function n(a, c) { if (!(h = a.length)) return a; let l = a.map((e, r) => t.call(n, e, r)); let s = l.map((t) => t.map((t, e) => [i.call(n, t, e), o.call(n, t, e)])); const f = e.call(n, s, c); l = ta.permute(l, f), s = ta.permute(s, f); let h; let g; let p; let v; const d = r.call(n, s, c); const m = l[0].length; for (p = 0; m > p; ++p) for (u.call(n, l[0][p], v = d[p], s[0][p][1]), g = 1; h > g; ++g)u.call(n, l[g][p], v += s[g - 1][p][1], s[g][p][1]); return a; } var t = At; var e = ci; var r = li; var u = ai; var i = ii; var o = oi; return n.values = function (e) { return arguments.length ? (t = e, n) : t; }, n.order = function (t) { return arguments.length ? (e = typeof t === 'function' ? t : Ml.get(t) || ci, n) : e; }, n.offset = function (t) { return arguments.length ? (r = typeof t === 'function' ? t : xl.get(t) || li, n) : r; }, n.x = function (t) { return arguments.length ? (i = t, n) : i; }, n.y = function (t) { return arguments.length ? (o = t, n) : o; }, n.out = function (t) { return arguments.length ? (u = t, n) : u; }, n; }; var Ml = ta.map({ 'inside-out': function (n) { let t; let e; const r = n.length; const u = n.map(si); const i = n.map(fi); const o = ta.range(r).sort((n, t) => u[n] - u[t]); let a = 0; let c = 0; const l = []; const s = []; for (t = 0; r > t; ++t)e = o[t], c > a ? (a += i[e], l.push(e)) : (c += i[e], s.push(e)); return s.reverse().concat(l); }, reverse(n) { return ta.range(n.length).reverse(); }, 'default': ci }); var xl = ta.map({
    silhouette(n) { let t; let e; let r; const u = n.length; const i = n[0].length; const o = []; let a = 0; const c = []; for (e = 0; i > e; ++e) { for (t = 0, r = 0; u > t; t++)r += n[t][e][1]; r > a && (a = r), o.push(r); } for (e = 0; i > e; ++e)c[e] = (a - o[e]) / 2; return c; }, wiggle(n) { let t; let e; let r; let u; let i; let o; let a; let c; let l; const s = n.length; const f = n[0]; const h = f.length; const g = []; for (g[0] = c = l = 0, e = 1; h > e; ++e) { for (t = 0, u = 0; s > t; ++t)u += n[t][e][1]; for (t = 0, i = 0, a = f[e][0] - f[e - 1][0]; s > t; ++t) { for (r = 0, o = (n[t][e][1] - n[t][e - 1][1]) / (2 * a); t > r; ++r)o += (n[r][e][1] - n[r][e - 1][1]) / a; i += o * n[t][e][1]; }g[e] = c -= u ? i / u * a : 0, l > c && (l = c); } for (e = 0; h > e; ++e)g[e] -= l; return g; }, expand(n) { let t; let e; let r; const u = n.length; const i = n[0].length; const o = 1 / u; const a = []; for (e = 0; i > e; ++e) { for (t = 0, r = 0; u > t; t++)r += n[t][e][1]; if (r) for (t = 0; u > t; t++)n[t][e][1] /= r; else for (t = 0; u > t; t++)n[t][e][1] = o; } for (e = 0; i > e; ++e)a[e] = 0; return a; }, zero: li,
  }); ta.layout.histogram = function () { function n(n, i) { for (var o, a, c = [], l = n.map(e, this), s = r.call(this, l, i), f = u.call(this, s, l, i), i = -1, h = l.length, g = f.length - 1, p = t ? 1 : 1 / h; ++i < g;)o = c[i] = [], o.dx = f[i + 1] - (o.x = f[i]), o.y = 0; if (g > 0) for (i = -1; ++i < h;)a = l[i], a >= s[0] && a <= s[1] && (o = c[ta.bisect(f, a, 1, g) - 1], o.y += p, o.push(n[i])); return c; } var t = !0; var e = Number; var r = vi; var u = gi; return n.value = function (t) { return arguments.length ? (e = t, n) : e; }, n.range = function (t) { return arguments.length ? (r = Et(t), n) : r; }, n.bins = function (t) { return arguments.length ? (u = typeof t === 'number' ? function (n) { return pi(n, t); } : Et(t), n) : u; }, n.frequency = function (e) { return arguments.length ? (t = !!e, n) : t; }, n; }, ta.layout.pack = function () { function n(n, i) { const o = e.call(this, n, i); const a = o[0]; const c = u[0]; const l = u[1]; const s = t == null ? Math.sqrt : typeof t === 'function' ? t : function () { return t; }; if (a.x = a.y = 0, ni(a, (n) => { n.r = +s(n.value); }), ni(a, xi), r) { const f = r * (t ? 1 : Math.max(2 * a.r / c, 2 * a.r / l)) / 2; ni(a, (n) => { n.r += f; }), ni(a, xi), ni(a, (n) => { n.r -= f; }); } return wi(a, c / 2, l / 2, t ? 1 : 1 / Math.max(2 * a.r / c, 2 * a.r / l)), o; } let t; var e = ta.layout.hierarchy().sort(di); var r = 0; var u = [1, 1]; return n.size = function (t) { return arguments.length ? (u = t, n) : u; }, n.radius = function (e) { return arguments.length ? (t = e == null || typeof e === 'function' ? e : +e, n) : t; }, n.padding = function (t) { return arguments.length ? (r = +t, n) : r; }, Ku(n, e); }, ta.layout.tree = function () {
    function n(n, u) { const s = o.call(this, n, u); const f = s[0]; const h = t(f); if (ni(h, e), h.parent.m = -h.z, Qu(h, r), l)Qu(f, i); else { let g = f; let p = f; let v = f; Qu(f, (n) => { n.x < g.x && (g = n), n.x > p.x && (p = n), n.depth > v.depth && (v = n); }); const d = a(g, p) / 2 - g.x; const m = c[0] / (p.x + a(p, g) / 2 + d); const y = c[1] / (v.depth || 1); Qu(f, (n) => { n.x = (n.x + d) * m, n.y = n.depth * y; }); } return s; } function t(n) {
      for (var t, e = { A: null, children: [n] }, r = [e]; (t = r.pop()) != null;) {
        for (var u, i = t.children, o = 0, a = i.length; a > o; ++o) {
          r.push((i[o] = u = {
            _: i[o], parent: t, children: (u = i[o].children) && u.slice() || [], A: null, a: null, z: 0, m: 0, c: 0, s: 0, t: null, i: o,
          }).a = u);
        }
      } return e.children[0];
    } function e(n) { const t = n.children; const e = n.parent.children; const r = n.i ? e[n.i - 1] : null; if (t.length) { Ci(n); const i = (t[0].z + t[t.length - 1].z) / 2; r ? (n.z = r.z + a(n._, r._), n.m = n.z - i) : n.z = i; } else r && (n.z = r.z + a(n._, r._)); n.parent.A = u(n, r, n.parent.A || e[0]); } function r(n) { n._.x = n.z + n.parent.m, n.m += n.parent.m; } function u(n, t, e) { if (t) { for (var r, u = n, i = n, o = t, c = u.parent.children[0], l = u.m, s = i.m, f = o.m, h = c.m; o = Ai(o), u = Ei(u), o && u;)c = Ei(c), i = Ai(i), i.a = n, r = o.z + f - u.z - l + a(o._, u._), r > 0 && (Ni(zi(o, n, e), n, r), l += r, s += r), f += o.m, l += u.m, h += c.m, s += i.m; o && !Ai(i) && (i.t = o, i.m += f - s), u && !Ei(c) && (c.t = u, c.m += l - h, e = n); } return e; } function i(n) { n.x *= c[0], n.y = n.depth * c[1]; } var o = ta.layout.hierarchy().sort(null).value(null); var a = ki; var c = [1, 1]; var l = null; return n.separation = function (t) { return arguments.length ? (a = t, n) : a; }, n.size = function (t) { return arguments.length ? (l = (c = t) == null ? i : null, n) : l ? null : c; }, n.nodeSize = function (t) { return arguments.length ? (l = (c = t) == null ? null : i, n) : l ? c : null; }, Ku(n, o);
  }, ta.layout.cluster = function () { function n(n, i) { let o; const a = t.call(this, n, i); const c = a[0]; let l = 0; ni(c, (n) => { const t = n.children; t && t.length ? (n.x = Li(t), n.y = qi(t)) : (n.x = o ? l += e(n, o) : 0, n.y = 0, o = n); }); const s = Ti(c); const f = Ri(c); const h = s.x - e(s, f) / 2; const g = f.x + e(f, s) / 2; return ni(c, u ? (n) => { n.x = (n.x - c.x) * r[0], n.y = (c.y - n.y) * r[1]; } : (n) => { n.x = (n.x - h) / (g - h) * r[0], n.y = (1 - (c.y ? n.y / c.y : 1)) * r[1]; }), a; } var t = ta.layout.hierarchy().sort(null).value(null); var e = ki; var r = [1, 1]; var u = !1; return n.separation = function (t) { return arguments.length ? (e = t, n) : e; }, n.size = function (t) { return arguments.length ? (u = (r = t) == null, n) : u ? null : r; }, n.nodeSize = function (t) { return arguments.length ? (u = (r = t) != null, n) : u ? r : null; }, Ku(n, t); }, ta.layout.treemap = function () { function n(n, t) { for (var e, r, u = -1, i = n.length; ++u < i;)r = (e = n[u]).value * (t < 0 ? 0 : t), e.area = isNaN(r) || r <= 0 ? 0 : r; } function t(e) { const i = e.children; if (i && i.length) { let o; let a; let c; const l = f(e); const s = []; const h = i.slice(); let p = 1 / 0; let v = g === 'slice' ? l.dx : g === 'dice' ? l.dy : g === 'slice-dice' ? 1 & e.depth ? l.dy : l.dx : Math.min(l.dx, l.dy); for (n(h, l.dx * l.dy / e.value), s.area = 0; (c = h.length) > 0;)s.push(o = h[c - 1]), s.area += o.area, g !== 'squarify' || (a = r(s, v)) <= p ? (h.pop(), p = a) : (s.area -= s.pop().area, u(s, v, l, !1), v = Math.min(l.dx, l.dy), s.length = s.area = 0, p = 1 / 0); s.length && (u(s, v, l, !0), s.length = s.area = 0), i.forEach(t); } } function e(t) { const r = t.children; if (r && r.length) { let i; const o = f(t); const a = r.slice(); const c = []; for (n(a, o.dx * o.dy / t.value), c.area = 0; i = a.pop();)c.push(i), c.area += i.area, i.z != null && (u(c, i.z ? o.dx : o.dy, o, !a.length), c.length = c.area = 0); r.forEach(e); } } function r(n, t) { for (var e, r = n.area, u = 0, i = 1 / 0, o = -1, a = n.length; ++o < a;)(e = n[o].area) && (i > e && (i = e), e > u && (u = e)); return r *= r, t *= t, r ? Math.max(t * u * p / r, r / (t * i * p)) : 1 / 0; } function u(n, t, e, r) { let u; let i = -1; const o = n.length; let a = e.x; let l = e.y; let s = t ? c(n.area / t) : 0; if (t == e.dx) { for ((r || s > e.dy) && (s = e.dy); ++i < o;)u = n[i], u.x = a, u.y = l, u.dy = s, a += u.dx = Math.min(e.x + e.dx - a, s ? c(u.area / s) : 0); u.z = !0, u.dx += e.x + e.dx - a, e.y += s, e.dy -= s; } else { for ((r || s > e.dx) && (s = e.dx); ++i < o;)u = n[i], u.x = a, u.y = l, u.dx = s, l += u.dy = Math.min(e.y + e.dy - l, s ? c(u.area / s) : 0); u.z = !1, u.dy += e.y + e.dy - l, e.x += s, e.dx -= s; } } function i(r) { const u = o || a(r); const i = u[0]; return i.x = 0, i.y = 0, i.dx = l[0], i.dy = l[1], o && a.revalue(i), n([i], i.dx * i.dy / i.value), (o ? e : t)(i), h && (o = u), u; } let o; var a = ta.layout.hierarchy(); var c = Math.round; var l = [1, 1]; let s = null; var f = Di; var h = !1; var g = 'squarify'; var p = 0.5 * (1 + Math.sqrt(5)); return i.size = function (n) { return arguments.length ? (l = n, i) : l; }, i.padding = function (n) { function t(t) { const e = n.call(i, t, t.depth); return e == null ? Di(t) : Pi(t, typeof e === 'number' ? [e, e, e, e] : e); } function e(t) { return Pi(t, n); } if (!arguments.length) return s; let r; return f = (s = n) == null ? Di : (r = typeof n) == 'function' ? t : r === 'number' ? (n = [n, n, n, n], e) : e, i; }, i.round = function (n) { return arguments.length ? (c = n ? Math.round : Number, i) : c != Number; }, i.sticky = function (n) { return arguments.length ? (h = n, o = null, i) : h; }, i.ratio = function (n) { return arguments.length ? (p = n, i) : p; }, i.mode = function (n) { return arguments.length ? (g = `${n}`, i) : g; }, Ku(i, a); }, ta.random = {
    normal(n, t) {
      const e = arguments.length; return e < 2 && (t = 1), e < 1 && (n = 0), function () {
        let e; let r; let u;
        do e = 2 * Math.random() - 1, r = 2 * Math.random() - 1, u = e * e + r * r; while (!u || u > 1); return n + t * e * Math.sqrt(-2 * Math.log(u) / u);
      };
    },
    logNormal() { const n = ta.random.normal.apply(ta, arguments); return function () { return Math.exp(n()); }; },
    bates(n) { const t = ta.random.irwinHall(n); return function () { return t() / n; }; },
    irwinHall(n) { return function () { for (var t = 0, e = 0; n > e; e++)t += Math.random(); return t; }; },
  }, ta.scale = {}; var bl = { floor: At, ceil: At }; ta.scale.linear = function () { return Ii([0, 1], [0, 1], yu, !1); }; var _l = {
    s: 1, g: 1, p: 1, r: 1, e: 1,
  }; ta.scale.log = function () { return Gi(ta.scale.linear().domain([0, 1]), 10, !0, [1, 10]); }; var wl = ta.format('.0e'); var Sl = { floor(n) { return -Math.ceil(-n); }, ceil(n) { return -Math.floor(-n); } }; ta.scale.pow = function () { return Ki(ta.scale.linear(), 1, [0, 1]); }, ta.scale.sqrt = function () { return ta.scale.pow().exponent(0.5); }, ta.scale.ordinal = function () { return no([], { t: 'range', a: [[]] }); }, ta.scale.category10 = function () { return ta.scale.ordinal().range(kl); }, ta.scale.category20 = function () { return ta.scale.ordinal().range(El); }, ta.scale.category20b = function () { return ta.scale.ordinal().range(Al); }, ta.scale.category20c = function () { return ta.scale.ordinal().range(Nl); }; var kl = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(Mt); var El = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(Mt); var Al = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(Mt); var Nl = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(Mt); ta.scale.quantile = function () { return to([], []); }, ta.scale.quantize = function () { return eo(0, 1, [0, 1]); }, ta.scale.threshold = function () { return ro([0.5], [0, 1]); }, ta.scale.identity = function () { return uo([0, 1]); }, ta.svg = {}, ta.svg.arc = function () { function n() { let n = Math.max(0, +e.apply(this, arguments)); let l = Math.max(0, +r.apply(this, arguments)); const s = o.apply(this, arguments) - ja; const f = a.apply(this, arguments) - ja; const h = Math.abs(f - s); const g = s > f ? 0 : 1; if (n > l && (p = l, l = n, n = p), h >= Ua) return `${t(l, g) + (n ? t(n, 1 - g) : '')}Z`; let p; let v; let d; let m; let y; let M; let x; let b; let _; let w; let S; let k; let E = 0; let A = 0; const N = []; if ((m = (+c.apply(this, arguments) || 0) / 2) && (d = i === Cl ? Math.sqrt(n * n + l * l) : +i.apply(this, arguments), g || (A *= -1), l && (A = tt(d / l * Math.sin(m))), n && (E = tt(d / n * Math.sin(m)))), l) { y = l * Math.cos(s + A), M = l * Math.sin(s + A), x = l * Math.cos(f - A), b = l * Math.sin(f - A); var C = Math.abs(f - s - 2 * A) <= Da ? 0 : 1; if (A && fo(y, M, x, b) === g ^ C) { const z = (s + f) / 2; y = l * Math.cos(z), M = l * Math.sin(z), x = b = null; } } else y = M = 0; if (n) { _ = n * Math.cos(f - E), w = n * Math.sin(f - E), S = n * Math.cos(s + E), k = n * Math.sin(s + E); var q = Math.abs(s - f + 2 * E) <= Da ? 0 : 1; if (E && fo(_, w, S, k) === 1 - g ^ q) { const L = (s + f) / 2; _ = n * Math.cos(L), w = n * Math.sin(L), S = k = null; } } else _ = w = 0; if ((p = Math.min(Math.abs(l - n) / 2, +u.apply(this, arguments))) > 0.001) { v = l > n ^ g ? 0 : 1; const T = S == null ? [_, w] : x == null ? [y, M] : Tr([y, M], [S, k], [x, b], [_, w]); const R = y - T[0]; const D = M - T[1]; const P = x - T[0]; const U = b - T[1]; const j = 1 / Math.sin(Math.acos((R * P + D * U) / (Math.sqrt(R * R + D * D) * Math.sqrt(P * P + U * U))) / 2); const F = Math.sqrt(T[0] * T[0] + T[1] * T[1]); if (x != null) { const H = Math.min(p, (l - F) / (j + 1)); const O = ho(S == null ? [_, w] : [S, k], [y, M], l, H, g); const Y = ho([x, b], [_, w], l, H, g); p === H ? N.push('M', O[0], 'A', H, ',', H, ' 0 0,', v, ' ', O[1], 'A', l, ',', l, ' 0 ', 1 - g ^ fo(O[1][0], O[1][1], Y[1][0], Y[1][1]), ',', g, ' ', Y[1], 'A', H, ',', H, ' 0 0,', v, ' ', Y[0]) : N.push('M', O[0], 'A', H, ',', H, ' 0 1,', v, ' ', Y[0]); } else N.push('M', y, ',', M); if (S != null) { const I = Math.min(p, (n - F) / (j - 1)); const Z = ho([y, M], [S, k], n, -I, g); const V = ho([_, w], x == null ? [y, M] : [x, b], n, -I, g); p === I ? N.push('L', V[0], 'A', I, ',', I, ' 0 0,', v, ' ', V[1], 'A', n, ',', n, ' 0 ', g ^ fo(V[1][0], V[1][1], Z[1][0], Z[1][1]), ',', 1 - g, ' ', Z[1], 'A', I, ',', I, ' 0 0,', v, ' ', Z[0]) : N.push('L', V[0], 'A', I, ',', I, ' 0 0,', v, ' ', Z[0]); } else N.push('L', _, ',', w); } else N.push('M', y, ',', M), x != null && N.push('A', l, ',', l, ' 0 ', C, ',', g, ' ', x, ',', b), N.push('L', _, ',', w), S != null && N.push('A', n, ',', n, ' 0 ', q, ',', 1 - g, ' ', S, ',', k); return N.push('Z'), N.join(''); } function t(n, t) { return `M0,${n}A${n},${n} 0 1,${t} 0,${-n}A${n},${n} 0 1,${t} 0,${n}`; } var e = oo; var r = ao; var u = io; var i = Cl; var o = co; var a = lo; var c = so; return n.innerRadius = function (t) { return arguments.length ? (e = Et(t), n) : e; }, n.outerRadius = function (t) { return arguments.length ? (r = Et(t), n) : r; }, n.cornerRadius = function (t) { return arguments.length ? (u = Et(t), n) : u; }, n.padRadius = function (t) { return arguments.length ? (i = t == Cl ? Cl : Et(t), n) : i; }, n.startAngle = function (t) { return arguments.length ? (o = Et(t), n) : o; }, n.endAngle = function (t) { return arguments.length ? (a = Et(t), n) : a; }, n.padAngle = function (t) { return arguments.length ? (c = Et(t), n) : c; }, n.centroid = function () { const n = (+e.apply(this, arguments) + +r.apply(this, arguments)) / 2; const t = (+o.apply(this, arguments) + +a.apply(this, arguments)) / 2 - ja; return [Math.cos(t) * n, Math.sin(t) * n]; }, n; }; var Cl = 'auto'; ta.svg.line = function () { return go(At); }; var zl = ta.map({
    linear: po, 'linear-closed': vo, step: mo, 'step-before': yo, 'step-after': Mo, basis: ko, 'basis-open': Eo, 'basis-closed': Ao, bundle: No, cardinal: _o, 'cardinal-open': xo, 'cardinal-closed': bo, monotone: Ro,
  }); zl.forEach((n, t) => { t.key = n, t.closed = /-closed$/.test(n); }); var ql = [0, 2 / 3, 1 / 3, 0]; var Ll = [0, 1 / 3, 2 / 3, 0]; var Tl = [0, 1 / 6, 2 / 3, 1 / 6]; ta.svg.line.radial = function () { const n = go(Do); return n.radius = n.x, delete n.x, n.angle = n.y, delete n.y, n; }, yo.reverse = Mo, Mo.reverse = yo, ta.svg.area = function () { return Po(At); }, ta.svg.area.radial = function () { const n = Po(Do); return n.radius = n.x, delete n.x, n.innerRadius = n.x0, delete n.x0, n.outerRadius = n.x1, delete n.x1, n.angle = n.y, delete n.y, n.startAngle = n.y0, delete n.y0, n.endAngle = n.y1, delete n.y1, n; }, ta.svg.chord = function () {
    function n(n, a) { const c = t(this, i, n, a); const l = t(this, o, n, a); return `M${c.p0}${r(c.r, c.p1, c.a1 - c.a0)}${e(c, l) ? u(c.r, c.p1, c.r, c.p0) : u(c.r, c.p1, l.r, l.p0) + r(l.r, l.p1, l.a1 - l.a0) + u(l.r, l.p1, c.r, c.p0)}Z`; } function t(n, t, e, r) {
      const u = t.call(n, e, r); const i = a.call(n, u, r); const o = c.call(n, u, r) - ja; const s = l.call(n, u, r) - ja; return {
        r: i, a0: o, a1: s, p0: [i * Math.cos(o), i * Math.sin(o)], p1: [i * Math.cos(s), i * Math.sin(s)],
      };
    } function e(n, t) { return n.a0 == t.a0 && n.a1 == t.a1; } function r(n, t, e) { return `A${n},${n} 0 ${+(e > Da)},1 ${t}`; } function u(n, t, e, r) { return `Q 0,0 ${r}`; } var i = yr; var o = Mr; var a = Uo; var c = co; var l = lo; return n.radius = function (t) { return arguments.length ? (a = Et(t), n) : a; }, n.source = function (t) { return arguments.length ? (i = Et(t), n) : i; }, n.target = function (t) { return arguments.length ? (o = Et(t), n) : o; }, n.startAngle = function (t) { return arguments.length ? (c = Et(t), n) : c; }, n.endAngle = function (t) { return arguments.length ? (l = Et(t), n) : l; }, n;
  }, ta.svg.diagonal = function () { function n(n, u) { const i = t.call(this, n, u); const o = e.call(this, n, u); const a = (i.y + o.y) / 2; let c = [i, { x: i.x, y: a }, { x: o.x, y: a }, o]; return c = c.map(r), `M${c[0]}C${c[1]} ${c[2]} ${c[3]}`; } var t = yr; var e = Mr; var r = jo; return n.source = function (e) { return arguments.length ? (t = Et(e), n) : t; }, n.target = function (t) { return arguments.length ? (e = Et(t), n) : e; }, n.projection = function (t) { return arguments.length ? (r = t, n) : r; }, n; }, ta.svg.diagonal.radial = function () { const n = ta.svg.diagonal(); let t = jo; const e = n.projection; return n.projection = function (n) { return arguments.length ? e(Fo(t = n)) : t; }, n; }, ta.svg.symbol = function () { function n(n, r) { return (Rl.get(t.call(this, n, r)) || Yo)(e.call(this, n, r)); } var t = Oo; var e = Ho; return n.type = function (e) { return arguments.length ? (t = Et(e), n) : t; }, n.size = function (t) { return arguments.length ? (e = Et(t), n) : e; }, n; }; var Rl = ta.map({
    circle: Yo, cross(n) { const t = Math.sqrt(n / 5) / 2; return `M${-3 * t},${-t}H${-t}V${-3 * t}H${t}V${-t}H${3 * t}V${t}H${t}V${3 * t}H${-t}V${t}H${-3 * t}Z`; }, diamond(n) { const t = Math.sqrt(n / (2 * jl)); const e = t * jl; return `M0,${-t}L${e},0` + ` 0,${t} ${-e},0` + 'Z'; }, square(n) { const t = Math.sqrt(n) / 2; return `M${-t},${-t}L${t},${-t} ${t},${t} ${-t},${t}Z`; }, 'triangle-down': function (n) { const t = Math.sqrt(n / Ul); const e = t * Ul / 2; return `M0,${e}L${t},${-e} ${-t},${-e}Z`; }, 'triangle-up': function (n) { const t = Math.sqrt(n / Ul); const e = t * Ul / 2; return `M0,${-e}L${t},${e} ${-t},${e}Z`; },
  }); ta.svg.symbolTypes = Rl.keys(); let Dl; let Pl; var Ul = Math.sqrt(3); var jl = Math.tan(30 * Fa); var Fl = []; var Hl = 0; Fl.call = ka.call, Fl.empty = ka.empty, Fl.node = ka.node, Fl.size = ka.size, ta.transition = function (n) { return arguments.length ? Dl ? n.transition() : n : Na.transition(); }, ta.transition.prototype = Fl, Fl.select = function (n) { let t; let e; let r; const u = this.id; const i = this.namespace; const o = []; n = k(n); for (let a = -1, c = this.length; ++a < c;) { o.push(t = []); for (let l = this[a], s = -1, f = l.length; ++s < f;)(r = l[s]) && (e = n.call(r, r.__data__, s, a)) ? ('__data__' in r && (e.__data__ = r.__data__), $o(e, s, i, u, r[i][u]), t.push(e)) : t.push(null); } return Io(o, i, u); }, Fl.selectAll = function (n) { let t; let e; let r; let u; let i; const o = this.id; const a = this.namespace; const c = []; n = E(n); for (let l = -1, s = this.length; ++l < s;) for (let f = this[l], h = -1, g = f.length; ++h < g;) if (r = f[h]) { i = r[a][o], e = n.call(r, r.__data__, h, l), c.push(t = []); for (let p = -1, v = e.length; ++p < v;)(u = e[p]) && $o(u, p, a, o, i), t.push(u); } return Io(c, a, o); }, Fl.filter = function (n) { let t; var e; let r; const u = []; typeof n !== 'function' && (n = j(n)); for (let i = 0, o = this.length; o > i; i++) { u.push(t = []); for (var e = this[i], a = 0, c = e.length; c > a; a++)(r = e[a]) && n.call(r, r.__data__, a, i) && t.push(r); } return Io(u, this.namespace, this.id); }, Fl.tween = function (n, t) { const e = this.id; const r = this.namespace; return arguments.length < 2 ? this.node()[r][e].tween.get(n) : H(this, t == null ? (t) => { t[r][e].tween.remove(n); } : (u) => { u[r][e].tween.set(n, t); }); }, Fl.attr = function (n, t) { function e() { this.removeAttribute(a); } function r() { this.removeAttributeNS(a.space, a.local); } function u(n) { return n == null ? e : (n += '', function () { let t; const e = this.getAttribute(a); return e !== n && (t = o(e, n), function (n) { this.setAttribute(a, t(n)); }); }); } function i(n) { return n == null ? r : (n += '', function () { let t; const e = this.getAttributeNS(a.space, a.local); return e !== n && (t = o(e, n), function (n) { this.setAttributeNS(a.space, a.local, t(n)); }); }); } if (arguments.length < 2) { for (t in n) this.attr(t, n[t]); return this; } var o = n == 'transform' ? Ou : yu; var a = ta.ns.qualify(n); return Zo(this, `attr.${n}`, t, a.local ? i : u); }, Fl.attrTween = function (n, t) { function e(n, e) { const r = t.call(this, n, e, this.getAttribute(u)); return r && function (n) { this.setAttribute(u, r(n)); }; } function r(n, e) { const r = t.call(this, n, e, this.getAttributeNS(u.space, u.local)); return r && function (n) { this.setAttributeNS(u.space, u.local, r(n)); }; } var u = ta.ns.qualify(n); return this.tween(`attr.${n}`, u.local ? r : e); }, Fl.style = function (n, t, e) { function r() { this.style.removeProperty(n); } function u(t) { return t == null ? r : (t += '', function () { let r; const u = oa.getComputedStyle(this, null).getPropertyValue(n); return u !== t && (r = yu(u, t), function (t) { this.style.setProperty(n, r(t), e); }); }); } const i = arguments.length; if (i < 3) { if (typeof n !== 'string') { i < 2 && (t = ''); for (e in n) this.style(e, n[e], t); return this; }e = ''; } return Zo(this, `style.${n}`, t, u); }, Fl.styleTween = function (n, t, e) { function r(r, u) { const i = t.call(this, r, u, oa.getComputedStyle(this, null).getPropertyValue(n)); return i && function (t) { this.style.setProperty(n, i(t), e); }; } return arguments.length < 3 && (e = ''), this.tween(`style.${n}`, r); }, Fl.text = function (n) { return Zo(this, 'text', n, Vo); }, Fl.remove = function () { const n = this.namespace; return this.each('end.transition', function () { let t; this[n].count < 2 && (t = this.parentNode) && t.removeChild(this); }); }, Fl.ease = function (n) { const t = this.id; const e = this.namespace; return arguments.length < 1 ? this.node()[e][t].ease : (typeof n !== 'function' && (n = ta.ease.apply(ta, arguments)), H(this, (r) => { r[e][t].ease = n; })); }, Fl.delay = function (n) { const t = this.id; const e = this.namespace; return arguments.length < 1 ? this.node()[e][t].delay : H(this, typeof n === 'function' ? (r, u, i) => { r[e][t].delay = +n.call(r, r.__data__, u, i); } : (n = +n, function (r) { r[e][t].delay = n; })); }, Fl.duration = function (n) { const t = this.id; const e = this.namespace; return arguments.length < 1 ? this.node()[e][t].duration : H(this, typeof n === 'function' ? (r, u, i) => { r[e][t].duration = Math.max(1, n.call(r, r.__data__, u, i)); } : (n = Math.max(1, n), function (r) { r[e][t].duration = n; })); }, Fl.each = function (n, t) { const e = this.id; const r = this.namespace; if (arguments.length < 2) { const u = Pl; const i = Dl; Dl = e, H(this, (t, u, i) => { Pl = t[r][e], n.call(t, t.__data__, u, i); }), Pl = u, Dl = i; } else H(this, (u) => { const i = u[r][e]; (i.event || (i.event = ta.dispatch('start', 'end', 'interrupt'))).on(n, t); }); return this; }, Fl.transition = function () {
    for (var n, t, e, r, u = this.id, i = ++Hl, o = this.namespace, a = [], c = 0, l = this.length; l > c; c++) {
      a.push(n = []); for (var t = this[c], s = 0, f = t.length; f > s; s++) {
        (e = t[s]) && (r = e[o][u], $o(e, s, o, i, {
          time: r.time, ease: r.ease, delay: r.delay + r.duration, duration: r.duration,
        })), n.push(e);
      }
    } return Io(a, o, i);
  }, ta.svg.axis = function () { function n(n) { n.each(function () { let n; const l = ta.select(this); let s = this.__chart__ || e; let f = this.__chart__ = e.copy(); const h = c == null ? f.ticks ? f.ticks.apply(f, a) : f.domain() : c; const g = t == null ? f.tickFormat ? f.tickFormat.apply(f, a) : At : t; const p = l.selectAll('.tick').data(h, f); const v = p.enter().insert('g', '.domain').attr('class', 'tick').style('opacity', Ta); const d = ta.transition(p.exit()).style('opacity', Ta).remove(); const m = ta.transition(p.order()).style('opacity', 1); const y = Math.max(u, 0) + o; const M = ji(f); const x = l.selectAll('.domain').data([0]); const b = (x.enter().append('path').attr('class', 'domain'), ta.transition(x)); v.append('line'), v.append('text'); let _; let w; let S; let k; const E = v.select('line'); const A = m.select('line'); const N = p.select('text').text(g); const C = v.select('text'); const z = m.select('text'); const q = r === 'top' || r === 'left' ? -1 : 1; if (r === 'bottom' || r === 'top' ? (n = Bo, _ = 'x', S = 'y', w = 'x2', k = 'y2', N.attr('dy', q < 0 ? '0em' : '.71em').style('text-anchor', 'middle'), b.attr('d', `M${M[0]},${q * i}V0H${M[1]}V${q * i}`)) : (n = Wo, _ = 'y', S = 'x', w = 'y2', k = 'x2', N.attr('dy', '.32em').style('text-anchor', q < 0 ? 'end' : 'start'), b.attr('d', `M${q * i},${M[0]}H0V${M[1]}H${q * i}`)), E.attr(k, q * u), C.attr(S, q * y), A.attr(w, 0).attr(k, q * u), z.attr(_, 0).attr(S, q * y), f.rangeBand) { const L = f; const T = L.rangeBand() / 2; s = f = function (n) { return L(n) + T; }; } else s.rangeBand ? s = f : d.call(n, f, s); v.call(n, s, f), m.call(n, f, f); }); } let t; var e = ta.scale.linear(); var r = Ol; var u = 6; var i = 6; var o = 3; var a = [10]; var c = null; return n.scale = function (t) { return arguments.length ? (e = t, n) : e; }, n.orient = function (t) { return arguments.length ? (r = t in Yl ? `${t}` : Ol, n) : r; }, n.ticks = function () { return arguments.length ? (a = arguments, n) : a; }, n.tickValues = function (t) { return arguments.length ? (c = t, n) : c; }, n.tickFormat = function (e) { return arguments.length ? (t = e, n) : t; }, n.tickSize = function (t) { const e = arguments.length; return e ? (u = +t, i = +arguments[e - 1], n) : u; }, n.innerTickSize = function (t) { return arguments.length ? (u = +t, n) : u; }, n.outerTickSize = function (t) { return arguments.length ? (i = +t, n) : i; }, n.tickPadding = function (t) { return arguments.length ? (o = +t, n) : o; }, n.tickSubdivide = function () { return arguments.length && n; }, n; }; var Ol = 'bottom'; var Yl = {
    top: 1, right: 1, bottom: 1, left: 1,
  }; ta.svg.brush = function () {
    function n(i) {
      i.each(function () {
        const i = ta.select(this).style('pointer-events', 'all').style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)').on('mousedown.brush', u)
          .on('touchstart.brush', u); const o = i.selectAll('.background').data([0]); o.enter().append('rect').attr('class', 'background').style('visibility', 'hidden')
          .style('cursor', 'crosshair'), i.selectAll('.extent').data([0]).enter().append('rect')
          .attr('class', 'extent')
          .style('cursor', 'move'); const a = i.selectAll('.resize').data(p, At); a.exit().remove(), a.enter().append('g').attr('class', (n) => `resize ${n}`).style('cursor', (n) => Il[n])
          .append('rect')
          .attr('x', (n) => (/[ew]$/.test(n) ? -3 : null))
          .attr('y', (n) => (/^[ns]/.test(n) ? -3 : null))
          .attr('width', 6)
          .attr('height', 6)
          .style('visibility', 'hidden'), a.style('display', n.empty() ? 'none' : null); let s; const f = ta.transition(i); const h = ta.transition(o); c && (s = ji(c), h.attr('x', s[0]).attr('width', s[1] - s[0]), e(f)), l && (s = ji(l), h.attr('y', s[0]).attr('height', s[1] - s[0]), r(f)), t(f);
      });
    } function t(n) { n.selectAll('.resize').attr('transform', (n) => `translate(${s[+/e$/.test(n)]},${f[+/^s/.test(n)]})`); } function e(n) { n.select('.extent').attr('x', s[0]), n.selectAll('.extent,.n>rect,.s>rect').attr('width', s[1] - s[0]); } function r(n) { n.select('.extent').attr('y', f[0]), n.selectAll('.extent,.e>rect,.w>rect').attr('height', f[1] - f[0]); } function u() {
      function u() { ta.event.keyCode == 32 && (N || (y = null, z[0] -= s[1], z[1] -= f[1], N = 2), b()); } function p() { ta.event.keyCode == 32 && N == 2 && (z[0] += s[1], z[1] += f[1], N = 0, b()); } function v() { const n = ta.mouse(x); let u = !1; M && (n[0] += M[0], n[1] += M[1]), N || (ta.event.altKey ? (y || (y = [(s[0] + s[1]) / 2, (f[0] + f[1]) / 2]), z[0] = s[+(n[0] < y[0])], z[1] = f[+(n[1] < y[1])]) : y = null), E && d(n, c, 0) && (e(S), u = !0), A && d(n, l, 1) && (r(S), u = !0), u && (t(S), w({ type: 'brush', mode: N ? 'move' : 'resize' })); } function d(n, t, e) { let r; let u; const a = ji(t); let c = a[0]; let l = a[1]; let p = z[e]; const v = e ? f : s; const d = v[1] - v[0]; return N && (c -= p, l -= d + p), r = (e ? g : h) ? Math.max(c, Math.min(l, n[e])) : n[e], N ? u = (r += p) + d : (y && (p = Math.max(c, Math.min(l, 2 * y[e] - r))), r > p ? (u = r, r = p) : u = p), v[0] != r || v[1] != u ? (e ? o = null : i = null, v[0] = r, v[1] = u, !0) : void 0; } function m() {
        v(), S.style('pointer-events', 'all').selectAll('.resize').style('display', n.empty() ? 'none' : null), ta.select('body').style('cursor', null), q.on('mousemove.brush', null).on('mouseup.brush', null).on('touchmove.brush', null).on('touchend.brush', null)
          .on('keydown.brush', null)
          .on('keyup.brush', null), C(), w({ type: 'brushend' });
      } let y; let M; var x = this; const _ = ta.select(ta.event.target); var w = a.of(x, arguments); var S = ta.select(x); const k = _.datum(); var E = !/^(n|s)$/.test(k) && c; var A = !/^(e|w)$/.test(k) && l; var N = _.classed('extent'); var C = $(); var z = ta.mouse(x); var q = ta.select(oa).on('keydown.brush', u).on('keyup.brush', p); if (ta.event.changedTouches ? q.on('touchmove.brush', v).on('touchend.brush', m) : q.on('mousemove.brush', v).on('mouseup.brush', m), S.interrupt().selectAll('*').interrupt(), N)z[0] = s[0] - z[0], z[1] = f[0] - z[1]; else if (k) { const L = +/w$/.test(k); const T = +/^n/.test(k); M = [s[1 - L] - z[0], f[1 - T] - z[1]], z[0] = s[L], z[1] = f[T]; } else ta.event.altKey && (y = z.slice()); S.style('pointer-events', 'none').selectAll('.resize').style('display', null), ta.select('body').style('cursor', _.style('cursor')), w({ type: 'brushstart' }), v();
    } let i; let o; var a = w(n, 'brushstart', 'brush', 'brushend'); var c = null; var l = null; var s = [0, 0]; var f = [0, 0]; var h = !0; var g = !0; var p = Zl[0]; return n.event = function (n) {
      n.each(function () {
        const n = a.of(this, arguments); const t = {
          x: s, y: f, i, j: o,
        }; const e = this.__chart__ || t; this.__chart__ = t, Dl ? ta.select(this).transition().each('start.brush', () => { i = e.i, o = e.j, s = e.x, f = e.y, n({ type: 'brushstart' }); }).tween('brush:brush', () => { const e = Mu(s, t.x); const r = Mu(f, t.y); return i = o = null, function (u) { s = t.x = e(u), f = t.y = r(u), n({ type: 'brush', mode: 'resize' }); }; })
          .each('end.brush', () => { i = t.i, o = t.j, n({ type: 'brush', mode: 'resize' }), n({ type: 'brushend' }); }) : (n({ type: 'brushstart' }), n({ type: 'brush', mode: 'resize' }), n({ type: 'brushend' }));
      });
    }, n.x = function (t) { return arguments.length ? (c = t, p = Zl[!c << 1 | !l], n) : c; }, n.y = function (t) { return arguments.length ? (l = t, p = Zl[!c << 1 | !l], n) : l; }, n.clamp = function (t) { return arguments.length ? (c && l ? (h = !!t[0], g = !!t[1]) : c ? h = !!t : l && (g = !!t), n) : c && l ? [h, g] : c ? h : l ? g : null; }, n.extent = function (t) { let e; let r; let u; let a; let h; return arguments.length ? (c && (e = t[0], r = t[1], l && (e = e[0], r = r[0]), i = [e, r], c.invert && (e = c(e), r = c(r)), e > r && (h = e, e = r, r = h), (e != s[0] || r != s[1]) && (s = [e, r])), l && (u = t[0], a = t[1], c && (u = u[1], a = a[1]), o = [u, a], l.invert && (u = l(u), a = l(a)), u > a && (h = u, u = a, a = h), (u != f[0] || a != f[1]) && (f = [u, a])), n) : (c && (i ? (e = i[0], r = i[1]) : (e = s[0], r = s[1], c.invert && (e = c.invert(e), r = c.invert(r)), e > r && (h = e, e = r, r = h))), l && (o ? (u = o[0], a = o[1]) : (u = f[0], a = f[1], l.invert && (u = l.invert(u), a = l.invert(a)), u > a && (h = u, u = a, a = h))), c && l ? [[e, u], [r, a]] : c ? [e, r] : l && [u, a]); }, n.clear = function () { return n.empty() || (s = [0, 0], f = [0, 0], i = o = null), n; }, n.empty = function () { return !!c && s[0] == s[1] || !!l && f[0] == f[1]; }, ta.rebind(n, a, 'on');
  }; var Il = {
    n: 'ns-resize', e: 'ew-resize', s: 'ns-resize', w: 'ew-resize', nw: 'nwse-resize', ne: 'nesw-resize', se: 'nwse-resize', sw: 'nesw-resize',
  }; var Zl = [['n', 'e', 's', 'w', 'nw', 'ne', 'se', 'sw'], ['e', 'w'], ['n', 's'], []]; const Vl = fc.format = mc.timeFormat; const Xl = Vl.utc; const $l = Xl('%Y-%m-%dT%H:%M:%S.%LZ'); Vl.iso = Date.prototype.toISOString && +new Date('2000-01-01T00:00:00.000Z') ? Jo : $l, Jo.parse = function (n) { const t = new Date(n); return isNaN(t) ? null : t; }, Jo.toString = $l.toString, fc.second = Ht((n) => new hc(1e3 * Math.floor(n / 1e3)), (n, t) => { n.setTime(n.getTime() + 1e3 * Math.floor(t)); }, (n) => n.getSeconds()), fc.seconds = fc.second.range, fc.seconds.utc = fc.second.utc.range, fc.minute = Ht((n) => new hc(6e4 * Math.floor(n / 6e4)), (n, t) => { n.setTime(n.getTime() + 6e4 * Math.floor(t)); }, (n) => n.getMinutes()), fc.minutes = fc.minute.range, fc.minutes.utc = fc.minute.utc.range, fc.hour = Ht((n) => { const t = n.getTimezoneOffset() / 60; return new hc(36e5 * (Math.floor(n / 36e5 - t) + t)); }, (n, t) => { n.setTime(n.getTime() + 36e5 * Math.floor(t)); }, (n) => n.getHours()), fc.hours = fc.hour.range, fc.hours.utc = fc.hour.utc.range, fc.month = Ht((n) => (n = fc.day(n), n.setDate(1), n), (n, t) => { n.setMonth(n.getMonth() + t); }, (n) => n.getMonth()), fc.months = fc.month.range, fc.months.utc = fc.month.utc.range; var Bl = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6]; const Wl = [[fc.second, 1], [fc.second, 5], [fc.second, 15], [fc.second, 30], [fc.minute, 1], [fc.minute, 5], [fc.minute, 15], [fc.minute, 30], [fc.hour, 1], [fc.hour, 3], [fc.hour, 6], [fc.hour, 12], [fc.day, 1], [fc.day, 2], [fc.week, 1], [fc.month, 1], [fc.month, 3], [fc.year, 1]]; const Jl = Vl.multi([['.%L', function (n) { return n.getMilliseconds(); }], [':%S', function (n) { return n.getSeconds(); }], ['%I:%M', function (n) { return n.getMinutes(); }], ['%I %p', function (n) { return n.getHours(); }], ['%a %d', function (n) { return n.getDay() && n.getDate() != 1; }], ['%b %d', function (n) { return n.getDate() != 1; }], ['%B', function (n) { return n.getMonth(); }], ['%Y', Ce]]); var Gl = { range(n, t, e) { return ta.range(Math.ceil(n / e) * e, +t, e).map(Ko); }, floor: At, ceil: At }; Wl.year = fc.year, fc.scale = function () { return Go(ta.scale.linear(), Wl, Jl); }; const Kl = Wl.map((n) => [n[0].utc, n[1]]); const Ql = Xl.multi([['.%L', function (n) { return n.getUTCMilliseconds(); }], [':%S', function (n) { return n.getUTCSeconds(); }], ['%I:%M', function (n) { return n.getUTCMinutes(); }], ['%I %p', function (n) { return n.getUTCHours(); }], ['%a %d', function (n) { return n.getUTCDay() && n.getUTCDate() != 1; }], ['%b %d', function (n) { return n.getUTCDate() != 1; }], ['%B', function (n) { return n.getUTCMonth(); }], ['%Y', Ce]]); Kl.year = fc.year.utc, fc.scale.utc = function () { return Go(ta.scale.linear(), Kl, Ql); }, ta.text = Nt((n) => n.responseText), ta.json = function (n, t) { return Ct(n, 'application/json', Qo, t); }, ta.html = function (n, t) { return Ct(n, 'text/html', na, t); }, ta.xml = Nt((n) => n.responseXML), typeof define === 'function' && define.amd ? define(ta) : typeof module === 'object' && module.exports && (module.exports = ta), this.d3 = ta;
}());
