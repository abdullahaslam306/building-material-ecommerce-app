/*
 *  Bootstrap TouchSpin - v3.0.1
 *  A mobile and touch friendly input spinner component for Bootstrap 3.
 *  http://www.virtuosoft.eu/code/bootstrap-touchspin/
 *
 *  Made by István Ujj-Mészáros
 *  Under Apache License v2.0 License
 */
!(function (a) {
  function b(a, b) { return `${a}.touchspin_${b}`; } function c(c, d) { return a.map(c, (a) => b(a, d)); } let d = 0; a.fn.TouchSpin = function (b) {
    if (b === 'destroy') return void this.each(function () { const b = a(this); const d = b.data(); a(document).off(c(['mouseup', 'touchend', 'touchcancel', 'mousemove', 'touchmove', 'scroll', 'scrollstart'], d.spinnerid).join(' ')); }); const e = {
      min: 0, max: 100, initval: '', step: 1, decimals: 0, stepinterval: 100, forcestepdivisibility: 'round', stepintervaldelay: 500, verticalbuttons: !1, verticalupclass: 'glyphicon glyphicon-chevron-up', verticaldownclass: 'glyphicon glyphicon-chevron-down', prefix: '', postfix: '', prefix_extraclass: '', postfix_extraclass: '', booster: !0, boostat: 10, maxboostedstep: !1, mousewheel: !0, buttondown_class: 'btn btn-default', buttonup_class: 'btn btn-default',
    }; const f = {
      min: 'min', max: 'max', initval: 'init-val', step: 'step', decimals: 'decimals', stepinterval: 'step-interval', verticalbuttons: 'vertical-buttons', verticalupclass: 'vertical-up-class', verticaldownclass: 'vertical-down-class', forcestepdivisibility: 'force-step-divisibility', stepintervaldelay: 'step-interval-delay', prefix: 'prefix', postfix: 'postfix', prefix_extraclass: 'prefix-extra-class', postfix_extraclass: 'postfix-extra-class', booster: 'booster', boostat: 'boostat', maxboostedstep: 'max-boosted-step', mousewheel: 'mouse-wheel', buttondown_class: 'button-down-class', buttonup_class: 'button-up-class',
    }; return this.each(function () {
      function g() { if (!J.data('alreadyinitialized')) { if (J.data('alreadyinitialized', !0), d += 1, J.data('spinnerid', d), !J.is('input')) return void console.log('Must be an input.'); j(), h(), u(), m(), p(), q(), r(), s(), D.input.css('display', 'block'); } } function h() { B.initval !== '' && J.val() === '' && J.val(B.initval); } function i(a) { l(a), u(); let b = D.input.val(); b !== '' && (b = Number(D.input.val()), D.input.val(b.toFixed(B.decimals))); } function j() { B = a.extend({}, e, K, k(), b); } function k() { const b = {}; return a.each(f, (a, c) => { const d = `bts-${c}`; J.is(`[data-${d}]`) && (b[a] = J.data(d)); }), b; } function l(b) { B = a.extend({}, B, b); } function m() { let a = J.val(); const b = J.parent(); a !== '' && (a = Number(a).toFixed(B.decimals)), J.data('initvalue', a).val(a), J.addClass('form-control'), b.hasClass('input-group') ? n(b) : o(); } function n(b) { b.addClass('bootstrap-touchspin'); let c; let d; const e = J.prev(); const f = J.next(); const g = `<span class="input-group-addon bootstrap-touchspin-prefix">${B.prefix}</span>`; const h = `<span class="input-group-addon bootstrap-touchspin-postfix">${B.postfix}</span>`; e.hasClass('input-group-btn') ? (c = `<button class="${B.buttondown_class} bootstrap-touchspin-down" type="button">-</button>`, e.append(c)) : (c = `<span class="input-group-btn"><button class="${B.buttondown_class} bootstrap-touchspin-down" type="button">-</button></span>`, a(c).insertBefore(J)), f.hasClass('input-group-btn') ? (d = `<button class="${B.buttonup_class} bootstrap-touchspin-up" type="button">+</button>`, f.prepend(d)) : (d = `<span class="input-group-btn"><button class="${B.buttonup_class} bootstrap-touchspin-up" type="button">+</button></span>`, a(d).insertAfter(J)), a(g).insertBefore(J), a(h).insertAfter(J), C = b; } function o() { let b; b = B.verticalbuttons ? `<div class="input-group bootstrap-touchspin"><span class="input-group-addon bootstrap-touchspin-postfix">${B.prefix}</span><span class="input-group-addon bootstrap-touchspin-postfix">${B.postfix}</span><span class="input-group-btn-vertical"><button class="${B.buttondown_class} bootstrap-touchspin-up" type="button"><i class="${B.verticalupclass}"></i></button><button class="${B.buttonup_class} bootstrap-touchspin-down" type="button"><i class="${B.verticaldownclass}"></i></button></span></div>` : `<div class="input-group bootstrap-touchspin"><span class="input-group-btn"><button class="${B.buttondown_class} bootstrap-touchspin-down" type="button">-</button></span><span class="input-group-addon bootstrap-touchspin-prefix">${B.prefix}</span><span class="input-group-addon bootstrap-touchspin-postfix">${B.postfix}</span><span class="input-group-btn"><button class="${B.buttonup_class} bootstrap-touchspin-up" type="button">+</button></span></div>`, C = a(b).insertBefore(J), a('.bootstrap-touchspin-prefix', C).after(J), J.hasClass('input-sm') ? C.addClass('input-group-sm') : J.hasClass('input-lg') && C.addClass('input-group-lg'); } function p() {
        D = {
          down: a('.bootstrap-touchspin-down', C), up: a('.bootstrap-touchspin-up', C), input: a('input', C), prefix: a('.bootstrap-touchspin-prefix', C).addClass(B.prefix_extraclass), postfix: a('.bootstrap-touchspin-postfix', C).addClass(B.postfix_extraclass),
        };
      } function q() { B.prefix === '' && D.prefix.hide(), B.postfix === '' && D.postfix.hide(); } function r() { J.on('keydown', (a) => { const b = a.keyCode || a.which; b === 38 ? (M !== 'up' && (w(), z()), a.preventDefault()) : b === 40 && (M !== 'down' && (x(), y()), a.preventDefault()); }), J.on('keyup', (a) => { const b = a.keyCode || a.which; b === 38 ? A() : b === 40 && A(); }), J.on('blur', () => { u(); }), D.down.on('keydown', (a) => { const b = a.keyCode || a.which; (b === 32 || b === 13) && (M !== 'down' && (x(), y()), a.preventDefault()); }), D.down.on('keyup', (a) => { const b = a.keyCode || a.which; (b === 32 || b === 13) && A(); }), D.up.on('keydown', (a) => { const b = a.keyCode || a.which; (b === 32 || b === 13) && (M !== 'up' && (w(), z()), a.preventDefault()); }), D.up.on('keyup', (a) => { const b = a.keyCode || a.which; (b === 32 || b === 13) && A(); }), D.down.on('mousedown.touchspin', (a) => { D.down.off('touchstart.touchspin'), J.is(':disabled') || (x(), y(), a.preventDefault(), a.stopPropagation()); }), D.down.on('touchstart.touchspin', (a) => { D.down.off('mousedown.touchspin'), J.is(':disabled') || (x(), y(), a.preventDefault(), a.stopPropagation()); }), D.up.on('mousedown.touchspin', (a) => { D.up.off('touchstart.touchspin'), J.is(':disabled') || (w(), z(), a.preventDefault(), a.stopPropagation()); }), D.up.on('touchstart.touchspin', (a) => { D.up.off('mousedown.touchspin'), J.is(':disabled') || (w(), z(), a.preventDefault(), a.stopPropagation()); }), D.up.on('mouseout touchleave touchend touchcancel', (a) => { M && (a.stopPropagation(), A()); }), D.down.on('mouseout touchleave touchend touchcancel', (a) => { M && (a.stopPropagation(), A()); }), D.down.on('mousemove touchmove', (a) => { M && (a.stopPropagation(), a.preventDefault()); }), D.up.on('mousemove touchmove', (a) => { M && (a.stopPropagation(), a.preventDefault()); }), a(document).on(c(['mouseup', 'touchend', 'touchcancel'], d).join(' '), (a) => { M && (a.preventDefault(), A()); }), a(document).on(c(['mousemove', 'touchmove', 'scroll', 'scrollstart'], d).join(' '), (a) => { M && (a.preventDefault(), A()); }), J.on('mousewheel DOMMouseScroll', (a) => { if (B.mousewheel && J.is(':focus')) { const b = a.originalEvent.wheelDelta || -a.originalEvent.deltaY || -a.originalEvent.detail; a.stopPropagation(), a.preventDefault(), b < 0 ? x() : w(); } }); } function s() { J.on('touchspin.uponce', () => { A(), w(); }), J.on('touchspin.downonce', () => { A(), x(); }), J.on('touchspin.startupspin', () => { z(); }), J.on('touchspin.startdownspin', () => { y(); }), J.on('touchspin.stopspin', () => { A(); }), J.on('touchspin.updatesettings', (a, b) => { i(b); }); } function t(a) { switch (B.forcestepdivisibility) { case 'round': return (Math.round(a / B.step) * B.step).toFixed(B.decimals); case 'floor': return (Math.floor(a / B.step) * B.step).toFixed(B.decimals); case 'ceil': return (Math.ceil(a / B.step) * B.step).toFixed(B.decimals); default: return a; } } function u() { let a; let b; let c; a = J.val(), a !== '' && (B.decimals > 0 && a === '.' || (b = parseFloat(a), isNaN(b) && (b = 0), c = b, b.toString() !== a && (c = b), b < B.min && (c = B.min), b > B.max && (c = B.max), c = t(c), Number(a).toString() !== c.toString() && (J.val(c), J.trigger('change')))); } function v() { if (B.booster) { let a = Math.pow(2, Math.floor(L / B.boostat)) * B.step; return B.maxboostedstep && a > B.maxboostedstep && (a = B.maxboostedstep, E = Math.round(E / a) * a), Math.max(B.step, a); } return B.step; } function w() { u(), E = parseFloat(D.input.val()), isNaN(E) && (E = 0); const a = E; const b = v(); E += b, E > B.max && (E = B.max, J.trigger('touchspin.on.max'), A()), D.input.val(Number(E).toFixed(B.decimals)), a !== E && J.trigger('change'); } function x() { u(), E = parseFloat(D.input.val()), isNaN(E) && (E = 0); const a = E; const b = v(); E -= b, E < B.min && (E = B.min, J.trigger('touchspin.on.min'), A()), D.input.val(E.toFixed(B.decimals)), a !== E && J.trigger('change'); } function y() { A(), L = 0, M = 'down', J.trigger('touchspin.on.startspin'), J.trigger('touchspin.on.startdownspin'), H = setTimeout(() => { F = setInterval(() => { L++, x(); }, B.stepinterval); }, B.stepintervaldelay); } function z() { A(), L = 0, M = 'up', J.trigger('touchspin.on.startspin'), J.trigger('touchspin.on.startupspin'), I = setTimeout(() => { G = setInterval(() => { L++, w(); }, B.stepinterval); }, B.stepintervaldelay); } function A() { switch (clearTimeout(H), clearTimeout(I), clearInterval(F), clearInterval(G), M) { case 'up': J.trigger('touchspin.on.stopupspin'), J.trigger('touchspin.on.stopspin'); break; case 'down': J.trigger('touchspin.on.stopdownspin'), J.trigger('touchspin.on.stopspin'); }L = 0, M = !1; } let B; let C; let D; let E; let F; let G; let H; let I; var J = a(this); var K = J.data(); var L = 0; var M = !1; g();
    });
  };
}(jQuery));
